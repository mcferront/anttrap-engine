; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd@4
PUBLIC	_inflateBack@20
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\infback.c
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 c4 00 00
	00		 je	 $LN3@inflateBac
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 bb 00 00
	00		 jne	 $LN3@inflateBac
  0001b	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 b1 00 00
	00		 jne	 $LN3@inflateBac

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00025	53		 push	 ebx
  00026	57		 push	 edi
  00027	85 f6		 test	 esi, esi
  00029	0f 84 9b 00 00
	00		 je	 $LN5@inflateBac
  0002f	8b 5d 10	 mov	 ebx, DWORD PTR _window$[ebp]
  00032	85 db		 test	 ebx, ebx
  00034	0f 84 90 00 00
	00		 je	 $LN5@inflateBac
  0003a	8b 7d 0c	 mov	 edi, DWORD PTR _windowBits$[ebp]
  0003d	8d 47 f8	 lea	 eax, DWORD PTR [edi-8]
  00040	83 f8 07	 cmp	 eax, 7
  00043	0f 87 81 00 00
	00		 ja	 $LN5@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 44   :     if (strm->zalloc == (alloc_func)0) {

  00049	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0004c	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00053	85 c0		 test	 eax, eax
  00055	75 13		 jne	 SHORT $LN10@inflateBac

; 45   :         strm->zalloc = zcalloc;
; 46   :         strm->opaque = (voidpf)0;

  00057	89 46 28	 mov	 DWORD PTR [esi+40], eax
  0005a	33 c9		 xor	 ecx, ecx
  0005c	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  00063	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00068	eb 03		 jmp	 SHORT $LN6@inflateBac
$LN10@inflateBac:
  0006a	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN6@inflateBac:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  0006d	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00071	75 07		 jne	 SHORT $LN7@inflateBac
  00073	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN7@inflateBac:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  0007a	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0007f	6a 01		 push	 1
  00081	51		 push	 ecx
  00082	ff d0		 call	 eax
  00084	8b d0		 mov	 edx, eax
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH

; 50   :                                                sizeof(struct inflate_state));
; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  00089	85 d2		 test	 edx, edx
  0008b	75 0a		 jne	 SHORT $LN8@inflateBac
  0008d	5f		 pop	 edi
  0008e	5b		 pop	 ebx
  0008f	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00092	5e		 pop	 esi

; 61   : }

  00093	5d		 pop	 ebp
  00094	c2 14 00	 ret	 20			; 00000014H
$LN8@inflateBac:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  00097	89 56 1c	 mov	 DWORD PTR [esi+28], edx

; 54   :     state->dmax = 32768U;
; 55   :     state->wbits = windowBits;
; 56   :     state->wsize = 1U << windowBits;

  0009a	8b cf		 mov	 ecx, edi
  0009c	89 7a 24	 mov	 DWORD PTR [edx+36], edi
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	5f		 pop	 edi
  000a5	d3 e0		 shl	 eax, cl

; 57   :     state->window = window;

  000a7	89 5a 34	 mov	 DWORD PTR [edx+52], ebx
  000aa	5b		 pop	 ebx
  000ab	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 58   :     state->wnext = 0;
; 59   :     state->whave = 0;
; 60   :     return Z_OK;

  000ae	33 c0		 xor	 eax, eax
  000b0	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [edx+20], 32768 ; 00008000H
  000b7	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
  000be	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0
  000c5	5e		 pop	 esi

; 61   : }

  000c6	5d		 pop	 ebp
  000c7	c2 14 00	 ret	 20			; 00000014H
$LN5@inflateBac:
  000ca	5f		 pop	 edi
  000cb	5b		 pop	 ebx

; 42   :         return Z_STREAM_ERROR;

  000cc	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000d1	5e		 pop	 esi

; 61   : }

  000d2	5d		 pop	 ebp
  000d3	c2 14 00	 ret	 20			; 00000014H
$LN3@inflateBac:

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;

  000d6	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000db	5e		 pop	 esi

; 61   : }

  000dc	5d		 pop	 ebp
  000dd	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\infback.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00000	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 111  :     state->lenbits = 9;

  00007	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 112  :     state->distcode = distfix;

  0000e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 113  :     state->distbits = 5;

  00015	c7 41 58 05 00
	00 00		 mov	 DWORD PTR [ecx+88], 5

; 114  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\infback.c
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
_from$1$ = -52						; size = 4
tv3527 = -52						; size = 4
tv3508 = -52						; size = 4
tv3507 = -52						; size = 4
tv3479 = -48						; size = 4
tv3478 = -48						; size = 4
tv3470 = -48						; size = 4
$T1 = -44						; size = 4
$T2 = -44						; size = 4
$T3 = -44						; size = 4
_copy$2$ = -44						; size = 4
tv3573 = -44						; size = 4
tv3533 = -44						; size = 4
tv3572 = -40						; size = 4
tv3530 = -40						; size = 4
$T4 = -36						; size = 4
tv3528 = -36						; size = 4
$T5 = -32						; size = 4
tv3480 = -32						; size = 4
_here$ = -32						; size = 4
$T6 = -28						; size = 4
_copy$1$ = -28						; size = 4
tv3520 = -28						; size = 4
_last$ = -28						; size = 4
_put$1$ = -24						; size = 4
_left$1$ = -20						; size = 4
_here$1$ = -16						; size = 4
_bits$1$ = -16						; size = 4
_state$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_next$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 84 a5 0d 00
	00		 je	 $LN265@inflateBac
  00011	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00014	89 55 f4	 mov	 DWORD PTR _state$1$[ebp], edx
  00017	85 d2		 test	 edx, edx
  00019	0f 84 97 0d 00
	00		 je	 $LN265@inflateBac

; 266  :     state = (struct inflate_state FAR *)strm->state;
; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  0001f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00026	53		 push	 ebx

; 270  :     state->mode = TYPE;

  00027	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 271  :     state->last = 0;

  0002d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 272  :     state->whave = 0;

  00034	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 273  :     next = strm->next_in;

  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  00040	56		 push	 esi
  00041	57		 push	 edi
  00042	85 c0		 test	 eax, eax

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00044	74 05		 je	 SHORT $LN356@inflateBac
  00046	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00049	eb 02		 jmp	 SHORT $LN357@inflateBac
$LN356@inflateBac:
  0004b	33 f6		 xor	 esi, esi
$LN357@inflateBac:

; 275  :     hold = 0;
; 276  :     bits = 0;
; 277  :     put = state->window;

  0004d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00050	33 ff		 xor	 edi, edi
  00052	89 45 e8	 mov	 DWORD PTR _put$1$[ebp], eax
  00055	33 db		 xor	 ebx, ebx

; 278  :     left = state->wsize;

  00057	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0005a	89 45 ec	 mov	 DWORD PTR _left$1$[ebp], eax

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  0005d	8b 02		 mov	 eax, DWORD PTR [edx]
  0005f	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00062	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00065	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  00068	83 f8 12	 cmp	 eax, 18			; 00000012H
  0006b	0f 87 e2 0c 00
	00		 ja	 $LN354@inflateBac
$LN513@inflateBac:
  00071	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00074	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN496@inflateBac[eax]
  0007b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN515@inflateBac[eax*4]
$LN266@inflateBac:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  00082	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00086	74 1a		 je	 SHORT $LN12@inflateBac

; 286  :                 BYTEBITS();

  00088	8b cb		 mov	 ecx, ebx

; 287  :                 state->mode = DONE;

  0008a	c7 02 1c 00 00
	00		 mov	 DWORD PTR [edx], 28	; 0000001cH
  00090	83 e1 07	 and	 ecx, 7
  00093	d3 ef		 shr	 edi, cl
  00095	2b d9		 sub	 ebx, ecx
  00097	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  0009a	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 288  :                 break;

  0009d	e9 a3 0c 00 00	 jmp	 $LN503@inflateBac
$LN12@inflateBac:

; 289  :             }
; 290  :             NEEDBITS(3);

  000a2	83 fb 03	 cmp	 ebx, 3
  000a5	73 37		 jae	 SHORT $LN10@inflateBac
$LL13@inflateBac:
  000a7	85 f6		 test	 esi, esi
  000a9	75 15		 jne	 SHORT $LN18@inflateBac
  000ab	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  000ae	50		 push	 eax
  000af	51		 push	 ecx
  000b0	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  000b3	8b f0		 mov	 esi, eax
  000b5	83 c4 08	 add	 esp, 8
  000b8	85 f6		 test	 esi, esi
  000ba	0f 84 ae 0c 00
	00		 je	 $LN383@inflateBac
$LN18@inflateBac:
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  000c3	8b cb		 mov	 ecx, ebx
  000c5	83 c3 08	 add	 ebx, 8
  000c8	4e		 dec	 esi
  000c9	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000cc	ff 45 fc	 inc	 DWORD PTR _next$[ebp]
  000cf	d3 e0		 shl	 eax, cl
  000d1	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  000d4	03 f8		 add	 edi, eax
  000d6	83 fb 03	 cmp	 ebx, 3
  000d9	72 cc		 jb	 SHORT $LL13@inflateBac
  000db	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN10@inflateBac:

; 291  :             state->last = BITS(1);

  000de	8b c7		 mov	 eax, edi

; 292  :             DROPBITS(1);

  000e0	d1 ef		 shr	 edi, 1
  000e2	83 e0 01	 and	 eax, 1
  000e5	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 293  :             switch (BITS(2)) {

  000e8	8b c7		 mov	 eax, edi
  000ea	83 e0 03	 and	 eax, 3
  000ed	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN516@inflateBac[eax*4]
$LN270@inflateBac:

; 313  :             }
; 314  :             DROPBITS(2);

  000f4	c1 ef 02	 shr	 edi, 2
  000f7	83 eb 03	 sub	 ebx, 3
  000fa	c7 02 0d 00 00
	00		 mov	 DWORD PTR [edx], 13	; 0000000dH
  00100	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00103	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 315  :             break;

  00106	e9 3a 0c 00 00	 jmp	 $LN503@inflateBac
$LN271@inflateBac:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;
; 298  :                 break;
; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  0010b	8b ca		 mov	 ecx, edx
  0010d	e8 00 00 00 00	 call	 _fixedtables

; 313  :             }
; 314  :             DROPBITS(2);

  00112	c1 ef 02	 shr	 edi, 2
  00115	83 eb 03	 sub	 ebx, 3
  00118	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H
  0011e	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00121	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 315  :             break;

  00124	e9 1c 0c 00 00	 jmp	 $LN503@inflateBac
$LN272@inflateBac:

; 313  :             }
; 314  :             DROPBITS(2);

  00129	c1 ef 02	 shr	 edi, 2
  0012c	83 eb 03	 sub	 ebx, 3
  0012f	c7 02 10 00 00
	00		 mov	 DWORD PTR [edx], 16	; 00000010H
  00135	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00138	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 315  :             break;

  0013b	e9 05 0c 00 00	 jmp	 $LN503@inflateBac
$LN273@inflateBac:

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */
; 304  :                 break;
; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;
; 309  :                 break;
; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  00140	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00143	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 312  :                 state->mode = BAD;

  0014a	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH
$LN28@inflateBac:

; 313  :             }
; 314  :             DROPBITS(2);

  00150	c1 ef 02	 shr	 edi, 2
  00153	83 eb 03	 sub	 ebx, 3
  00156	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00159	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 315  :             break;

  0015c	e9 e4 0b 00 00	 jmp	 $LN503@inflateBac
$LN31@inflateBac:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  00161	8b cb		 mov	 ecx, ebx
  00163	83 e1 07	 and	 ecx, 7
  00166	2b d9		 sub	 ebx, ecx
  00168	d3 ef		 shr	 edi, cl
  0016a	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  0016d	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 320  :             NEEDBITS(32);

  00170	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00173	73 3c		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  00175	85 f6		 test	 esi, esi
  00177	75 17		 jne	 SHORT $LN40@inflateBac
  00179	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0017c	50		 push	 eax
  0017d	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00180	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00183	8b f0		 mov	 esi, eax
  00185	83 c4 08	 add	 esp, 8
  00188	85 f6		 test	 esi, esi
  0018a	0f 84 de 0b 00
	00		 je	 $LN383@inflateBac
$LN40@inflateBac:
  00190	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00193	8b cb		 mov	 ecx, ebx
  00195	83 c3 08	 add	 ebx, 8
  00198	4e		 dec	 esi
  00199	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  0019c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0019f	ff 45 fc	 inc	 DWORD PTR _next$[ebp]
  001a2	d3 e0		 shl	 eax, cl
  001a4	03 f8		 add	 edi, eax
  001a6	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  001a9	83 fb 20	 cmp	 ebx, 32			; 00000020H
  001ac	72 c7		 jb	 SHORT $LL35@inflateBac
  001ae	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN32@inflateBac:

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001b1	8b c7		 mov	 eax, edi
  001b3	0f b7 cf	 movzx	 ecx, di
  001b6	f7 d0		 not	 eax
  001b8	89 4d dc	 mov	 DWORD PTR $T4[ebp], ecx
  001bb	c1 e8 10	 shr	 eax, 16			; 00000010H
  001be	3b c8		 cmp	 ecx, eax
  001c0	74 15		 je	 SHORT $LN277@inflateBac

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  001c2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001c5	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@

; 323  :                 state->mode = BAD;

  001cc	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 324  :                 break;

  001d2	e9 6e 0b 00 00	 jmp	 $LN503@inflateBac
$LN277@inflateBac:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;
; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  001d7	33 ff		 xor	 edi, edi
  001d9	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
  001dc	33 db		 xor	 ebx, ebx
  001de	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  001e1	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  001e4	85 c9		 test	 ecx, ecx
  001e6	0f 84 93 00 00
	00		 je	 $LN47@inflateBac
  001ec	8b 45 ec	 mov	 eax, DWORD PTR _left$1$[ebp]
  001ef	90		 npad	 1
$LL46@inflateBac:

; 333  :                 copy = state->length;
; 334  :                 PULL();

  001f0	85 f6		 test	 esi, esi
  001f2	75 1d		 jne	 SHORT $LN48@inflateBac
  001f4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  001f7	50		 push	 eax
  001f8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  001fb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  001fe	8b f0		 mov	 esi, eax
  00200	83 c4 08	 add	 esp, 8
  00203	85 f6		 test	 esi, esi
  00205	0f 84 71 0b 00
	00		 je	 $LN385@inflateBac
  0020b	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  0020e	8b 45 ec	 mov	 eax, DWORD PTR _left$1$[ebp]
$LN48@inflateBac:

; 335  :                 ROOM();

  00211	85 c0		 test	 eax, eax
  00213	75 22		 jne	 SHORT $LN51@inflateBac
  00215	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00218	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0021b	51		 push	 ecx
  0021c	50		 push	 eax
  0021d	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00220	89 45 e8	 mov	 DWORD PTR _put$1$[ebp], eax
  00223	89 4d ec	 mov	 DWORD PTR _left$1$[ebp], ecx
  00226	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
  00229	ff 55 14	 call	 DWORD PTR _out$[ebp]
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022f	85 c0		 test	 eax, eax
  00231	0f 85 3e 0b 00
	00		 jne	 $LN386@inflateBac
$LN51@inflateBac:

; 336  :                 if (copy > have) copy = have;
; 337  :                 if (copy > left) copy = left;

  00237	39 75 dc	 cmp	 DWORD PTR $T4[ebp], esi
  0023a	8b c6		 mov	 eax, esi

; 338  :                 zmemcpy(put, next, copy);

  0023c	8b 7d ec	 mov	 edi, DWORD PTR _left$1$[ebp]
  0023f	0f 46 45 dc	 cmovbe	 eax, DWORD PTR $T4[ebp]
  00243	3b c7		 cmp	 eax, edi
  00245	0f 46 f8	 cmovbe	 edi, eax
  00248	8b 45 e8	 mov	 eax, DWORD PTR _put$1$[ebp]
  0024b	57		 push	 edi
  0024c	ff 75 fc	 push	 DWORD PTR _next$[ebp]
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 _memcpy

; 339  :                 have -= copy;
; 340  :                 next += copy;
; 341  :                 left -= copy;
; 342  :                 put += copy;
; 343  :                 state->length -= copy;

  00255	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00258	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025b	01 7d fc	 add	 DWORD PTR _next$[ebp], edi
  0025e	2b f7		 sub	 esi, edi
  00260	8b 45 ec	 mov	 eax, DWORD PTR _left$1$[ebp]
  00263	01 7d e8	 add	 DWORD PTR _put$1$[ebp], edi
  00266	2b c7		 sub	 eax, edi
  00268	8b 4a 40	 mov	 ecx, DWORD PTR [edx+64]
  0026b	2b cf		 sub	 ecx, edi
  0026d	89 45 ec	 mov	 DWORD PTR _left$1$[ebp], eax
  00270	89 4d dc	 mov	 DWORD PTR $T4[ebp], ecx
  00273	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
  00276	0f 85 74 ff ff
	ff		 jne	 $LL46@inflateBac
  0027c	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
$LN47@inflateBac:

; 344  :             }
; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  0027f	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 347  :             break;

  00285	e9 bb 0a 00 00	 jmp	 $LN503@inflateBac
$LN56@inflateBac:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  0028a	83 fb 0e	 cmp	 ebx, 14			; 0000000eH
  0028d	73 38		 jae	 SHORT $LN54@inflateBac
  0028f	90		 npad	 1
$LL57@inflateBac:
  00290	85 f6		 test	 esi, esi
  00292	75 15		 jne	 SHORT $LN62@inflateBac
  00294	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00297	50		 push	 eax
  00298	51		 push	 ecx
  00299	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0029c	8b f0		 mov	 esi, eax
  0029e	83 c4 08	 add	 esp, 8
  002a1	85 f6		 test	 esi, esi
  002a3	0f 84 c5 0a 00
	00		 je	 $LN383@inflateBac
$LN62@inflateBac:
  002a9	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  002ac	8b cb		 mov	 ecx, ebx
  002ae	83 c3 08	 add	 ebx, 8
  002b1	4e		 dec	 esi
  002b2	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  002b5	ff 45 fc	 inc	 DWORD PTR _next$[ebp]
  002b8	d3 e0		 shl	 eax, cl
  002ba	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  002bd	03 f8		 add	 edi, eax
  002bf	83 fb 0e	 cmp	 ebx, 14			; 0000000eH
  002c2	72 cc		 jb	 SHORT $LL57@inflateBac
  002c4	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN54@inflateBac:

; 352  :             state->nlen = BITS(5) + 257;

  002c7	8b cf		 mov	 ecx, edi

; 353  :             DROPBITS(5);
; 354  :             state->ndist = BITS(5) + 1;
; 355  :             DROPBITS(5);
; 356  :             state->ncode = BITS(4) + 4;
; 357  :             DROPBITS(4);

  002c9	83 eb 0e	 sub	 ebx, 14			; 0000000eH
  002cc	c1 ef 05	 shr	 edi, 5
  002cf	83 e1 1f	 and	 ecx, 31			; 0000001fH
  002d2	8b c7		 mov	 eax, edi
  002d4	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  002d7	83 e0 1f	 and	 eax, 31			; 0000001fH
  002da	c1 ef 05	 shr	 edi, 5
  002dd	40		 inc	 eax
  002de	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  002e4	89 45 d4	 mov	 DWORD PTR tv3573[ebp], eax
  002e7	89 42 64	 mov	 DWORD PTR [edx+100], eax
  002ea	8b c7		 mov	 eax, edi
  002ec	83 e0 0f	 and	 eax, 15			; 0000000fH
  002ef	c1 ef 04	 shr	 edi, 4
  002f2	83 c0 04	 add	 eax, 4
  002f5	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
  002f8	89 45 d8	 mov	 DWORD PTR tv3572[ebp], eax
  002fb	89 42 5c	 mov	 DWORD PTR [edx+92], eax
  002fe	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  00301	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00307	0f 87 35 05 00
	00		 ja	 $LN288@inflateBac
  0030d	83 7d d4 1e	 cmp	 DWORD PTR tv3573[ebp], 30 ; 0000001eH
  00311	0f 87 2b 05 00
	00		 ja	 $LN288@inflateBac

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  00317	33 c0		 xor	 eax, eax
  00319	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 369  :             while (state->have < state->ncode) {

  00320	39 45 d8	 cmp	 DWORD PTR tv3572[ebp], eax
  00323	76 6e		 jbe	 SHORT $LN365@inflateBac
$LL74@inflateBac:

; 370  :                 NEEDBITS(3);

  00325	83 fb 03	 cmp	 ebx, 3
  00328	73 3d		 jae	 SHORT $LN76@inflateBac
  0032a	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0032d	0f 1f 00	 npad	 3
$LL79@inflateBac:
  00330	85 f6		 test	 esi, esi
  00332	75 1a		 jne	 SHORT $LN84@inflateBac
  00334	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00337	50		 push	 eax
  00338	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0033b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0033e	8b f0		 mov	 esi, eax
  00340	83 c4 08	 add	 esp, 8
  00343	85 f6		 test	 esi, esi
  00345	0f 84 23 0a 00
	00		 je	 $LN383@inflateBac
  0034b	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
$LN84@inflateBac:
  0034e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00351	8b cb		 mov	 ecx, ebx
  00353	d3 e0		 shl	 eax, cl
  00355	42		 inc	 edx
  00356	83 c3 08	 add	 ebx, 8
  00359	89 55 fc	 mov	 DWORD PTR _next$[ebp], edx
  0035c	4e		 dec	 esi
  0035d	03 f8		 add	 edi, eax
  0035f	83 fb 03	 cmp	 ebx, 3
  00362	72 cc		 jb	 SHORT $LL79@inflateBac
  00364	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN76@inflateBac:

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00367	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0036a	8b cf		 mov	 ecx, edi
  0036c	83 e1 07	 and	 ecx, 7

; 372  :                 DROPBITS(3);

  0036f	c1 ef 03	 shr	 edi, 3
  00372	83 eb 03	 sub	 ebx, 3
  00375	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00378	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  0037b	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[eax*2]
  00383	66 89 4c 42 70	 mov	 WORD PTR [edx+eax*2+112], cx
  00388	ff 42 68	 inc	 DWORD PTR [edx+104]
  0038b	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0038e	3b 42 5c	 cmp	 eax, DWORD PTR [edx+92]
  00391	72 92		 jb	 SHORT $LL74@inflateBac
$LN365@inflateBac:

; 373  :             }
; 374  :             while (state->have < 19)

  00393	83 f8 13	 cmp	 eax, 19			; 00000013H
  00396	73 23		 jae	 SHORT $LN91@inflateBac
  00398	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL90@inflateBac:

; 375  :                 state->lens[order[state->have++]] = 0;

  003a0	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  003a3	33 c9		 xor	 ecx, ecx
  003a5	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[eax*2]
  003ad	66 89 4c 42 70	 mov	 WORD PTR [edx+eax*2+112], cx
  003b2	ff 42 68	 inc	 DWORD PTR [edx+104]
  003b5	83 7a 68 13	 cmp	 DWORD PTR [edx+104], 19	; 00000013H
  003b9	72 e5		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 376  :             state->next = state->codes;

  003bb	8d 82 30 05 00
	00		 lea	 eax, DWORD PTR [edx+1328]

; 377  :             state->lencode = (code const FAR *)(state->next);
; 378  :             state->lenbits = 7;

  003c1	c7 42 54 07 00
	00 00		 mov	 DWORD PTR [edx+84], 7
  003c8	8d 4a 6c	 lea	 ecx, DWORD PTR [edx+108]
  003cb	89 42 4c	 mov	 DWORD PTR [edx+76], eax
  003ce	89 01		 mov	 DWORD PTR [ecx], eax
  003d0	8d 42 54	 lea	 eax, DWORD PTR [edx+84]
  003d3	89 4d d4	 mov	 DWORD PTR tv3533[ebp], ecx

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  003d6	8d 8a f0 02 00
	00		 lea	 ecx, DWORD PTR [edx+752]
  003dc	51		 push	 ecx
  003dd	89 4d dc	 mov	 DWORD PTR tv3528[ebp], ecx
  003e0	83 c2 70	 add	 edx, 112		; 00000070H
  003e3	8b 4d d4	 mov	 ecx, DWORD PTR tv3533[ebp]
  003e6	50		 push	 eax
  003e7	51		 push	 ecx
  003e8	6a 13		 push	 19			; 00000013H
  003ea	33 c9		 xor	 ecx, ecx
  003ec	89 45 d8	 mov	 DWORD PTR tv3530[ebp], eax
  003ef	89 55 cc	 mov	 DWORD PTR tv3527[ebp], edx
  003f2	e8 00 00 00 00	 call	 _inflate_table

; 380  :                                 &(state->lenbits), state->work);
; 381  :             if (ret) {

  003f7	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  003fa	83 c4 10	 add	 esp, 16			; 00000010H
  003fd	85 c0		 test	 eax, eax
  003ff	74 15		 je	 SHORT $LN291@inflateBac

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  00401	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00404	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@

; 383  :                 state->mode = BAD;

  0040b	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 384  :                 break;

  00411	e9 2f 09 00 00	 jmp	 $LN503@inflateBac
$LN291@inflateBac:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  00416	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00419	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0
  00420	03 42 60	 add	 eax, DWORD PTR [edx+96]
  00423	0f 84 c1 02 00
	00		 je	 $LN93@inflateBac
  00429	0f 1f 80 00 00
	00 00		 npad	 7
$LL92@inflateBac:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  00430	8b 45 d8	 mov	 eax, DWORD PTR tv3530[ebp]
  00433	ba 01 00 00 00	 mov	 edx, 1
  00438	8b 08		 mov	 ecx, DWORD PTR [eax]
  0043a	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0043d	d3 e2		 shl	 edx, cl
  0043f	4a		 dec	 edx
  00440	23 d7		 and	 edx, edi

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  00442	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
  00445	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00448	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  0044b	8b c8		 mov	 ecx, eax
  0044d	c1 e9 08	 shr	 ecx, 8
  00450	8b d0		 mov	 edx, eax
  00452	89 45 f0	 mov	 DWORD PTR _here$1$[ebp], eax
  00455	89 45 e0	 mov	 DWORD PTR _here$[ebp], eax
  00458	0f b6 c1	 movzx	 eax, cl
  0045b	c1 ea 10	 shr	 edx, 16			; 00000010H
  0045e	3b c3		 cmp	 eax, ebx
  00460	76 60		 jbe	 SHORT $LN462@inflateBac
$LL94@inflateBac:

; 394  :                     PULLBYTE();

  00462	85 f6		 test	 esi, esi
  00464	75 1a		 jne	 SHORT $LN100@inflateBac
  00466	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00469	50		 push	 eax
  0046a	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0046d	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00470	8b f0		 mov	 esi, eax
  00472	83 c4 08	 add	 esp, 8
  00475	85 f6		 test	 esi, esi
  00477	0f 84 f1 08 00
	00		 je	 $LN383@inflateBac
  0047d	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
$LN100@inflateBac:
  00480	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00483	8b cb		 mov	 ecx, ebx
  00485	d3 e0		 shl	 eax, cl
  00487	47		 inc	 edi
  00488	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  0048b	ba 01 00 00 00	 mov	 edx, 1
  00490	8b 45 d8	 mov	 eax, DWORD PTR tv3530[ebp]
  00493	83 c3 08	 add	 ebx, 8
  00496	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
  00499	4e		 dec	 esi
  0049a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0049c	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0049f	d3 e2		 shl	 edx, cl
  004a1	4a		 dec	 edx
  004a2	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  004a5	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  004a8	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  004ab	8b c8		 mov	 ecx, eax
  004ad	c1 e9 08	 shr	 ecx, 8
  004b0	8b d0		 mov	 edx, eax
  004b2	89 45 f0	 mov	 DWORD PTR _here$1$[ebp], eax
  004b5	89 45 e0	 mov	 DWORD PTR _here$[ebp], eax
  004b8	0f b6 c1	 movzx	 eax, cl
  004bb	c1 ea 10	 shr	 edx, 16			; 00000010H
  004be	3b c3		 cmp	 eax, ebx
  004c0	77 a0		 ja	 SHORT $LL94@inflateBac
$LN462@inflateBac:

; 395  :                 }
; 396  :                 if (here.val < 16) {

  004c2	0f b7 c2	 movzx	 eax, dx
  004c5	0f b7 d0	 movzx	 edx, ax
  004c8	89 4d e4	 mov	 DWORD PTR $T6[ebp], ecx
  004cb	89 45 d0	 mov	 DWORD PTR tv3470[ebp], eax
  004ce	83 fa 10	 cmp	 edx, 16			; 00000010H
  004d1	73 6f		 jae	 SHORT $LN295@inflateBac

; 397  :                     NEEDBITS(here.bits);

  004d3	0f b6 c1	 movzx	 eax, cl
  004d6	89 45 e4	 mov	 DWORD PTR tv3520[ebp], eax
  004d9	3b d8		 cmp	 ebx, eax
  004db	73 38		 jae	 SHORT $LN103@inflateBac
  004dd	0f 1f 00	 npad	 3
$LL106@inflateBac:
  004e0	85 f6		 test	 esi, esi
  004e2	75 1a		 jne	 SHORT $LN111@inflateBac
  004e4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  004e7	50		 push	 eax
  004e8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  004eb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  004ee	8b f0		 mov	 esi, eax
  004f0	83 c4 08	 add	 esp, 8
  004f3	85 f6		 test	 esi, esi
  004f5	0f 84 73 08 00
	00		 je	 $LN383@inflateBac
  004fb	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
$LN111@inflateBac:
  004fe	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00501	8b cb		 mov	 ecx, ebx
  00503	d3 e0		 shl	 eax, cl
  00505	47		 inc	 edi
  00506	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00509	83 c3 08	 add	 ebx, 8
  0050c	4e		 dec	 esi
  0050d	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
  00510	3b 5d e4	 cmp	 ebx, DWORD PTR tv3520[ebp]
  00513	72 cb		 jb	 SHORT $LL106@inflateBac
$LN103@inflateBac:

; 398  :                     DROPBITS(here.bits);
; 399  :                     state->lens[state->have++] = here.val;

  00515	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00518	8b 45 f0	 mov	 eax, DWORD PTR _here$1$[ebp]
  0051b	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  0051e	0f b6 cc	 movzx	 ecx, ah
  00521	66 8b 45 e2	 mov	 ax, WORD PTR _here$[ebp+2]
  00525	2b d9		 sub	 ebx, ecx
  00527	d3 ef		 shr	 edi, cl
  00529	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  0052c	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  0052f	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  00532	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  00537	ff 42 68	 inc	 DWORD PTR [edx+104]
  0053a	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]

; 400  :                 }

  0053d	e9 9a 01 00 00	 jmp	 $LN422@inflateBac
$LN295@inflateBac:

; 401  :                 else {
; 402  :                     if (here.val == 16) {

  00542	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  00545	0f b6 c0	 movzx	 eax, al
  00548	75 7e		 jne	 SHORT $LN299@inflateBac

; 403  :                         NEEDBITS(here.bits + 2);

  0054a	83 c0 02	 add	 eax, 2
  0054d	89 45 e0	 mov	 DWORD PTR tv3480[ebp], eax
  00550	3b d8		 cmp	 ebx, eax
  00552	73 35		 jae	 SHORT $LN117@inflateBac
$LL120@inflateBac:
  00554	85 f6		 test	 esi, esi
  00556	75 1a		 jne	 SHORT $LN125@inflateBac
  00558	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  0055b	50		 push	 eax
  0055c	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0055f	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00562	8b f0		 mov	 esi, eax
  00564	83 c4 08	 add	 esp, 8
  00567	85 f6		 test	 esi, esi
  00569	0f 84 ff 07 00
	00		 je	 $LN383@inflateBac
  0056f	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
$LN125@inflateBac:
  00572	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00575	8b cb		 mov	 ecx, ebx
  00577	d3 e0		 shl	 eax, cl
  00579	47		 inc	 edi
  0057a	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  0057d	83 c3 08	 add	 ebx, 8
  00580	4e		 dec	 esi
  00581	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
  00584	3b 5d e0	 cmp	 ebx, DWORD PTR tv3480[ebp]
  00587	72 cb		 jb	 SHORT $LL120@inflateBac
$LN117@inflateBac:

; 404  :                         DROPBITS(here.bits);

  00589	8b 45 f0	 mov	 eax, DWORD PTR _here$1$[ebp]

; 405  :                         if (state->have == 0) {

  0058c	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  0058f	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  00592	0f b6 cc	 movzx	 ecx, ah
  00595	d3 ef		 shr	 edi, cl
  00597	2b d9		 sub	 ebx, ecx
  00599	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  0059c	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  0059f	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  005a2	85 c0		 test	 eax, eax
  005a4	0f 84 68 01 00
	00		 je	 $LN395@inflateBac

; 406  :                             strm->msg = (char *)"invalid bit length repeat";
; 407  :                             state->mode = BAD;
; 408  :                             break;
; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);
; 411  :                         copy = 3 + BITS(2);
; 412  :                         DROPBITS(2);

  005aa	0f b7 44 42 6e	 movzx	 eax, WORD PTR [edx+eax*2+110]
  005af	8b cf		 mov	 ecx, edi
  005b1	83 e1 03	 and	 ecx, 3
  005b4	c1 ef 02	 shr	 edi, 2
  005b7	83 c1 03	 add	 ecx, 3
  005ba	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
  005bd	89 4d e4	 mov	 DWORD PTR _copy$1$[ebp], ecx
  005c0	83 eb 02	 sub	 ebx, 2

; 413  :                     }

  005c3	e9 d9 00 00 00	 jmp	 $LN511@inflateBac
$LN299@inflateBac:

; 414  :                     else if (here.val == 17) {

  005c8	66 83 7d d0 11	 cmp	 WORD PTR tv3470[ebp], 17 ; 00000011H
  005cd	75 66		 jne	 SHORT $LN153@inflateBac

; 415  :                         NEEDBITS(here.bits + 3);

  005cf	83 c0 03	 add	 eax, 3
  005d2	89 45 d0	 mov	 DWORD PTR tv3479[ebp], eax
  005d5	3b d8		 cmp	 ebx, eax
  005d7	73 3c		 jae	 SHORT $LN134@inflateBac
  005d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL137@inflateBac:
  005e0	85 f6		 test	 esi, esi
  005e2	75 1a		 jne	 SHORT $LN142@inflateBac
  005e4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  005e7	50		 push	 eax
  005e8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  005eb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  005ee	8b f0		 mov	 esi, eax
  005f0	83 c4 08	 add	 esp, 8
  005f3	85 f6		 test	 esi, esi
  005f5	0f 84 73 07 00
	00		 je	 $LN383@inflateBac
  005fb	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
$LN142@inflateBac:
  005fe	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00601	8b cb		 mov	 ecx, ebx
  00603	d3 e0		 shl	 eax, cl
  00605	47		 inc	 edi
  00606	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00609	83 c3 08	 add	 ebx, 8
  0060c	4e		 dec	 esi
  0060d	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
  00610	3b 5d d0	 cmp	 ebx, DWORD PTR tv3479[ebp]
  00613	72 cb		 jb	 SHORT $LL137@inflateBac
$LN134@inflateBac:

; 416  :                         DROPBITS(here.bits);

  00615	8b 45 f0	 mov	 eax, DWORD PTR _here$1$[ebp]
  00618	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  0061b	0f b6 cc	 movzx	 ecx, ah
  0061e	d3 ef		 shr	 edi, cl

; 417  :                         len = 0;
; 418  :                         copy = 3 + BITS(3);

  00620	8b c7		 mov	 eax, edi
  00622	83 e0 07	 and	 eax, 7
  00625	83 c0 03	 add	 eax, 3

; 419  :                         DROPBITS(3);

  00628	c1 ef 03	 shr	 edi, 3
  0062b	89 45 e4	 mov	 DWORD PTR _copy$1$[ebp], eax
  0062e	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 420  :                     }

  00633	eb 5e		 jmp	 SHORT $LN512@inflateBac
$LN153@inflateBac:

; 421  :                     else {
; 422  :                         NEEDBITS(here.bits + 7);

  00635	83 c0 07	 add	 eax, 7
  00638	89 45 d0	 mov	 DWORD PTR tv3478[ebp], eax
  0063b	3b d8		 cmp	 ebx, eax
  0063d	73 36		 jae	 SHORT $LN151@inflateBac
  0063f	90		 npad	 1
$LL154@inflateBac:
  00640	85 f6		 test	 esi, esi
  00642	75 1a		 jne	 SHORT $LN159@inflateBac
  00644	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00647	50		 push	 eax
  00648	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0064b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0064e	8b f0		 mov	 esi, eax
  00650	83 c4 08	 add	 esp, 8
  00653	85 f6		 test	 esi, esi
  00655	0f 84 13 07 00
	00		 je	 $LN383@inflateBac
  0065b	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
$LN159@inflateBac:
  0065e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00661	8b cb		 mov	 ecx, ebx
  00663	d3 e0		 shl	 eax, cl
  00665	47		 inc	 edi
  00666	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00669	83 c3 08	 add	 ebx, 8
  0066c	4e		 dec	 esi
  0066d	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
  00670	3b 5d d0	 cmp	 ebx, DWORD PTR tv3478[ebp]
  00673	72 cb		 jb	 SHORT $LL154@inflateBac
$LN151@inflateBac:

; 423  :                         DROPBITS(here.bits);

  00675	8b 45 f0	 mov	 eax, DWORD PTR _here$1$[ebp]
  00678	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  0067b	0f b6 cc	 movzx	 ecx, ah
  0067e	d3 ef		 shr	 edi, cl

; 424  :                         len = 0;
; 425  :                         copy = 11 + BITS(7);

  00680	8b c7		 mov	 eax, edi
  00682	83 e0 7f	 and	 eax, 127		; 0000007fH
  00685	83 c0 0b	 add	 eax, 11			; 0000000bH

; 426  :                         DROPBITS(7);

  00688	c1 ef 07	 shr	 edi, 7
  0068b	89 45 e4	 mov	 DWORD PTR _copy$1$[ebp], eax
  0068e	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN512@inflateBac:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00693	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00696	2b c1		 sub	 eax, ecx
  00698	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0
  0069f	03 d8		 add	 ebx, eax
$LN511@inflateBac:
  006a1	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  006a4	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  006a7	03 4d e4	 add	 ecx, DWORD PTR _copy$1$[ebp]
  006aa	03 42 60	 add	 eax, DWORD PTR [edx+96]
  006ad	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  006b0	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  006b3	3b c8		 cmp	 ecx, eax
  006b5	77 5b		 ja	 SHORT $LN395@inflateBac
  006b7	8b 7d e4	 mov	 edi, DWORD PTR _copy$1$[ebp]
  006ba	8b 5d e0	 mov	 ebx, DWORD PTR $T5[ebp]
  006bd	0f 1f 00	 npad	 3
$LL168@inflateBac:

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)
; 434  :                         state->lens[state->have++] = (unsigned short)len;

  006c0	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  006c3	66 89 5c 42 70	 mov	 WORD PTR [edx+eax*2+112], bx
  006c8	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  006cb	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  006ce	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  006d1	83 ef 01	 sub	 edi, 1
  006d4	75 ea		 jne	 SHORT $LL168@inflateBac
  006d6	8b 5d f0	 mov	 ebx, DWORD PTR _bits$1$[ebp]
  006d9	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
$LN422@inflateBac:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  006dc	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  006df	03 42 60	 add	 eax, DWORD PTR [edx+96]
  006e2	3b c8		 cmp	 ecx, eax
  006e4	0f 82 46 fd ff
	ff		 jb	 $LL92@inflateBac
$LN93@inflateBac:

; 435  :                 }
; 436  :             }
; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  006ea	83 3a 1d	 cmp	 DWORD PTR [edx], 29	; 0000001dH
  006ed	0f 84 52 06 00
	00		 je	 $LN503@inflateBac

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  006f3	66 83 ba 70 02
	00 00 00	 cmp	 WORD PTR [edx+624], 0
  006fb	75 2a		 jne	 SHORT $LN312@inflateBac

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  006fd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00700	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 444  :                 state->mode = BAD;

  00707	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 445  :                 break;

  0070d	e9 33 06 00 00	 jmp	 $LN503@inflateBac
$LN395@inflateBac:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00712	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00715	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  0071c	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH
  00722	e9 1e 06 00 00	 jmp	 $LN503@inflateBac
$LN312@inflateBac:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;
; 452  :             state->lencode = (code const FAR *)(state->next);
; 453  :             state->lenbits = 9;
; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00727	ff 75 dc	 push	 DWORD PTR tv3528[ebp]
  0072a	8d 4a 6c	 lea	 ecx, DWORD PTR [edx+108]
  0072d	c7 42 54 09 00
	00 00		 mov	 DWORD PTR [edx+84], 9
  00734	8d 82 30 05 00
	00		 lea	 eax, DWORD PTR [edx+1328]
  0073a	89 01		 mov	 DWORD PTR [ecx], eax
  0073c	89 42 4c	 mov	 DWORD PTR [edx+76], eax
  0073f	8d 42 54	 lea	 eax, DWORD PTR [edx+84]
  00742	50		 push	 eax
  00743	51		 push	 ecx
  00744	ff 72 60	 push	 DWORD PTR [edx+96]
  00747	8b 55 cc	 mov	 edx, DWORD PTR tv3527[ebp]
  0074a	b9 01 00 00 00	 mov	 ecx, 1
  0074f	e8 00 00 00 00	 call	 _inflate_table
  00754	83 c4 10	 add	 esp, 16			; 00000010H

; 455  :                                 &(state->lenbits), state->work);
; 456  :             if (ret) {

  00757	85 c0		 test	 eax, eax
  00759	74 18		 je	 SHORT $LN313@inflateBac

; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  0075b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 458  :                 state->mode = BAD;

  0075e	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00761	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00768	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 459  :                 break;

  0076e	e9 d2 05 00 00	 jmp	 $LN503@inflateBac
$LN313@inflateBac:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);

  00773	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00776	8b 55 d4	 mov	 edx, DWORD PTR tv3533[ebp]

; 462  :             state->distbits = 6;
; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00779	ff 75 dc	 push	 DWORD PTR tv3528[ebp]
  0077c	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6
  00783	8b 02		 mov	 eax, DWORD PTR [edx]
  00785	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00788	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  0078b	50		 push	 eax
  0078c	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  0078f	52		 push	 edx
  00790	ff 71 64	 push	 DWORD PTR [ecx+100]
  00793	83 c1 70	 add	 ecx, 112		; 00000070H
  00796	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00799	b9 02 00 00 00	 mov	 ecx, 2
  0079e	e8 00 00 00 00	 call	 _inflate_table

; 464  :                             &(state->next), &(state->distbits), state->work);
; 465  :             if (ret) {

  007a3	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  007a6	83 c4 10	 add	 esp, 16			; 00000010H
  007a9	85 c0		 test	 eax, eax
  007ab	74 15		 je	 SHORT $LN314@inflateBac

; 466  :                 strm->msg = (char *)"invalid distances set";

  007ad	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  007b0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@

; 467  :                 state->mode = BAD;

  007b7	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 468  :                 break;

  007bd	e9 83 05 00 00	 jmp	 $LN503@inflateBac
$LN314@inflateBac:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  007c2	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H
$LN315@inflateBac:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  007c8	83 fe 06	 cmp	 esi, 6
  007cb	0f 82 86 00 00
	00		 jb	 $LN316@inflateBac
  007d1	8b 4d ec	 mov	 ecx, DWORD PTR _left$1$[ebp]
  007d4	81 f9 02 01 00
	00		 cmp	 ecx, 258		; 00000102H
  007da	72 7b		 jb	 SHORT $LN316@inflateBac

; 476  :                 RESTORE();

  007dc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007df	8b 45 e8	 mov	 eax, DWORD PTR _put$1$[ebp]
  007e2	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  007e5	8b c2		 mov	 eax, edx
  007e7	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  007ea	8b ca		 mov	 ecx, edx
  007ec	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  007ef	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  007f2	89 01		 mov	 DWORD PTR [ecx], eax
  007f4	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 477  :                 if (state->whave < state->wsize)

  007f7	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  007fa	89 7a 38	 mov	 DWORD PTR [edx+56], edi
  007fd	89 5a 3c	 mov	 DWORD PTR [edx+60], ebx
  00800	39 4a 2c	 cmp	 DWORD PTR [edx+44], ecx
  00803	73 08		 jae	 SHORT $LN317@inflateBac

; 478  :                     state->whave = state->wsize - left;

  00805	8b c1		 mov	 eax, ecx
  00807	2b 45 ec	 sub	 eax, DWORD PTR _left$1$[ebp]
  0080a	89 42 2c	 mov	 DWORD PTR [edx+44], eax
$LN317@inflateBac:

; 479  :                 inflate_fast(strm, state->wsize);

  0080d	8b d1		 mov	 edx, ecx
  0080f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00812	e8 00 00 00 00	 call	 _inflate_fast

; 480  :                 LOAD();

  00817	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0081a	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  0081d	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00820	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00823	89 45 e8	 mov	 DWORD PTR _put$1$[ebp], eax
  00826	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00829	89 45 ec	 mov	 DWORD PTR _left$1$[ebp], eax
  0082c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0082e	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  00831	8b 7a 38	 mov	 edi, DWORD PTR [edx+56]
  00834	8b 5a 3c	 mov	 ebx, DWORD PTR [edx+60]
  00837	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  0083a	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 481  :                 break;

  0083d	e9 03 05 00 00	 jmp	 $LN503@inflateBac
$LN288@inflateBac:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  00842	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00845	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@

; 361  :                 state->mode = BAD;

  0084c	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 362  :                 break;

  00852	e9 ee 04 00 00	 jmp	 $LN503@inflateBac
$LN316@inflateBac:

; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  00857	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0085a	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  0085d	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  00860	b8 01 00 00 00	 mov	 eax, 1
  00865	d3 e0		 shl	 eax, cl
  00867	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0086a	48		 dec	 eax
  0086b	23 c7		 and	 eax, edi
  0086d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00870	8b c8		 mov	 ecx, eax
  00872	c1 e9 08	 shr	 ecx, 8
  00875	0f b6 c9	 movzx	 ecx, cl

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  00878	3b cb		 cmp	 ecx, ebx
  0087a	76 60		 jbe	 SHORT $LN397@inflateBac
  0087c	0f 1f 40 00	 npad	 4
$LL176@inflateBac:

; 488  :                 PULLBYTE();

  00880	85 f6		 test	 esi, esi
  00882	75 1a		 jne	 SHORT $LN182@inflateBac
  00884	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00887	50		 push	 eax
  00888	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0088b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0088e	8b f0		 mov	 esi, eax
  00890	83 c4 08	 add	 esp, 8
  00893	85 f6		 test	 esi, esi
  00895	0f 84 d3 04 00
	00		 je	 $LN383@inflateBac
  0089b	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN182@inflateBac:
  0089e	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  008a1	8b cb		 mov	 ecx, ebx
  008a3	83 c3 08	 add	 ebx, 8
  008a6	4e		 dec	 esi
  008a7	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  008aa	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  008ad	ff 45 fc	 inc	 DWORD PTR _next$[ebp]
  008b0	d3 e0		 shl	 eax, cl
  008b2	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  008b5	03 f8		 add	 edi, eax
  008b7	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  008ba	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  008bd	b8 01 00 00 00	 mov	 eax, 1
  008c2	d3 e0		 shl	 eax, cl
  008c4	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  008c7	48		 dec	 eax
  008c8	23 c7		 and	 eax, edi
  008ca	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  008cd	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  008d0	8b c8		 mov	 ecx, eax
  008d2	c1 e9 08	 shr	 ecx, 8
  008d5	0f b6 c9	 movzx	 ecx, cl
  008d8	3b cb		 cmp	 ecx, ebx
  008da	77 a4		 ja	 SHORT $LL176@inflateBac
$LN397@inflateBac:

; 489  :             }
; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  008dc	84 c0		 test	 al, al
  008de	0f 84 c7 00 00
	00		 je	 $LN195@inflateBac
  008e4	a8 f0		 test	 al, 240			; 000000f0H
  008e6	0f 85 bf 00 00
	00		 jne	 $LN195@inflateBac

; 491  :                 last = here;

  008ec	8b c8		 mov	 ecx, eax

; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +

  008ee	bb 01 00 00 00	 mov	 ebx, 1
  008f3	c1 e9 08	 shr	 ecx, 8
  008f6	8b d0		 mov	 edx, eax
  008f8	0f b6 f9	 movzx	 edi, cl
  008fb	89 4d cc	 mov	 DWORD PTR tv3508[ebp], ecx
  008fe	0f b6 c8	 movzx	 ecx, al
  00901	03 cf		 add	 ecx, edi
  00903	c1 e8 10	 shr	 eax, 16			; 00000010H
  00906	d3 e3		 shl	 ebx, cl
  00908	8b cf		 mov	 ecx, edi
  0090a	4b		 dec	 ebx
  0090b	89 55 e4	 mov	 DWORD PTR _last$[ebp], edx
  0090e	23 5d f8	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00911	d3 eb		 shr	 ebx, cl
  00913	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp]
  00916	03 d8		 add	 ebx, eax
  00918	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]
  0091b	8b c8		 mov	 ecx, eax

; 494  :                             (BITS(last.bits + last.op) >> last.bits)];
; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0091d	8b 5d f0	 mov	 ebx, DWORD PTR _bits$1$[ebp]
  00920	c1 e9 08	 shr	 ecx, 8
  00923	0f b6 f9	 movzx	 edi, cl
  00926	8b 4d cc	 mov	 ecx, DWORD PTR tv3508[ebp]
  00929	0f b6 c9	 movzx	 ecx, cl
  0092c	03 f9		 add	 edi, ecx
  0092e	3b fb		 cmp	 edi, ebx
  00930	76 6c		 jbe	 SHORT $LN196@inflateBac
$LL185@inflateBac:

; 496  :                     PULLBYTE();

  00932	85 f6		 test	 esi, esi
  00934	75 1a		 jne	 SHORT $LN191@inflateBac
  00936	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00939	50		 push	 eax
  0093a	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  0093d	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00940	8b f0		 mov	 esi, eax
  00942	83 c4 08	 add	 esp, 8
  00945	85 f6		 test	 esi, esi
  00947	0f 84 21 04 00
	00		 je	 $LN383@inflateBac
  0094d	8b 55 e4	 mov	 edx, DWORD PTR _last$[ebp]
$LN191@inflateBac:
  00950	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00953	8b cb		 mov	 ecx, ebx
  00955	83 c3 08	 add	 ebx, 8
  00958	bf 01 00 00 00	 mov	 edi, 1
  0095d	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  00960	4e		 dec	 esi
  00961	0f b6 de	 movzx	 ebx, dh
  00964	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00967	ff 45 fc	 inc	 DWORD PTR _next$[ebp]
  0096a	d3 e0		 shl	 eax, cl
  0096c	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  0096f	0f b7 45 e6	 movzx	 eax, WORD PTR _last$[ebp+2]
  00973	0f b6 ca	 movzx	 ecx, dl
  00976	03 cb		 add	 ecx, ebx
  00978	d3 e7		 shl	 edi, cl
  0097a	8b cb		 mov	 ecx, ebx
  0097c	4f		 dec	 edi
  0097d	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  00980	d3 ef		 shr	 edi, cl
  00982	03 f8		 add	 edi, eax
  00984	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00987	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  0098a	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0098d	8b c8		 mov	 ecx, eax
  0098f	c1 e9 08	 shr	 ecx, 8
  00992	0f b6 c9	 movzx	 ecx, cl
  00995	03 cb		 add	 ecx, ebx
  00997	8b 5d f0	 mov	 ebx, DWORD PTR _bits$1$[ebp]
  0099a	3b cb		 cmp	 ecx, ebx
  0099c	77 94		 ja	 SHORT $LL185@inflateBac
$LN196@inflateBac:

; 497  :                 }
; 498  :                 DROPBITS(last.bits);

  0099e	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  009a1	0f b6 ce	 movzx	 ecx, dh
  009a4	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  009a7	d3 ef		 shr	 edi, cl
  009a9	2b d9		 sub	 ebx, ecx
$LN195@inflateBac:

; 499  :             }
; 500  :             DROPBITS(here.bits);

  009ab	8b c8		 mov	 ecx, eax
  009ad	c1 e9 08	 shr	 ecx, 8
  009b0	0f b6 c9	 movzx	 ecx, cl
  009b3	d3 ef		 shr	 edi, cl
  009b5	2b d9		 sub	 ebx, ecx

; 501  :             state->length = (unsigned)here.val;

  009b7	8b c8		 mov	 ecx, eax
  009b9	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  009bc	c1 e9 10	 shr	 ecx, 16			; 00000010H
  009bf	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  009c2	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  009c5	84 c0		 test	 al, al
  009c7	75 45		 jne	 SHORT $LN325@inflateBac

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  009c9	83 7d ec 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  009cd	75 25		 jne	 SHORT $LN200@inflateBac
  009cf	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  009d2	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  009d5	51		 push	 ecx
  009d6	50		 push	 eax
  009d7	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  009da	89 45 e8	 mov	 DWORD PTR _put$1$[ebp], eax
  009dd	89 4d ec	 mov	 DWORD PTR _left$1$[ebp], ecx
  009e0	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
  009e3	ff 55 14	 call	 DWORD PTR _out$[ebp]
  009e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  009e9	85 c0		 test	 eax, eax
  009eb	0f 85 84 03 00
	00		 jne	 $LN386@inflateBac
  009f1	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN200@inflateBac:

; 509  :                 *put++ = (unsigned char)(state->length);

  009f4	8b 4d e8	 mov	 ecx, DWORD PTR _put$1$[ebp]
  009f7	8a 42 40	 mov	 al, BYTE PTR [edx+64]
  009fa	88 01		 mov	 BYTE PTR [ecx], al
  009fc	41		 inc	 ecx

; 510  :                 left--;

  009fd	ff 4d ec	 dec	 DWORD PTR _left$1$[ebp]
  00a00	89 4d e8	 mov	 DWORD PTR _put$1$[ebp], ecx

; 511  :                 state->mode = LEN;

  00a03	c7 02 14 00 00
	00		 mov	 DWORD PTR [edx], 20	; 00000014H

; 512  :                 break;

  00a09	e9 37 03 00 00	 jmp	 $LN503@inflateBac
$LN325@inflateBac:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  00a0e	a8 20		 test	 al, 32			; 00000020H
  00a10	74 0b		 je	 SHORT $LN328@inflateBac

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;

  00a12	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 519  :                 break;

  00a18	e9 28 03 00 00	 jmp	 $LN503@inflateBac
$LN328@inflateBac:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  00a1d	a8 40		 test	 al, 64			; 00000040H
  00a1f	74 15		 je	 SHORT $LN329@inflateBac

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  00a21	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00a24	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 525  :                 state->mode = BAD;

  00a2b	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 526  :                 break;

  00a31	e9 0f 03 00 00	 jmp	 $LN503@inflateBac
$LN329@inflateBac:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  00a36	0f b6 c8	 movzx	 ecx, al
  00a39	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00a3c	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 531  :             if (state->extra != 0) {

  00a3f	74 5a		 je	 SHORT $LN215@inflateBac

; 532  :                 NEEDBITS(state->extra);

  00a41	3b d9		 cmp	 ebx, ecx
  00a43	73 3f		 jae	 SHORT $LN203@inflateBac
  00a45	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LL206@inflateBac:
  00a48	85 f6		 test	 esi, esi
  00a4a	75 1d		 jne	 SHORT $LN211@inflateBac
  00a4c	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00a4f	50		 push	 eax
  00a50	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00a53	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00a56	8b f0		 mov	 esi, eax
  00a58	83 c4 08	 add	 esp, 8
  00a5b	85 f6		 test	 esi, esi
  00a5d	0f 84 0b 03 00
	00		 je	 $LN383@inflateBac
  00a63	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00a66	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LN211@inflateBac:
  00a69	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00a6c	8b cb		 mov	 ecx, ebx
  00a6e	d3 e0		 shl	 eax, cl
  00a70	83 c3 08	 add	 ebx, 8
  00a73	03 f8		 add	 edi, eax
  00a75	4e		 dec	 esi
  00a76	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00a79	40		 inc	 eax
  00a7a	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  00a7d	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  00a80	3b d9		 cmp	 ebx, ecx
  00a82	72 c4		 jb	 SHORT $LL206@inflateBac
$LN203@inflateBac:

; 533  :                 state->length += BITS(state->extra);

  00a84	b8 01 00 00 00	 mov	 eax, 1
  00a89	d3 e0		 shl	 eax, cl
  00a8b	48		 dec	 eax
  00a8c	23 c7		 and	 eax, edi

; 534  :                 DROPBITS(state->extra);

  00a8e	d3 ef		 shr	 edi, cl
  00a90	01 42 40	 add	 DWORD PTR [edx+64], eax
  00a93	2b d9		 sub	 ebx, ecx
  00a95	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00a98	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
$LN215@inflateBac:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  00a9b	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00a9e	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  00aa1	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  00aa4	b8 01 00 00 00	 mov	 eax, 1
  00aa9	d3 e0		 shl	 eax, cl
  00aab	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00aae	48		 dec	 eax
  00aaf	23 c7		 and	 eax, edi
  00ab1	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00ab4	8b c8		 mov	 ecx, eax
  00ab6	c1 e9 08	 shr	 ecx, 8
  00ab9	0f b6 c9	 movzx	 ecx, cl

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  00abc	3b cb		 cmp	 ecx, ebx
  00abe	76 5c		 jbe	 SHORT $LN502@inflateBac
$LL217@inflateBac:

; 542  :                 PULLBYTE();

  00ac0	85 f6		 test	 esi, esi
  00ac2	75 1a		 jne	 SHORT $LN223@inflateBac
  00ac4	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00ac7	50		 push	 eax
  00ac8	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00acb	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00ace	8b f0		 mov	 esi, eax
  00ad0	83 c4 08	 add	 esp, 8
  00ad3	85 f6		 test	 esi, esi
  00ad5	0f 84 93 02 00
	00		 je	 $LN383@inflateBac
  00adb	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN223@inflateBac:
  00ade	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00ae1	8b cb		 mov	 ecx, ebx
  00ae3	83 c3 08	 add	 ebx, 8
  00ae6	4e		 dec	 esi
  00ae7	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  00aea	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00aed	ff 45 fc	 inc	 DWORD PTR _next$[ebp]
  00af0	d3 e0		 shl	 eax, cl
  00af2	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  00af5	03 f8		 add	 edi, eax
  00af7	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00afa	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  00afd	b8 01 00 00 00	 mov	 eax, 1
  00b02	d3 e0		 shl	 eax, cl
  00b04	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00b07	48		 dec	 eax
  00b08	23 c7		 and	 eax, edi
  00b0a	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00b0d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00b10	8b c8		 mov	 ecx, eax
  00b12	c1 e9 08	 shr	 ecx, 8
  00b15	0f b6 c9	 movzx	 ecx, cl
  00b18	3b cb		 cmp	 ecx, ebx
  00b1a	77 a4		 ja	 SHORT $LL217@inflateBac
$LN502@inflateBac:

; 543  :             }
; 544  :             if ((here.op & 0xf0) == 0) {

  00b1c	a8 f0		 test	 al, 240			; 000000f0H
  00b1e	0f 85 c6 00 00
	00		 jne	 $LN236@inflateBac

; 545  :                 last = here;

  00b24	8b c8		 mov	 ecx, eax

; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +

  00b26	bb 01 00 00 00	 mov	 ebx, 1
  00b2b	c1 e9 08	 shr	 ecx, 8
  00b2e	8b d0		 mov	 edx, eax
  00b30	0f b6 f9	 movzx	 edi, cl
  00b33	89 4d cc	 mov	 DWORD PTR tv3507[ebp], ecx
  00b36	0f b6 c8	 movzx	 ecx, al
  00b39	03 cf		 add	 ecx, edi
  00b3b	c1 e8 10	 shr	 eax, 16			; 00000010H
  00b3e	d3 e3		 shl	 ebx, cl
  00b40	8b cf		 mov	 ecx, edi
  00b42	4b		 dec	 ebx
  00b43	89 55 e4	 mov	 DWORD PTR _last$[ebp], edx
  00b46	23 5d f8	 and	 ebx, DWORD PTR _hold$1$[ebp]
  00b49	d3 eb		 shr	 ebx, cl
  00b4b	8b 4d d4	 mov	 ecx, DWORD PTR $T2[ebp]
  00b4e	03 d8		 add	 ebx, eax
  00b50	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]
  00b53	8b c8		 mov	 ecx, eax

; 548  :                             (BITS(last.bits + last.op) >> last.bits)];
; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00b55	8b 5d f0	 mov	 ebx, DWORD PTR _bits$1$[ebp]
  00b58	c1 e9 08	 shr	 ecx, 8
  00b5b	0f b6 f9	 movzx	 edi, cl
  00b5e	8b 4d cc	 mov	 ecx, DWORD PTR tv3507[ebp]
  00b61	0f b6 c9	 movzx	 ecx, cl
  00b64	03 f9		 add	 edi, ecx
  00b66	3b fb		 cmp	 edi, ebx
  00b68	76 73		 jbe	 SHORT $LN237@inflateBac
  00b6a	66 0f 1f 44 00
	00		 npad	 6
$LL226@inflateBac:

; 550  :                     PULLBYTE();

  00b70	85 f6		 test	 esi, esi
  00b72	75 1a		 jne	 SHORT $LN232@inflateBac
  00b74	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00b77	50		 push	 eax
  00b78	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00b7b	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00b7e	8b f0		 mov	 esi, eax
  00b80	83 c4 08	 add	 esp, 8
  00b83	85 f6		 test	 esi, esi
  00b85	0f 84 e3 01 00
	00		 je	 $LN383@inflateBac
  00b8b	8b 55 e4	 mov	 edx, DWORD PTR _last$[ebp]
$LN232@inflateBac:
  00b8e	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
  00b91	8b cb		 mov	 ecx, ebx
  00b93	83 c3 08	 add	 ebx, 8
  00b96	4e		 dec	 esi
  00b97	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
  00b9a	0f b6 de	 movzx	 ebx, dh
  00b9d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00ba0	47		 inc	 edi
  00ba1	d3 e0		 shl	 eax, cl
  00ba3	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  00ba6	0f b7 45 e6	 movzx	 eax, WORD PTR _last$[ebp+2]
  00baa	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
  00bad	bf 01 00 00 00	 mov	 edi, 1
  00bb2	0f b6 ca	 movzx	 ecx, dl
  00bb5	03 cb		 add	 ecx, ebx
  00bb7	d3 e7		 shl	 edi, cl
  00bb9	8b cb		 mov	 ecx, ebx
  00bbb	4f		 dec	 edi
  00bbc	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  00bbf	d3 ef		 shr	 edi, cl
  00bc1	03 f8		 add	 edi, eax
  00bc3	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bc6	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00bc9	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00bcc	8b c8		 mov	 ecx, eax
  00bce	c1 e9 08	 shr	 ecx, 8
  00bd1	0f b6 c9	 movzx	 ecx, cl
  00bd4	03 cb		 add	 ecx, ebx
  00bd6	8b 5d f0	 mov	 ebx, DWORD PTR _bits$1$[ebp]
  00bd9	3b cb		 cmp	 ecx, ebx
  00bdb	77 93		 ja	 SHORT $LL226@inflateBac
$LN237@inflateBac:

; 551  :                 }
; 552  :                 DROPBITS(last.bits);

  00bdd	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  00be0	0f b6 ce	 movzx	 ecx, dh
  00be3	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00be6	d3 ef		 shr	 edi, cl
  00be8	2b d9		 sub	 ebx, ecx
$LN236@inflateBac:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  00bea	8b c8		 mov	 ecx, eax
  00bec	c1 e9 08	 shr	 ecx, 8
  00bef	0f b6 c9	 movzx	 ecx, cl
  00bf2	d3 ef		 shr	 edi, cl
  00bf4	2b d9		 sub	 ebx, ecx
  00bf6	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00bf9	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx

; 555  :             if (here.op & 64) {

  00bfc	a8 40		 test	 al, 64			; 00000040H
  00bfe	74 15		 je	 SHORT $LN340@inflateBac

; 556  :                 strm->msg = (char *)"invalid distance code";

  00c00	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c03	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 557  :                 state->mode = BAD;

  00c0a	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 558  :                 break;

  00c10	e9 30 01 00 00	 jmp	 $LN503@inflateBac
$LN340@inflateBac:

; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  00c15	8b c8		 mov	 ecx, eax
  00c17	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00c1a	89 4d d4	 mov	 DWORD PTR $T1[ebp], ecx
  00c1d	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  00c20	0f b6 c8	 movzx	 ecx, al
  00c23	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00c26	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 564  :             if (state->extra != 0) {

  00c29	74 60		 je	 SHORT $LN253@inflateBac

; 565  :                 NEEDBITS(state->extra);

  00c2b	3b d9		 cmp	 ebx, ecx
  00c2d	73 3f		 jae	 SHORT $LN241@inflateBac
  00c2f	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LL244@inflateBac:
  00c32	85 f6		 test	 esi, esi
  00c34	75 1d		 jne	 SHORT $LN249@inflateBac
  00c36	8d 45 fc	 lea	 eax, DWORD PTR _next$[ebp]
  00c39	50		 push	 eax
  00c3a	ff 75 10	 push	 DWORD PTR _in_desc$[ebp]
  00c3d	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00c40	8b f0		 mov	 esi, eax
  00c42	83 c4 08	 add	 esp, 8
  00c45	85 f6		 test	 esi, esi
  00c47	0f 84 21 01 00
	00		 je	 $LN383@inflateBac
  00c4d	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00c50	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LN249@inflateBac:
  00c53	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00c56	8b cb		 mov	 ecx, ebx
  00c58	d3 e0		 shl	 eax, cl
  00c5a	83 c3 08	 add	 ebx, 8
  00c5d	03 f8		 add	 edi, eax
  00c5f	4e		 dec	 esi
  00c60	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  00c63	40		 inc	 eax
  00c64	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  00c67	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  00c6a	3b d9		 cmp	 ebx, ecx
  00c6c	72 c4		 jb	 SHORT $LL244@inflateBac
$LN241@inflateBac:

; 566  :                 state->offset += BITS(state->extra);

  00c6e	b8 01 00 00 00	 mov	 eax, 1
  00c73	d3 e0		 shl	 eax, cl
  00c75	48		 dec	 eax
  00c76	23 c7		 and	 eax, edi

; 567  :                 DROPBITS(state->extra);

  00c78	d3 ef		 shr	 edi, cl
  00c7a	01 42 44	 add	 DWORD PTR [edx+68], eax
  00c7d	2b d9		 sub	 ebx, ecx
  00c7f	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00c82	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
  00c85	89 7d f8	 mov	 DWORD PTR _hold$1$[ebp], edi
  00c88	89 5d f0	 mov	 DWORD PTR _bits$1$[ebp], ebx
$LN253@inflateBac:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00c8b	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00c8e	39 4a 2c	 cmp	 DWORD PTR [edx+44], ecx
  00c91	1b c0		 sbb	 eax, eax
  00c93	23 45 ec	 and	 eax, DWORD PTR _left$1$[ebp]
  00c96	2b c8		 sub	 ecx, eax
  00c98	39 4d d4	 cmp	 DWORD PTR $T1[ebp], ecx
  00c9b	76 15		 jbe	 SHORT $LL257@inflateBac

; 570  :                                                 left : 0)) {
; 571  :                 strm->msg = (char *)"invalid distance too far back";

  00c9d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ca0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 572  :                 state->mode = BAD;

  00ca7	c7 02 1d 00 00
	00		 mov	 DWORD PTR [edx], 29	; 0000001dH

; 573  :                 break;

  00cad	e9 93 00 00 00	 jmp	 $LN503@inflateBac
$LL257@inflateBac:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  00cb2	83 7d ec 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  00cb6	75 25		 jne	 SHORT $LN258@inflateBac
  00cb8	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  00cbb	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00cbe	51		 push	 ecx
  00cbf	50		 push	 eax
  00cc0	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00cc3	89 45 e8	 mov	 DWORD PTR _put$1$[ebp], eax
  00cc6	89 4d ec	 mov	 DWORD PTR _left$1$[ebp], ecx
  00cc9	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx
  00ccc	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00ccf	83 c4 0c	 add	 esp, 12			; 0000000cH
  00cd2	85 c0		 test	 eax, eax
  00cd4	0f 85 9b 00 00
	00		 jne	 $LN386@inflateBac
  00cda	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
$LN258@inflateBac:

; 580  :                 copy = state->wsize - state->offset;

  00cdd	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00ce0	8b 52 28	 mov	 edx, DWORD PTR [edx+40]

; 581  :                 if (copy < left) {
; 582  :                     from = put + copy;
; 583  :                     copy = left - copy;
; 584  :                 }
; 585  :                 else {
; 586  :                     from = put - state->offset;
; 587  :                     copy = left;
; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  00ce3	8b 7d e8	 mov	 edi, DWORD PTR _put$1$[ebp]
  00ce6	2b d0		 sub	 edx, eax
  00ce8	8b cf		 mov	 ecx, edi
  00cea	2b c8		 sub	 ecx, eax
  00cec	3b 55 ec	 cmp	 edx, DWORD PTR _left$1$[ebp]
  00cef	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  00cf2	0f 43 c1	 cmovae	 eax, ecx
  00cf5	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax
  00cf8	8b 45 ec	 mov	 eax, DWORD PTR _left$1$[ebp]
  00cfb	8b c8		 mov	 ecx, eax
  00cfd	2b ca		 sub	 ecx, edx
  00cff	3b d0		 cmp	 edx, eax
  00d01	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00d04	0f 43 c8	 cmovae	 ecx, eax
  00d07	8b 42 40	 mov	 eax, DWORD PTR [edx+64]

; 590  :                 state->length -= copy;

  00d0a	3b c8		 cmp	 ecx, eax
  00d0c	8b d0		 mov	 edx, eax
  00d0e	0f 46 d1	 cmovbe	 edx, ecx
  00d11	8b 4d cc	 mov	 ecx, DWORD PTR _from$1$[ebp]
  00d14	2b c2		 sub	 eax, edx
  00d16	89 55 d4	 mov	 DWORD PTR _copy$2$[ebp], edx
  00d19	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00d1c	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 591  :                 left -= copy;

  00d1f	8b 55 d4	 mov	 edx, DWORD PTR _copy$2$[ebp]
  00d22	29 55 ec	 sub	 DWORD PTR _left$1$[ebp], edx
$LL263@inflateBac:

; 592  :                 do {
; 593  :                     *put++ = *from++;

  00d25	8a 01		 mov	 al, BYTE PTR [ecx]
  00d27	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00d2a	88 07		 mov	 BYTE PTR [edi], al
  00d2c	47		 inc	 edi

; 594  :                 } while (--copy);

  00d2d	83 ea 01	 sub	 edx, 1
  00d30	75 f3		 jne	 SHORT $LL263@inflateBac

; 595  :             } while (state->length != 0);

  00d32	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00d35	89 7d e8	 mov	 DWORD PTR _put$1$[ebp], edi
  00d38	8b 7d f8	 mov	 edi, DWORD PTR _hold$1$[ebp]
  00d3b	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  00d3f	0f 85 6d ff ff
	ff		 jne	 $LL257@inflateBac
$LN503@inflateBac:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00d45	8b 02		 mov	 eax, DWORD PTR [edx]
  00d47	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00d4a	83 f8 12	 cmp	 eax, 18			; 00000012H
  00d4d	0f 86 1e f3 ff
	ff		 jbe	 $LN513@inflateBac
$LN354@inflateBac:

; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  00d53	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$inf_leave$517:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00d58	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00d5b	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]

; 619  :     strm->avail_in = have;

  00d5e	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00d61	89 08		 mov	 DWORD PTR [eax], ecx

; 620  :     return ret;

  00d63	8b c7		 mov	 eax, edi
  00d65	5f		 pop	 edi
  00d66	5e		 pop	 esi
  00d67	5b		 pop	 ebx

; 621  : }

  00d68	8b e5		 mov	 esp, ebp
  00d6a	5d		 pop	 ebp
  00d6b	c2 14 00	 ret	 20			; 00000014H
$LN383@inflateBac:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00d6e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN386@inflateBac:
  00d75	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00d7a	eb dc		 jmp	 SHORT $inf_leave$517
$LN385@inflateBac:

; 333  :                 copy = state->length;
; 334  :                 PULL();

  00d7c	89 5d fc	 mov	 DWORD PTR _next$[ebp], ebx
  00d7f	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH
  00d84	eb d2		 jmp	 SHORT $inf_leave$517
$LN350@inflateBac:

; 596  :             break;
; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;
; 601  :             if (left < state->wsize) {

  00d86	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00d89	bf 01 00 00 00	 mov	 edi, 1
  00d8e	8b 4d ec	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00d91	3b c8		 cmp	 ecx, eax
  00d93	73 c3		 jae	 SHORT $inf_leave$517

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  00d95	2b c1		 sub	 eax, ecx
  00d97	50		 push	 eax
  00d98	ff 72 34	 push	 DWORD PTR [edx+52]
  00d9b	ff 75 18	 push	 DWORD PTR _out_desc$[ebp]
  00d9e	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00da1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00da4	85 c0		 test	 eax, eax
  00da6	74 b0		 je	 SHORT $inf_leave$517

; 603  :                     ret = Z_BUF_ERROR;

  00da8	bf fb ff ff ff	 mov	 edi, -5			; fffffffbH

; 604  :             }
; 605  :             goto inf_leave;

  00dad	eb a9		 jmp	 SHORT $inf_leave$517
$LN353@inflateBac:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;

  00daf	bf fd ff ff ff	 mov	 edi, -3			; fffffffdH

; 609  :             goto inf_leave;

  00db4	eb a2		 jmp	 SHORT $inf_leave$517
$LN265@inflateBac:

; 265  :         return Z_STREAM_ERROR;

  00db6	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 621  : }

  00dbb	8b e5		 mov	 esp, ebp
  00dbd	5d		 pop	 ebp
  00dbe	c2 14 00	 ret	 20			; 00000014H
  00dc1	0f 1f 00	 npad	 3
$LN515@inflateBac:
  00dc4	00 00 00 00	 DD	 $LN266@inflateBac
  00dc8	00 00 00 00	 DD	 $LN31@inflateBac
  00dcc	00 00 00 00	 DD	 $LN56@inflateBac
  00dd0	00 00 00 00	 DD	 $LN315@inflateBac
  00dd4	00 00 00 00	 DD	 $LN350@inflateBac
  00dd8	00 00 00 00	 DD	 $LN353@inflateBac
  00ddc	00 00 00 00	 DD	 $LN354@inflateBac
$LN496@inflateBac:
  00de0	00		 DB	 0
  00de1	06		 DB	 6
  00de2	01		 DB	 1
  00de3	06		 DB	 6
  00de4	06		 DB	 6
  00de5	02		 DB	 2
  00de6	06		 DB	 6
  00de7	06		 DB	 6
  00de8	06		 DB	 6
  00de9	03		 DB	 3
  00dea	06		 DB	 6
  00deb	06		 DB	 6
  00dec	06		 DB	 6
  00ded	06		 DB	 6
  00dee	06		 DB	 6
  00def	06		 DB	 6
  00df0	06		 DB	 6
  00df1	04		 DB	 4
  00df2	05		 DB	 5
  00df3	90		 npad	 1
$LN516@inflateBac:
  00df4	00 00 00 00	 DD	 $LN270@inflateBac
  00df8	00 00 00 00	 DD	 $LN271@inflateBac
  00dfc	00 00 00 00	 DD	 $LN272@inflateBac
  00e00	00 00 00 00	 DD	 $LN273@inflateBac
_inflateBack@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 25		 je	 SHORT $LN3@inflateBac
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 1e		 je	 SHORT $LN3@inflateBac
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 17		 je	 SHORT $LN3@inflateBac

; 628  :     ZFREE(strm, strm->state);

  00019	50		 push	 eax
  0001a	ff 76 28	 push	 DWORD PTR [esi+40]
  0001d	ff d1		 call	 ecx
  0001f	83 c4 08	 add	 esp, 8

; 629  :     strm->state = Z_NULL;

  00022	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  00029	33 c0		 xor	 eax, eax
  0002b	5e		 pop	 esi

; 632  : }

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
$LN3@inflateBac:

; 627  :         return Z_STREAM_ERROR;

  00030	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00035	5e		 pop	 esi

; 632  : }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
_TEXT	ENDS
END
