; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

	ORG $+2
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c3H
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	_inflate_table
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
_offs$ = -132						; size = 32
_count$ = -100						; size = 32
_min$2$ = -68						; size = 4
_mask$1$ = -64						; size = 4
tv1903 = -60						; size = 4
tv1911 = -56						; size = 4
tv1898 = -56						; size = 4
_used$1$ = -52						; size = 4
_len$2$ = -48						; size = 4
_lens$1$ = -44						; size = 4
_base$1$ = -40						; size = 4
_extra$1$ = -36						; size = 4
_incr$1$ = -32						; size = 4
_huff$1$ = -32						; size = 4
_type$1$ = -28						; size = 4
_end$1$ = -24						; size = 4
tv1916 = -20						; size = 4
_next$1$ = -16						; size = 4
_low$1$ = -12						; size = 4
_curr$1$ = -12						; size = 4
_drop$1$ = -8						; size = 4
_max$1$ = -4						; size = 4
_here$ = 8						; size = 4
_codes$ = 8						; size = 4
_table$ = 12						; size = 4
_bits$ = 16						; size = 4
_work$ = 20						; size = 4
_inflate_table PROC					; COMDAT
; _type$ = ecx
; _lens$ = edx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	89 4d e4	 mov	 DWORD PTR _type$1$[ebp], ecx
  0000e	0f 57 c0	 xorps	 xmm0, xmm0

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;
; 109  :     for (sym = 0; sym < codes; sym++)

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _codes$[ebp]
  00014	8b c2		 mov	 eax, edx
  00016	33 f6		 xor	 esi, esi
  00018	89 45 d4	 mov	 DWORD PTR _lens$1$[ebp], eax
  0001b	57		 push	 edi
  0001c	0f 11 45 9c	 movups	 XMMWORD PTR _count$[ebp], xmm0
  00020	0f 11 45 ac	 movups	 XMMWORD PTR _count$[ebp+16], xmm0
  00024	85 c9		 test	 ecx, ecx
  00026	74 18		 je	 SHORT $LN6@inflate_ta
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@inflate_ta:

; 110  :         count[lens[sym]]++;

  00030	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  00034	46		 inc	 esi
  00035	66 ff 44 45 9c	 inc	 WORD PTR _count$[ebp+eax*2]
  0003a	8b c2		 mov	 eax, edx
  0003c	3b f1		 cmp	 esi, ecx
  0003e	72 f0		 jb	 SHORT $LL7@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00040	8b 5d 10	 mov	 ebx, DWORD PTR _bits$[ebp]
  00043	8d 45 b6	 lea	 eax, DWORD PTR _count$[ebp+26]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00046	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  0004b	89 7d fc	 mov	 DWORD PTR _max$1$[ebp], edi
  0004e	8b 0b		 mov	 ecx, DWORD PTR [ebx]
$LL10@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00050	66 83 78 04 00	 cmp	 WORD PTR [eax+4], 0
  00055	75 3e		 jne	 SHORT $LN86@inflate_ta
  00057	66 83 78 02 00	 cmp	 WORD PTR [eax+2], 0
  0005c	75 33		 jne	 SHORT $LN126@inflate_ta
  0005e	66 83 38 00	 cmp	 WORD PTR [eax], 0
  00062	75 28		 jne	 SHORT $LN127@inflate_ta
  00064	66 83 78 fe 00	 cmp	 WORD PTR [eax-2], 0
  00069	75 1c		 jne	 SHORT $LN128@inflate_ta
  0006b	66 83 78 fc 00	 cmp	 WORD PTR [eax-4], 0
  00070	75 10		 jne	 SHORT $LN129@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00072	83 ef 05	 sub	 edi, 5
  00075	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00078	89 7d fc	 mov	 DWORD PTR _max$1$[ebp], edi
  0007b	83 ff 01	 cmp	 edi, 1
  0007e	73 d0		 jae	 SHORT $LL10@inflate_ta
  00080	eb 13		 jmp	 SHORT $LN86@inflate_ta
$LN129@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00082	83 ef 04	 sub	 edi, 4
  00085	eb 0b		 jmp	 SHORT $LN169@inflate_ta
$LN128@inflate_ta:
  00087	83 ef 03	 sub	 edi, 3
  0008a	eb 06		 jmp	 SHORT $LN169@inflate_ta
$LN127@inflate_ta:
  0008c	83 ef 02	 sub	 edi, 2
  0008f	eb 01		 jmp	 SHORT $LN169@inflate_ta
$LN126@inflate_ta:
  00091	4f		 dec	 edi
$LN169@inflate_ta:

; 116  :     if (root > max) root = max;
; 117  :     if (max == 0) {                     /* no symbols to code at all */

  00092	89 7d fc	 mov	 DWORD PTR _max$1$[ebp], edi
$LN86@inflate_ta:
  00095	3b cf		 cmp	 ecx, edi
  00097	8b c7		 mov	 eax, edi
  00099	0f 46 c1	 cmovbe	 eax, ecx
  0009c	85 ff		 test	 edi, edi
  0009e	75 2a		 jne	 SHORT $LN41@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000a0	8b 55 0c	 mov	 edx, DWORD PTR _table$[ebp]
  000a3	c7 45 08 40 01
	00 00		 mov	 DWORD PTR _here$[ebp], 320 ; 00000140H
  000aa	8b 45 08	 mov	 eax, DWORD PTR _here$[ebp]
  000ad	5f		 pop	 edi
  000ae	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 329  :     return 0;
; 330  : }

  000b0	5e		 pop	 esi
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	83 02 04	 add	 DWORD PTR [edx], 4
  000b6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000b8	89 01		 mov	 DWORD PTR [ecx], eax
  000ba	83 02 04	 add	 DWORD PTR [edx], 4
  000bd	33 c0		 xor	 eax, eax
  000bf	c7 03 01 00 00
	00		 mov	 DWORD PTR [ebx], 1
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN41@inflate_ta:

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */
; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000ca	bb 01 00 00 00	 mov	 ebx, 1
  000cf	89 5d d0	 mov	 DWORD PTR _len$2$[ebp], ebx
  000d2	3b fb		 cmp	 edi, ebx
  000d4	76 10		 jbe	 SHORT $LN87@inflate_ta
$LL13@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000d6	66 83 7c 5d 9c
	00		 cmp	 WORD PTR _count$[ebp+ebx*2], 0
  000dc	75 05		 jne	 SHORT $LN158@inflate_ta

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */
; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000de	43		 inc	 ebx
  000df	3b df		 cmp	 ebx, edi
  000e1	72 f3		 jb	 SHORT $LL13@inflate_ta
$LN158@inflate_ta:
  000e3	89 5d d0	 mov	 DWORD PTR _len$2$[ebp], ebx
$LN87@inflate_ta:

; 128  :     if (root < min) root = min;
; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000e6	3b c3		 cmp	 eax, ebx
  000e8	8b cb		 mov	 ecx, ebx
  000ea	ba 01 00 00 00	 mov	 edx, 1
  000ef	0f 43 c8	 cmovae	 ecx, eax
  000f2	89 4d ec	 mov	 DWORD PTR tv1916[ebp], ecx

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000f5	8b ca		 mov	 ecx, edx
$LL16@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  000f7	0f b7 44 4d 9c	 movzx	 eax, WORD PTR _count$[ebp+ecx*2]
  000fc	03 d2		 add	 edx, edx
  000fe	2b d0		 sub	 edx, eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00100	0f 88 59 03 00
	00		 js	 $LN46@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00106	41		 inc	 ecx
  00107	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0010a	76 eb		 jbe	 SHORT $LL16@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  0010c	85 d2		 test	 edx, edx
  0010e	7e 13		 jle	 SHORT $LN45@inflate_ta
  00110	83 7d e4 00	 cmp	 DWORD PTR _type$1$[ebp], 0
  00114	0f 84 45 03 00
	00		 je	 $LN46@inflate_ta
  0011a	83 ff 01	 cmp	 edi, 1
  0011d	0f 85 3c 03 00
	00		 jne	 $LN46@inflate_ta
$LN45@inflate_ta:

; 138  :         return -1;                      /* incomplete set */
; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  00123	33 c0		 xor	 eax, eax
  00125	b9 02 00 00 00	 mov	 ecx, 2
  0012a	66 89 85 7e ff
	ff ff		 mov	 WORD PTR _offs$[ebp+2], ax
$LL19@inflate_ta:

; 142  :     for (len = 1; len < MAXBITS; len++)
; 143  :         offs[len + 1] = offs[len] + count[len];

  00131	66 8b 44 0d 9c	 mov	 ax, WORD PTR _count$[ebp+ecx]
  00136	66 03 84 0d 7c
	ff ff ff	 add	 ax, WORD PTR _offs$[ebp+ecx]
  0013e	66 89 84 0d 7e
	ff ff ff	 mov	 WORD PTR _offs$[ebp+ecx+2], ax
  00146	83 c1 02	 add	 ecx, 2
  00149	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  0014c	72 e3		 jb	 SHORT $LL19@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0014e	8b 55 08	 mov	 edx, DWORD PTR _codes$[ebp]
  00151	33 c9		 xor	 ecx, ecx
  00153	85 d2		 test	 edx, edx
  00155	74 32		 je	 SHORT $LN21@inflate_ta
  00157	8b 75 14	 mov	 esi, DWORD PTR _work$[ebp]
  0015a	8b 7d d4	 mov	 edi, DWORD PTR _lens$1$[ebp]
  0015d	0f 1f 00	 npad	 3
$LL22@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00160	0f b7 04 4f	 movzx	 eax, WORD PTR [edi+ecx*2]
  00164	66 85 c0	 test	 ax, ax
  00167	74 18		 je	 SHORT $LN20@inflate_ta
  00169	0f b7 84 45 7c
	ff ff ff	 movzx	 eax, WORD PTR _offs$[ebp+eax*2]
  00171	66 89 0c 46	 mov	 WORD PTR [esi+eax*2], cx
  00175	0f b7 04 4f	 movzx	 eax, WORD PTR [edi+ecx*2]
  00179	66 ff 84 45 7c
	ff ff ff	 inc	 WORD PTR _offs$[ebp+eax*2]
$LN20@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00181	41		 inc	 ecx
  00182	3b ca		 cmp	 ecx, edx
  00184	72 da		 jb	 SHORT $LL22@inflate_ta
  00186	8b 7d fc	 mov	 edi, DWORD PTR _max$1$[ebp]
$LN21@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00189	8b 45 e4	 mov	 eax, DWORD PTR _type$1$[ebp]
  0018c	83 e8 00	 sub	 eax, 0
  0018f	74 3c		 je	 SHORT $LN48@inflate_ta
  00191	83 e8 01	 sub	 eax, 1
  00194	74 17		 je	 SHORT $LN49@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  00196	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _base$1$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;

  0019d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _extra$1$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 196  :         end = -1;

  001a4	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _end$1$[ebp], -1
  001ab	eb 30		 jmp	 SHORT $LN23@inflate_ta
$LN49@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  001ad	b8 00 00 00 00	 mov	 eax, OFFSET ?lbase@?1??inflate_table@@9@9

; 189  :         extra = lext;
; 190  :         extra -= 257;
; 191  :         end = 256;

  001b2	c7 45 e8 00 01
	00 00		 mov	 DWORD PTR _end$1$[ebp], 256 ; 00000100H
  001b9	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  001be	89 45 d8	 mov	 DWORD PTR _base$1$[ebp], eax
  001c1	b8 00 00 00 00	 mov	 eax, OFFSET ?lext@?1??inflate_table@@9@9
  001c6	2d 02 02 00 00	 sub	 eax, 514		; 00000202H

; 192  :         break;

  001cb	eb 0d		 jmp	 SHORT $LN170@inflate_ta
$LN48@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  001cd	8b 45 14	 mov	 eax, DWORD PTR _work$[ebp]
  001d0	89 45 d8	 mov	 DWORD PTR _base$1$[ebp], eax

; 184  :         end = 19;

  001d3	c7 45 e8 13 00
	00 00		 mov	 DWORD PTR _end$1$[ebp], 19 ; 00000013H
$LN170@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */

  001da	89 45 dc	 mov	 DWORD PTR _extra$1$[ebp], eax
$LN23@inflate_ta:

; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  001dd	8b 45 0c	 mov	 eax, DWORD PTR _table$[ebp]

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */

  001e0	33 d2		 xor	 edx, edx

; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 207  :     used = 1U << root;          /* use root table entries */

  001e2	8b 4d ec	 mov	 ecx, DWORD PTR tv1916[ebp]
  001e5	33 f6		 xor	 esi, esi
  001e7	89 55 f8	 mov	 DWORD PTR _drop$1$[ebp], edx
  001ea	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _low$1$[ebp], -1
  001f1	8b 00		 mov	 eax, DWORD PTR [eax]
  001f3	89 45 f0	 mov	 DWORD PTR _next$1$[ebp], eax
  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	d3 e0		 shl	 eax, cl
  001fd	89 45 c4	 mov	 DWORD PTR tv1903[ebp], eax
  00200	89 45 cc	 mov	 DWORD PTR _used$1$[ebp], eax

; 208  :     mask = used - 1;            /* mask for comparing low */

  00203	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00206	89 4d c0	 mov	 DWORD PTR _mask$1$[ebp], ecx

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||

  00209	8b 4d e4	 mov	 ecx, DWORD PTR _type$1$[ebp]
  0020c	83 f9 01	 cmp	 ecx, 1
  0020f	75 13		 jne	 SHORT $LN53@inflate_ta
  00211	3d 54 03 00 00	 cmp	 eax, 852		; 00000354H
  00216	72 1d		 jb	 SHORT $LL25@inflate_ta
$LN66@inflate_ta:
  00218	5f		 pop	 edi

; 329  :     return 0;
; 330  : }

  00219	5e		 pop	 esi
  0021a	b8 01 00 00 00	 mov	 eax, 1
  0021f	5b		 pop	 ebx
  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c3		 ret	 0
$LN53@inflate_ta:

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||

  00224	83 f9 02	 cmp	 ecx, 2
  00227	75 0c		 jne	 SHORT $LL25@inflate_ta
  00229	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  0022e	73 e8		 jae	 SHORT $LN66@inflate_ta

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  00230	eb 03		 jmp	 SHORT $LL25@inflate_ta
$LN162@inflate_ta:

; 212  :         (type == DISTS && used >= ENOUGH_DISTS))
; 213  :         return 1;
; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00232	8b 55 f8	 mov	 edx, DWORD PTR _drop$1$[ebp]
$LL25@inflate_ta:
  00235	8a c3		 mov	 al, bl
  00237	2a c2		 sub	 al, dl
  00239	88 45 09	 mov	 BYTE PTR _here$[ebp+1], al

; 219  :         if ((int)(work[sym]) < end) {

  0023c	8b 45 14	 mov	 eax, DWORD PTR _work$[ebp]
  0023f	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00242	8b c8		 mov	 ecx, eax
  00244	3b 4d e8	 cmp	 ecx, DWORD PTR _end$1$[ebp]
  00247	7d 06		 jge	 SHORT $LN54@inflate_ta

; 220  :             here.op = (unsigned char)0;

  00249	c6 45 08 00	 mov	 BYTE PTR _here$[ebp], 0

; 221  :             here.val = work[sym];
; 222  :         }

  0024d	eb 1a		 jmp	 SHORT $LN171@inflate_ta
$LN54@inflate_ta:

; 223  :         else if ((int)(work[sym]) > end) {

  0024f	7e 12		 jle	 SHORT $LN56@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  00251	8b 45 dc	 mov	 eax, DWORD PTR _extra$1$[ebp]
  00254	8a 04 48	 mov	 al, BYTE PTR [eax+ecx*2]
  00257	88 45 08	 mov	 BYTE PTR _here$[ebp], al

; 225  :             here.val = base[work[sym]];

  0025a	8b 45 d8	 mov	 eax, DWORD PTR _base$1$[ebp]
  0025d	66 8b 04 48	 mov	 ax, WORD PTR [eax+ecx*2]

; 226  :         }

  00261	eb 06		 jmp	 SHORT $LN171@inflate_ta
$LN56@inflate_ta:

; 227  :         else {
; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00263	c6 45 08 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H

; 229  :             here.val = 0;

  00267	33 c0		 xor	 eax, eax
$LN171@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00269	66 89 45 0a	 mov	 WORD PTR _here$[ebp+2], ax
  0026d	8b cb		 mov	 ecx, ebx
  0026f	2b ca		 sub	 ecx, edx
  00271	b8 01 00 00 00	 mov	 eax, 1

; 234  :         fill = 1U << curr;

  00276	8b 55 c4	 mov	 edx, DWORD PTR tv1903[ebp]
  00279	d3 e0		 shl	 eax, cl
  0027b	8b 4d f8	 mov	 ecx, DWORD PTR _drop$1$[ebp]
  0027e	89 45 e0	 mov	 DWORD PTR _incr$1$[ebp], eax
  00281	c1 e0 02	 shl	 eax, 2
  00284	89 45 c8	 mov	 DWORD PTR tv1898[ebp], eax
  00287	8b c6		 mov	 eax, esi
  00289	d3 e8		 shr	 eax, cl
  0028b	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  0028e	03 c2		 add	 eax, edx

; 235  :         min = fill;                 /* save offset to next table */

  00290	89 55 bc	 mov	 DWORD PTR _min$2$[ebp], edx
  00293	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00296	8b 45 08	 mov	 eax, DWORD PTR _here$[ebp]
  00299	0f 1f 80 00 00
	00 00		 npad	 7
$LL30@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  002a0	2b 4d c8	 sub	 ecx, DWORD PTR tv1898[ebp]

; 238  :             next[(huff >> drop) + fill] = here;

  002a3	89 01		 mov	 DWORD PTR [ecx], eax
  002a5	2b 55 e0	 sub	 edx, DWORD PTR _incr$1$[ebp]

; 239  :         } while (fill != 0);

  002a8	75 f6		 jne	 SHORT $LL30@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  002aa	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  002ad	ba 01 00 00 00	 mov	 edx, 1
  002b2	d3 e2		 shl	 edx, cl

; 243  :         while (huff & incr)

  002b4	85 d6		 test	 edx, esi
  002b6	74 06		 je	 SHORT $LN32@inflate_ta
$LL31@inflate_ta:

; 244  :             incr >>= 1;

  002b8	d1 ea		 shr	 edx, 1
  002ba	85 d6		 test	 edx, esi
  002bc	75 fa		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 245  :         if (incr != 0) {

  002be	85 d2		 test	 edx, edx
  002c0	74 0e		 je	 SHORT $LN58@inflate_ta

; 246  :             huff &= incr - 1;

  002c2	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  002c5	23 c6		 and	 eax, esi

; 247  :             huff += incr;

  002c7	03 c2		 add	 eax, edx
  002c9	8b f0		 mov	 esi, eax
  002cb	89 45 e0	 mov	 DWORD PTR _huff$1$[ebp], eax

; 248  :         }

  002ce	eb 05		 jmp	 SHORT $LN59@inflate_ta
$LN58@inflate_ta:

; 249  :         else
; 250  :             huff = 0;

  002d0	33 f6		 xor	 esi, esi
  002d2	89 75 e0	 mov	 DWORD PTR _huff$1$[ebp], esi
$LN59@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  002d5	8b 45 14	 mov	 eax, DWORD PTR _work$[ebp]

; 254  :         if (--(count[len]) == 0) {

  002d8	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  002dd	83 c0 02	 add	 eax, 2
  002e0	66 01 4c 5d 9c	 add	 WORD PTR _count$[ebp+ebx*2], cx
  002e5	89 45 14	 mov	 DWORD PTR _work$[ebp], eax
  002e8	75 15		 jne	 SHORT $LN60@inflate_ta

; 255  :             if (len == max) break;

  002ea	3b df		 cmp	 ebx, edi
  002ec	0f 84 e9 00 00
	00		 je	 $LN90@inflate_ta

; 256  :             len = lens[work[sym]];

  002f2	0f b7 00	 movzx	 eax, WORD PTR [eax]
  002f5	8b 4d d4	 mov	 ecx, DWORD PTR _lens$1$[ebp]
  002f8	0f b7 1c 41	 movzx	 ebx, WORD PTR [ecx+eax*2]
  002fc	89 5d d0	 mov	 DWORD PTR _len$2$[ebp], ebx
$LN60@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  002ff	8b 4d ec	 mov	 ecx, DWORD PTR tv1916[ebp]
  00302	3b d9		 cmp	 ebx, ecx
  00304	0f 86 28 ff ff
	ff		 jbe	 $LN162@inflate_ta
  0030a	8b 45 c0	 mov	 eax, DWORD PTR _mask$1$[ebp]
  0030d	23 c6		 and	 eax, esi
  0030f	89 45 c8	 mov	 DWORD PTR tv1911[ebp], eax
  00312	3b 45 f4	 cmp	 eax, DWORD PTR _low$1$[ebp]
  00315	0f 84 17 ff ff
	ff		 je	 $LN162@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)
; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  0031b	8b 55 f0	 mov	 edx, DWORD PTR _next$1$[ebp]
  0031e	8b c1		 mov	 eax, ecx
  00320	8b 4d f8	 mov	 ecx, DWORD PTR _drop$1$[ebp]
  00323	85 c9		 test	 ecx, ecx
  00325	0f 45 c1	 cmovne	 eax, ecx
  00328	8b 4d bc	 mov	 ecx, DWORD PTR _min$2$[ebp]
  0032b	89 45 f8	 mov	 DWORD PTR _drop$1$[ebp], eax
  0032e	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  00331	8b cb		 mov	 ecx, ebx
  00333	89 55 f0	 mov	 DWORD PTR _next$1$[ebp], edx
  00336	2b c8		 sub	 ecx, eax

; 270  :             left = (int)(1 << curr);

  00338	ba 01 00 00 00	 mov	 edx, 1
  0033d	89 4d f4	 mov	 DWORD PTR _curr$1$[ebp], ecx
  00340	d3 e2		 shl	 edx, cl

; 271  :             while (curr + drop < max) {

  00342	3b df		 cmp	 ebx, edi
  00344	73 31		 jae	 SHORT $LN89@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)
; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  00346	8b 75 fc	 mov	 esi, DWORD PTR _max$1$[ebp]
  00349	8d 4d 9c	 lea	 ecx, DWORD PTR _count$[ebp]
  0034c	8b fb		 mov	 edi, ebx
  0034e	8d 0c 59	 lea	 ecx, DWORD PTR [ecx+ebx*2]
  00351	8b 5d f4	 mov	 ebx, DWORD PTR _curr$1$[ebp]
$LL33@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00354	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00357	2b d0		 sub	 edx, eax

; 273  :                 if (left <= 0) break;

  00359	85 d2		 test	 edx, edx
  0035b	7e 0b		 jle	 SHORT $LN159@inflate_ta

; 274  :                 curr++;

  0035d	47		 inc	 edi
  0035e	43		 inc	 ebx
  0035f	83 c1 02	 add	 ecx, 2

; 275  :                 left <<= 1;

  00362	03 d2		 add	 edx, edx
  00364	3b fe		 cmp	 edi, esi
  00366	72 ec		 jb	 SHORT $LL33@inflate_ta
$LN159@inflate_ta:
  00368	8b 75 e0	 mov	 esi, DWORD PTR _huff$1$[ebp]
  0036b	8b 7d fc	 mov	 edi, DWORD PTR _max$1$[ebp]
  0036e	89 5d f4	 mov	 DWORD PTR _curr$1$[ebp], ebx
  00371	8b 5d d0	 mov	 ebx, DWORD PTR _len$2$[ebp]
  00374	8b 4d f4	 mov	 ecx, DWORD PTR _curr$1$[ebp]
$LN89@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  00377	8b 55 cc	 mov	 edx, DWORD PTR _used$1$[ebp]
  0037a	b8 01 00 00 00	 mov	 eax, 1
  0037f	d3 e0		 shl	 eax, cl
  00381	03 d0		 add	 edx, eax
  00383	89 45 c4	 mov	 DWORD PTR tv1903[ebp], eax

; 280  :             if ((type == LENS && used >= ENOUGH_LENS) ||

  00386	8b 45 e4	 mov	 eax, DWORD PTR _type$1$[ebp]
  00389	89 55 cc	 mov	 DWORD PTR _used$1$[ebp], edx
  0038c	83 f8 01	 cmp	 eax, 1
  0038f	75 08		 jne	 SHORT $LN67@inflate_ta
  00391	81 fa 54 03 00
	00		 cmp	 edx, 852		; 00000354H
  00397	eb 0b		 jmp	 SHORT $LN172@inflate_ta
$LN67@inflate_ta:
  00399	83 f8 02	 cmp	 eax, 2
  0039c	75 0c		 jne	 SHORT $LN65@inflate_ta
  0039e	81 fa 50 02 00
	00		 cmp	 edx, 592		; 00000250H
$LN172@inflate_ta:

; 281  :                 (type == DISTS && used >= ENOUGH_DISTS))
; 282  :                 return 1;
; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;

  003a4	0f 83 6e fe ff
	ff		 jae	 $LN66@inflate_ta
$LN65@inflate_ta:

; 286  :             (*table)[low].op = (unsigned char)curr;

  003aa	8b 45 0c	 mov	 eax, DWORD PTR _table$[ebp]
  003ad	8b 55 c8	 mov	 edx, DWORD PTR tv1911[ebp]
  003b0	89 55 f4	 mov	 DWORD PTR _low$1$[ebp], edx
  003b3	8b 00		 mov	 eax, DWORD PTR [eax]
  003b5	88 0c 90	 mov	 BYTE PTR [eax+edx*4], cl

; 287  :             (*table)[low].bits = (unsigned char)root;

  003b8	8b 45 0c	 mov	 eax, DWORD PTR _table$[ebp]
  003bb	8b 4d ec	 mov	 ecx, DWORD PTR tv1916[ebp]
  003be	8b 00		 mov	 eax, DWORD PTR [eax]
  003c0	88 4c 90 01	 mov	 BYTE PTR [eax+edx*4+1], cl

; 288  :             (*table)[low].val = (unsigned short)(next - *table);

  003c4	8b 45 0c	 mov	 eax, DWORD PTR _table$[ebp]
  003c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c9	8b 45 f0	 mov	 eax, DWORD PTR _next$1$[ebp]
  003cc	2b c1		 sub	 eax, ecx
  003ce	c1 f8 02	 sar	 eax, 2
  003d1	66 89 44 91 02	 mov	 WORD PTR [ecx+edx*4+2], ax

; 289  :         }
; 290  :     }

  003d6	e9 57 fe ff ff	 jmp	 $LN162@inflate_ta
$LN90@inflate_ta:

; 291  : 
; 292  :     /*
; 293  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 294  :        loop above in incrementing huff for table indices.  It is assumed that
; 295  :        len is equal to curr + drop, so there is no loop needed to increment
; 296  :        through high index bits.  When the current sub-table is filled, the loop
; 297  :        drops back to the root table to fill in any remaining entries there.
; 298  :      */
; 299  :     here.op = (unsigned char)64;                /* invalid code marker */
; 300  :     here.bits = (unsigned char)(len - drop);
; 301  :     here.val = (unsigned short)0;

  003db	33 c0		 xor	 eax, eax
  003dd	c6 45 08 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H
  003e1	66 89 45 0a	 mov	 WORD PTR _here$[ebp+2], ax

; 302  :     while (huff != 0) {

  003e5	85 f6		 test	 esi, esi
  003e7	74 5a		 je	 SHORT $LN160@inflate_ta
  003e9	8b 7d f4	 mov	 edi, DWORD PTR _low$1$[ebp]
  003ec	0f 1f 40 00	 npad	 4
$LL35@inflate_ta:

; 303  :         /* when done with sub-table, drop back to root table */
; 304  :         if (drop != 0 && (huff & mask) != low) {

  003f0	8b 4d f8	 mov	 ecx, DWORD PTR _drop$1$[ebp]
  003f3	85 c9		 test	 ecx, ecx
  003f5	74 1c		 je	 SHORT $LN68@inflate_ta
  003f7	8b 45 c0	 mov	 eax, DWORD PTR _mask$1$[ebp]
  003fa	23 c6		 and	 eax, esi
  003fc	3b c7		 cmp	 eax, edi
  003fe	74 13		 je	 SHORT $LN68@inflate_ta

; 305  :             drop = 0;
; 306  :             len = root;
; 307  :             next = *table;

  00400	8b 45 0c	 mov	 eax, DWORD PTR _table$[ebp]
  00403	33 c9		 xor	 ecx, ecx
  00405	8b 5d ec	 mov	 ebx, DWORD PTR tv1916[ebp]
  00408	89 4d f8	 mov	 DWORD PTR _drop$1$[ebp], ecx

; 308  :             here.bits = (unsigned char)len;

  0040b	88 5d 09	 mov	 BYTE PTR _here$[ebp+1], bl
  0040e	8b 00		 mov	 eax, DWORD PTR [eax]
  00410	89 45 f0	 mov	 DWORD PTR _next$1$[ebp], eax
$LN68@inflate_ta:

; 309  :         }
; 310  : 
; 311  :         /* put invalid code marker in table */
; 312  :         next[huff >> drop] = here;

  00413	8b 45 08	 mov	 eax, DWORD PTR _here$[ebp]
  00416	8b d6		 mov	 edx, esi
  00418	d3 ea		 shr	 edx, cl
  0041a	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  0041d	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 313  : 
; 314  :         /* backwards increment the len-bit code huff */
; 315  :         incr = 1U << (len - 1);

  00420	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
  00423	b8 01 00 00 00	 mov	 eax, 1
  00428	d3 e0		 shl	 eax, cl

; 316  :         while (huff & incr)

  0042a	85 c6		 test	 eax, esi
  0042c	74 08		 je	 SHORT $LN38@inflate_ta
  0042e	66 90		 npad	 2
$LL37@inflate_ta:

; 317  :             incr >>= 1;

  00430	d1 e8		 shr	 eax, 1
  00432	85 c6		 test	 eax, esi
  00434	75 fa		 jne	 SHORT $LL37@inflate_ta
$LN38@inflate_ta:

; 318  :         if (incr != 0) {

  00436	85 c0		 test	 eax, eax
  00438	74 09		 je	 SHORT $LN160@inflate_ta

; 319  :             huff &= incr - 1;

  0043a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0043d	23 f1		 and	 esi, ecx

; 320  :             huff += incr;

  0043f	03 f0		 add	 esi, eax
  00441	75 ad		 jne	 SHORT $LL35@inflate_ta
$LN160@inflate_ta:

; 321  :         }
; 322  :         else
; 323  :             huff = 0;
; 324  :     }
; 325  : 
; 326  :     /* set return parameters */
; 327  :     *table += used;

  00443	8b 4d 0c	 mov	 ecx, DWORD PTR _table$[ebp]
  00446	8b 45 cc	 mov	 eax, DWORD PTR _used$1$[ebp]
  00449	c1 e0 02	 shl	 eax, 2
  0044c	5f		 pop	 edi
  0044d	01 01		 add	 DWORD PTR [ecx], eax

; 328  :     *bits = root;

  0044f	8b 4d 10	 mov	 ecx, DWORD PTR _bits$[ebp]
  00452	8b 45 ec	 mov	 eax, DWORD PTR tv1916[ebp]

; 329  :     return 0;
; 330  : }

  00455	5e		 pop	 esi
  00456	5b		 pop	 ebx
  00457	89 01		 mov	 DWORD PTR [ecx], eax
  00459	33 c0		 xor	 eax, eax
  0045b	8b e5		 mov	 esp, ebp
  0045d	5d		 pop	 ebp
  0045e	c3		 ret	 0
$LN46@inflate_ta:
  0045f	5f		 pop	 edi
  00460	5e		 pop	 esi
  00461	83 c8 ff	 or	 eax, -1
  00464	5b		 pop	 ebx
  00465	8b e5		 mov	 esp, ebp
  00467	5d		 pop	 ebp
  00468	c3		 ret	 0
_inflate_table ENDP
_TEXT	ENDS
END
