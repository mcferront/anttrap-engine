; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@	; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ ; `string'
EXTRN	__imp__close:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__read:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ DB 'out of room t'
	DB	'o push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ DB 'requested le'
	DB	'ngth does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error@ DB 'compressed data error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ DB 'internal err'
	DB	'or: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@ DB 'unexpected end of file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
PUBLIC	_gzdirect@4
PUBLIC	_gzgets@12
PUBLIC	_gzungetc@8
PUBLIC	_gzgetc@4
PUBLIC	_gzread@12
PUBLIC	_gzclose_r@4
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gzclose_r@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_r@4 PROC					; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 630  :     int ret;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 5a		 je	 SHORT $LN6@gzclose_r

; 635  :         return Z_STREAM_ERROR;
; 636  :     state = (gz_statep)file;
; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  0000b	81 3f 4f 1c 00
	00		 cmp	 DWORD PTR [edi], 7247	; 00001c4fH
  00011	75 52		 jne	 SHORT $LN6@gzclose_r

; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  00013	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00017	53		 push	 ebx
  00018	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  0001e	56		 push	 esi
  0001f	74 16		 je	 SHORT $LN4@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00021	8d 47 54	 lea	 eax, DWORD PTR [edi+84]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _inflateEnd@4

; 645  :         free(state->out);

  0002a	ff 77 1c	 push	 DWORD PTR [edi+28]
  0002d	ff d3		 call	 ebx

; 646  :         free(state->in);

  0002f	ff 77 18	 push	 DWORD PTR [edi+24]
  00032	ff d3		 call	 ebx
  00034	83 c4 08	 add	 esp, 8
$LN4@gzclose_r:

; 647  :     }
; 648  :     gz_error(state, Z_OK, NULL);

  00037	6a 00		 push	 0
  00039	33 d2		 xor	 edx, edx
  0003b	8b cf		 mov	 ecx, edi
  0003d	e8 00 00 00 00	 call	 _gz_error

; 649  :     free(state->path);

  00042	ff 77 08	 push	 DWORD PTR [edi+8]
  00045	ff d3		 call	 ebx

; 650  :     ret = close(state->fd);

  00047	ff 77 04	 push	 DWORD PTR [edi+4]
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__close

; 651  :     free(state);

  00050	57		 push	 edi
  00051	8b f0		 mov	 esi, eax
  00053	ff d3		 call	 ebx
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 652  :     return ret ? Z_ERRNO : Z_OK;

  00058	f7 de		 neg	 esi
  0005a	1b f6		 sbb	 esi, esi
  0005c	8b c6		 mov	 eax, esi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	5f		 pop	 edi

; 653  : }

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
$LN6@gzclose_r:

; 640  :         return Z_STREAM_ERROR;

  00065	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006a	5f		 pop	 edi

; 653  : }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
_gzclose_r@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_load
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_state$1$ = -4						; size = 4
_len$ = 8						; size = 4
_have$ = 12						; size = 4
_gz_load PROC						; COMDAT
; _state$ = ecx
; _buf$ = edx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 27   :     int ret;
; 28   : 
; 29   :     *have = 0;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _len$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _have$[ebp]
  0000f	33 f6		 xor	 esi, esi
  00011	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00014	89 4d fc	 mov	 DWORD PTR _state$1$[ebp], ecx
  00017	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0001d	0f 1f 00	 npad	 3
$LL4@gz_load:

; 30   :     do {
; 31   :         ret = read(state->fd, buf + *have, len - *have);

  00020	8b c3		 mov	 eax, ebx
  00022	2b c6		 sub	 eax, esi
  00024	50		 push	 eax
  00025	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00028	50		 push	 eax
  00029	ff 71 04	 push	 DWORD PTR [ecx+4]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__read
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   :         if (ret <= 0)

  00035	85 c0		 test	 eax, eax
  00037	7e 10		 jle	 SHORT $LN3@gz_load

; 33   :             break;
; 34   :         *have += ret;

  00039	8b 37		 mov	 esi, DWORD PTR [edi]

; 35   :     } while (*have < len);

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0003e	03 f0		 add	 esi, eax
  00040	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00043	89 37		 mov	 DWORD PTR [edi], esi
  00045	3b f3		 cmp	 esi, ebx
  00047	72 d7		 jb	 SHORT $LL4@gz_load
$LN3@gz_load:
  00049	5f		 pop	 edi

; 36   :     if (ret < 0) {

  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	85 c0		 test	 eax, eax
  0004e	79 24		 jns	 SHORT $LN13@gz_load

; 37   :         gz_error(state, Z_ERRNO, zstrerror());

  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00056	ff 30		 push	 DWORD PTR [eax]
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00061	83 ca ff	 or	 edx, -1
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _gz_error
  0006a	83 c4 08	 add	 esp, 8

; 38   :         return -1;

  0006d	83 c8 ff	 or	 eax, -1

; 43   : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN13@gz_load:

; 39   :     }
; 40   :     if (ret == 0)

  00074	75 0a		 jne	 SHORT $LN7@gz_load

; 41   :         state->eof = 1;

  00076	8b 4d fc	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00079	c7 41 28 01 00
	00 00		 mov	 DWORD PTR [ecx+40], 1
$LN7@gz_load:

; 42   :     return 0;

  00080	33 c0		 xor	 eax, eax

; 43   : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_gz_load ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_avail
_TEXT	SEGMENT
_gz_avail PROC						; COMDAT
; _state$ = ecx

; 52   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 53   :     z_streamp strm = &(state->strm);
; 54   : 
; 55   :     if (state->err != Z_OK)

  00003	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00007	75 27		 jne	 SHORT $LN6@gz_avail

; 56   :         return -1;
; 57   :     if (state->eof == 0) {

  00009	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0000d	75 1d		 jne	 SHORT $LN3@gz_avail

; 58   :         if (gz_load(state, state->in, state->size,
; 59   :                 (unsigned *)&(strm->avail_in)) == -1)

  0000f	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00012	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  00015	50		 push	 eax
  00016	ff 76 10	 push	 DWORD PTR [esi+16]
  00019	e8 00 00 00 00	 call	 _gz_load
  0001e	83 c4 08	 add	 esp, 8
  00021	83 f8 ff	 cmp	 eax, -1
  00024	74 0a		 je	 SHORT $LN6@gz_avail

; 61   :         strm->next_in = state->in;

  00026	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00029	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN3@gz_avail:

; 62   :     }
; 63   :     return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 64   : }

  0002f	c3		 ret	 0
$LN6@gz_avail:

; 60   :             return -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	5e		 pop	 esi

; 64   : }

  00034	c3		 ret	 0
_gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_next4
_TEXT	SEGMENT
_gz_next4 PROC						; COMDAT
; _state$ = ecx
; _ret$ = edx

; 76   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx
  00004	8b da		 mov	 ebx, edx
  00006	57		 push	 edi

; 77   :     int ch;
; 78   :     unsigned long val;
; 79   :     z_streamp strm = &(state->strm);
; 80   : 
; 81   :     val = NEXT();

  00007	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0000b	75 11		 jne	 SHORT $LN25@gz_next4
  0000d	e8 00 00 00 00	 call	 _gz_avail
  00012	83 f8 ff	 cmp	 eax, -1
  00015	75 07		 jne	 SHORT $LN25@gz_next4
  00017	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0001a	0b f8		 or	 edi, eax
  0001c	eb 1a		 jmp	 SHORT $LN6@gz_next4
$LN25@gz_next4:
  0001e	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00021	85 c9		 test	 ecx, ecx
  00023	75 05		 jne	 SHORT $LN5@gz_next4
  00025	83 cf ff	 or	 edi, -1
  00028	eb 0e		 jmp	 SHORT $LN6@gz_next4
$LN5@gz_next4:
  0002a	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0002d	49		 dec	 ecx
  0002e	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00031	0f b6 38	 movzx	 edi, BYTE PTR [eax]
  00034	40		 inc	 eax
  00035	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN6@gz_next4:

; 82   :     val += (unsigned)NEXT() << 8;

  00038	85 c9		 test	 ecx, ecx
  0003a	75 13		 jne	 SHORT $LN26@gz_next4
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 _gz_avail
  00043	83 f8 ff	 cmp	 eax, -1
  00046	75 07		 jne	 SHORT $LN26@gz_next4
  00048	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  0004b	0b c8		 or	 ecx, eax
  0004d	eb 1a		 jmp	 SHORT $LN10@gz_next4
$LN26@gz_next4:
  0004f	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  00052	85 d2		 test	 edx, edx
  00054	75 05		 jne	 SHORT $LN9@gz_next4
  00056	83 c9 ff	 or	 ecx, -1
  00059	eb 0e		 jmp	 SHORT $LN10@gz_next4
$LN9@gz_next4:
  0005b	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  0005e	4a		 dec	 edx
  0005f	89 56 58	 mov	 DWORD PTR [esi+88], edx
  00062	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00065	40		 inc	 eax
  00066	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN10@gz_next4:
  00069	c1 e1 08	 shl	 ecx, 8
  0006c	03 f9		 add	 edi, ecx

; 83   :     val += (unsigned long)NEXT() << 16;

  0006e	85 d2		 test	 edx, edx
  00070	75 13		 jne	 SHORT $LN22@gz_next4
  00072	8b ce		 mov	 ecx, esi
  00074	e8 00 00 00 00	 call	 _gz_avail
  00079	83 f8 ff	 cmp	 eax, -1
  0007c	75 07		 jne	 SHORT $LN22@gz_next4
  0007e	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  00081	0b c8		 or	 ecx, eax
  00083	eb 1a		 jmp	 SHORT $LN14@gz_next4
$LN22@gz_next4:
  00085	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  00088	85 d2		 test	 edx, edx
  0008a	75 05		 jne	 SHORT $LN13@gz_next4
  0008c	83 c9 ff	 or	 ecx, -1
  0008f	eb 0e		 jmp	 SHORT $LN14@gz_next4
$LN13@gz_next4:
  00091	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  00094	4a		 dec	 edx
  00095	89 56 58	 mov	 DWORD PTR [esi+88], edx
  00098	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0009b	40		 inc	 eax
  0009c	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN14@gz_next4:
  0009f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000a2	03 f9		 add	 edi, ecx

; 84   :     ch = NEXT();

  000a4	85 d2		 test	 edx, edx
  000a6	75 0c		 jne	 SHORT $LN23@gz_next4
  000a8	8b ce		 mov	 ecx, esi
  000aa	e8 00 00 00 00	 call	 _gz_avail
  000af	83 f8 ff	 cmp	 eax, -1
  000b2	74 22		 je	 SHORT $LN24@gz_next4
$LN23@gz_next4:
  000b4	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000b7	85 c0		 test	 eax, eax
  000b9	74 1b		 je	 SHORT $LN24@gz_next4
  000bb	48		 dec	 eax
  000bc	89 46 58	 mov	 DWORD PTR [esi+88], eax
  000bf	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  000c2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c5	40		 inc	 eax

; 85   :     if (ch == -1)
; 86   :         return -1;
; 87   :     val += (unsigned long)ch << 24;

  000c6	c1 e1 18	 shl	 ecx, 24			; 00000018H
  000c9	03 cf		 add	 ecx, edi
  000cb	89 46 54	 mov	 DWORD PTR [esi+84], eax
  000ce	5f		 pop	 edi

; 88   :     *ret = val;
; 89   :     return 0;
; 90   : }

  000cf	5e		 pop	 esi
  000d0	89 0b		 mov	 DWORD PTR [ebx], ecx
  000d2	33 c0		 xor	 eax, eax
  000d4	5b		 pop	 ebx
  000d5	c3		 ret	 0
$LN24@gz_next4:
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	83 c8 ff	 or	 eax, -1
  000db	5b		 pop	 ebx
  000dc	c3		 ret	 0
_gz_next4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_head
_TEXT	SEGMENT
_flags$1$ = -4						; size = 4
_gz_head PROC						; COMDAT
; _state$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 107  :     z_streamp strm = &(state->strm);
; 108  :     int flags;
; 109  :     unsigned len;
; 110  : 
; 111  :     /* allocate read buffers and inflate memory */
; 112  :     if (state->size == 0) {

  00009	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  0000d	8d 7b 54	 lea	 edi, DWORD PTR [ebx+84]
  00010	0f 85 d2 00 00
	00		 jne	 $LN13@gz_head

; 113  :         /* allocate buffers */
; 114  :         state->in = malloc(state->want);

  00016	ff 73 14	 push	 DWORD PTR [ebx+20]
  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__malloc
  0001f	ff d6		 call	 esi
  00021	89 43 18	 mov	 DWORD PTR [ebx+24], eax

; 115  :         state->out = malloc(state->want << 1);

  00024	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00027	03 c0		 add	 eax, eax
  00029	50		 push	 eax
  0002a	ff d6		 call	 esi

; 116  :         if (state->in == NULL || state->out == NULL) {

  0002c	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  0002f	83 c4 08	 add	 esp, 8
  00032	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  00035	85 c9		 test	 ecx, ecx
  00037	74 74		 je	 SHORT $LN98@gz_head
  00039	85 c0		 test	 eax, eax
  0003b	74 72		 je	 SHORT $LN135@gz_head

; 122  :             return -1;
; 123  :         }
; 124  :         state->size = state->want;

  0003d	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]

; 125  : 
; 126  :         /* allocate inflate memory */
; 127  :         state->strm.zalloc = Z_NULL;
; 128  :         state->strm.zfree = Z_NULL;
; 129  :         state->strm.opaque = Z_NULL;
; 130  :         state->strm.avail_in = 0;
; 131  :         state->strm.next_in = Z_NULL;
; 132  :         if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */

  00040	6a 38		 push	 56			; 00000038H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45@
  00047	6a f1		 push	 -15			; fffffff1H
  00049	57		 push	 edi
  0004a	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0004d	c7 43 74 00 00
	00 00		 mov	 DWORD PTR [ebx+116], 0
  00054	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [ebx+120], 0
  0005b	c7 43 7c 00 00
	00 00		 mov	 DWORD PTR [ebx+124], 0
  00062	c7 43 58 00 00
	00 00		 mov	 DWORD PTR [ebx+88], 0
  00069	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  0006f	e8 00 00 00 00	 call	 _inflateInit2_@16
  00074	85 c0		 test	 eax, eax
  00076	74 70		 je	 SHORT $LN13@gz_head

; 133  :             free(state->out);

  00078	ff 73 1c	 push	 DWORD PTR [ebx+28]
  0007b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  00081	ff d6		 call	 esi

; 134  :             free(state->in);

  00083	ff 73 18	 push	 DWORD PTR [ebx+24]
  00086	ff d6		 call	 esi

; 135  :             state->size = 0;
; 136  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  0008d	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  00092	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0
  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 _gz_error
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 137  :             return -1;

  000a3	83 c8 ff	 or	 eax, -1
  000a6	5f		 pop	 edi

; 222  :     return 0;
; 223  : }

  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN98@gz_head:

; 117  :             if (state->out != NULL)

  000ad	85 c0		 test	 eax, eax
$LN135@gz_head:
  000af	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  000b5	74 09		 je	 SHORT $LN11@gz_head

; 118  :                 free(state->out);

  000b7	50		 push	 eax
  000b8	ff d6		 call	 esi
  000ba	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  000bd	83 c4 04	 add	 esp, 4
$LN11@gz_head:

; 119  :             if (state->in != NULL)

  000c0	85 c9		 test	 ecx, ecx
  000c2	74 06		 je	 SHORT $LN12@gz_head

; 120  :                 free(state->in);

  000c4	51		 push	 ecx
  000c5	ff d6		 call	 esi
  000c7	83 c4 04	 add	 esp, 4
$LN12@gz_head:

; 121  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  000cf	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  000d4	8b cb		 mov	 ecx, ebx
  000d6	e8 00 00 00 00	 call	 _gz_error
  000db	83 c4 04	 add	 esp, 4
$LN130@gz_head:

; 222  :     return 0;
; 223  : }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	83 c8 ff	 or	 eax, -1
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN13@gz_head:

; 138  :         }
; 139  :     }
; 140  : 
; 141  :     /* get some data in the input buffer */
; 142  :     if (strm->avail_in == 0) {

  000e8	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000eb	85 c9		 test	 ecx, ecx
  000ed	75 17		 jne	 SHORT $LN16@gz_head

; 143  :         if (gz_avail(state) == -1)

  000ef	8b cb		 mov	 ecx, ebx
  000f1	e8 00 00 00 00	 call	 _gz_avail
  000f6	83 f8 ff	 cmp	 eax, -1
  000f9	74 e3		 je	 SHORT $LN130@gz_head

; 144  :             return -1;
; 145  :         if (strm->avail_in == 0)

  000fb	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000fe	85 c9		 test	 ecx, ecx
  00100	0f 84 3e 03 00
	00		 je	 $LN136@gz_head
$LN16@gz_head:

; 146  :             return 0;
; 147  :     }
; 148  : 
; 149  :     /* look for the gzip magic header bytes 31 and 139 */
; 150  :     if (strm->next_in[0] == 31) {

  00106	8b 07		 mov	 eax, DWORD PTR [edi]
  00108	80 38 1f	 cmp	 BYTE PTR [eax], 31	; 0000001fH
  0010b	0f 85 f4 02 00
	00		 jne	 $LN129@gz_head

; 151  :         strm->avail_in--;

  00111	49		 dec	 ecx

; 152  :         strm->next_in++;

  00112	40		 inc	 eax
  00113	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00116	89 07		 mov	 DWORD PTR [edi], eax

; 153  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00118	85 c9		 test	 ecx, ecx
  0011a	75 0c		 jne	 SHORT $LN125@gz_head
  0011c	8b cb		 mov	 ecx, ebx
  0011e	e8 00 00 00 00	 call	 _gz_avail
  00123	83 f8 ff	 cmp	 eax, -1
  00126	74 b6		 je	 SHORT $LN130@gz_head
$LN125@gz_head:

; 154  :             return -1;
; 155  :         if (strm->avail_in && strm->next_in[0] == 139) {

  00128	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0012b	85 c9		 test	 ecx, ecx
  0012d	0f 84 c5 02 00
	00		 je	 $LN128@gz_head
  00133	8b 07		 mov	 eax, DWORD PTR [edi]
  00135	80 38 8b	 cmp	 BYTE PTR [eax], 139	; 0000008bH
  00138	0f 85 ba 02 00
	00		 jne	 $LN128@gz_head

; 156  :             /* we have a gzip header, woo hoo! */
; 157  :             strm->avail_in--;

  0013e	49		 dec	 ecx

; 158  :             strm->next_in++;

  0013f	40		 inc	 eax
  00140	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00143	89 07		 mov	 DWORD PTR [edi], eax

; 159  : 
; 160  :             /* skip rest of header */
; 161  :             if (NEXT() != 8) {      /* compression method */

  00145	85 c9		 test	 ecx, ecx
  00147	75 10		 jne	 SHORT $LN100@gz_head
  00149	8b cb		 mov	 ecx, ebx
  0014b	e8 00 00 00 00	 call	 _gz_avail
  00150	83 f8 ff	 cmp	 eax, -1
  00153	0f 84 81 02 00
	00		 je	 $LN112@gz_head
$LN100@gz_head:
  00159	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0015c	85 c0		 test	 eax, eax
  0015e	0f 84 76 02 00
	00		 je	 $LN112@gz_head
  00164	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00167	8b 07		 mov	 eax, DWORD PTR [edi]
  00169	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0016c	8a 08		 mov	 cl, BYTE PTR [eax]
  0016e	40		 inc	 eax
  0016f	89 07		 mov	 DWORD PTR [edi], eax
  00171	80 f9 08	 cmp	 cl, 8
  00174	0f 85 60 02 00
	00		 jne	 $LN112@gz_head

; 163  :                 return -1;
; 164  :             }
; 165  :             flags = NEXT();

  0017a	85 d2		 test	 edx, edx
  0017c	75 10		 jne	 SHORT $LN126@gz_head
  0017e	8b cb		 mov	 ecx, ebx
  00180	e8 00 00 00 00	 call	 _gz_avail
  00185	83 f8 ff	 cmp	 eax, -1
  00188	75 04		 jne	 SHORT $LN126@gz_head
  0018a	0b c8		 or	 ecx, eax
  0018c	eb 18		 jmp	 SHORT $LN137@gz_head
$LN126@gz_head:
  0018e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00191	85 c0		 test	 eax, eax
  00193	75 05		 jne	 SHORT $LN35@gz_head
  00195	83 c9 ff	 or	 ecx, -1
  00198	eb 0c		 jmp	 SHORT $LN137@gz_head
$LN35@gz_head:
  0019a	48		 dec	 eax
  0019b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0019e	8b 07		 mov	 eax, DWORD PTR [edi]
  001a0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001a3	40		 inc	 eax
  001a4	89 07		 mov	 DWORD PTR [edi], eax
$LN137@gz_head:

; 166  :             if (flags & 0xe0) {     /* reserved flag bits */

  001a6	89 4d fc	 mov	 DWORD PTR _flags$1$[ebp], ecx
  001a9	f6 c1 e0	 test	 cl, 224			; 000000e0H
  001ac	74 0a		 je	 SHORT $LN22@gz_head

; 167  :                 gz_error(state, Z_DATA_ERROR, "unknown header flags set");

  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@

; 168  :                 return -1;

  001b3	e9 27 02 00 00	 jmp	 $LN151@gz_head
$LN22@gz_head:

; 169  :             }
; 170  :             NEXT();                 /* modification time */

  001b8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001bb	85 c0		 test	 eax, eax
  001bd	75 13		 jne	 SHORT $LN139@gz_head
  001bf	8b cb		 mov	 ecx, ebx
  001c1	e8 00 00 00 00	 call	 _gz_avail
  001c6	83 f8 ff	 cmp	 eax, -1
  001c9	74 0d		 je	 SHORT $LN40@gz_head
  001cb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001ce	85 c0		 test	 eax, eax
  001d0	74 06		 je	 SHORT $LN40@gz_head
$LN139@gz_head:
  001d2	48		 dec	 eax
  001d3	ff 07		 inc	 DWORD PTR [edi]
  001d5	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN40@gz_head:

; 171  :             NEXT();

  001d8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001db	85 c0		 test	 eax, eax
  001dd	75 13		 jne	 SHORT $LN141@gz_head
  001df	8b cb		 mov	 ecx, ebx
  001e1	e8 00 00 00 00	 call	 _gz_avail
  001e6	83 f8 ff	 cmp	 eax, -1
  001e9	74 0d		 je	 SHORT $LN44@gz_head
  001eb	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  001ee	85 c0		 test	 eax, eax
  001f0	74 06		 je	 SHORT $LN44@gz_head
$LN141@gz_head:
  001f2	48		 dec	 eax
  001f3	ff 07		 inc	 DWORD PTR [edi]
  001f5	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN44@gz_head:

; 172  :             NEXT();

  001f8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  001fb	85 c0		 test	 eax, eax
  001fd	75 13		 jne	 SHORT $LN143@gz_head
  001ff	8b cb		 mov	 ecx, ebx
  00201	e8 00 00 00 00	 call	 _gz_avail
  00206	83 f8 ff	 cmp	 eax, -1
  00209	74 0d		 je	 SHORT $LN48@gz_head
  0020b	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  0020e	85 c0		 test	 eax, eax
  00210	74 06		 je	 SHORT $LN48@gz_head
$LN143@gz_head:
  00212	48		 dec	 eax
  00213	ff 07		 inc	 DWORD PTR [edi]
  00215	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN48@gz_head:

; 173  :             NEXT();

  00218	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0021b	85 c0		 test	 eax, eax
  0021d	75 13		 jne	 SHORT $LN145@gz_head
  0021f	8b cb		 mov	 ecx, ebx
  00221	e8 00 00 00 00	 call	 _gz_avail
  00226	83 f8 ff	 cmp	 eax, -1
  00229	74 0d		 je	 SHORT $LN52@gz_head
  0022b	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  0022e	85 c0		 test	 eax, eax
  00230	74 06		 je	 SHORT $LN52@gz_head
$LN145@gz_head:
  00232	48		 dec	 eax
  00233	ff 07		 inc	 DWORD PTR [edi]
  00235	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN52@gz_head:

; 174  :             NEXT();                 /* extra flags */

  00238	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0023b	85 c0		 test	 eax, eax
  0023d	75 13		 jne	 SHORT $LN147@gz_head
  0023f	8b cb		 mov	 ecx, ebx
  00241	e8 00 00 00 00	 call	 _gz_avail
  00246	83 f8 ff	 cmp	 eax, -1
  00249	74 0d		 je	 SHORT $LN56@gz_head
  0024b	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  0024e	85 c0		 test	 eax, eax
  00250	74 06		 je	 SHORT $LN56@gz_head
$LN147@gz_head:
  00252	48		 dec	 eax
  00253	ff 07		 inc	 DWORD PTR [edi]
  00255	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN56@gz_head:

; 175  :             NEXT();                 /* operating system */

  00258	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0025c	75 0c		 jne	 SHORT $LN58@gz_head
  0025e	8b cb		 mov	 ecx, ebx
  00260	e8 00 00 00 00	 call	 _gz_avail
  00265	83 f8 ff	 cmp	 eax, -1
  00268	74 0d		 je	 SHORT $LN60@gz_head
$LN58@gz_head:
  0026a	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0026d	85 c0		 test	 eax, eax
  0026f	74 06		 je	 SHORT $LN60@gz_head
  00271	48		 dec	 eax
  00272	ff 07		 inc	 DWORD PTR [edi]
  00274	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN60@gz_head:

; 176  :             if (flags & 4) {        /* extra field */

  00277	8b 45 fc	 mov	 eax, DWORD PTR _flags$1$[ebp]
  0027a	a8 04		 test	 al, 4
  0027c	0f 84 8a 00 00
	00		 je	 $LN116@gz_head

; 177  :                 len = (unsigned)NEXT();

  00282	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00285	85 c9		 test	 ecx, ecx
  00287	75 1c		 jne	 SHORT $LN63@gz_head
  00289	8b cb		 mov	 ecx, ebx
  0028b	e8 00 00 00 00	 call	 _gz_avail
  00290	8b 4b 58	 mov	 ecx, DWORD PTR [ebx+88]
  00293	83 f8 ff	 cmp	 eax, -1
  00296	75 04		 jne	 SHORT $LN102@gz_head
  00298	0b f0		 or	 esi, eax
  0029a	eb 15		 jmp	 SHORT $LN64@gz_head
$LN102@gz_head:
  0029c	85 c9		 test	 ecx, ecx
  0029e	75 05		 jne	 SHORT $LN63@gz_head
  002a0	83 ce ff	 or	 esi, -1
  002a3	eb 10		 jmp	 SHORT $LN121@gz_head
$LN63@gz_head:
  002a5	8b 07		 mov	 eax, DWORD PTR [edi]
  002a7	49		 dec	 ecx
  002a8	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  002ab	0f b6 30	 movzx	 esi, BYTE PTR [eax]
  002ae	40		 inc	 eax
  002af	89 07		 mov	 DWORD PTR [edi], eax
$LN64@gz_head:

; 178  :                 len += (unsigned)NEXT() << 8;

  002b1	85 c9		 test	 ecx, ecx
  002b3	75 10		 jne	 SHORT $LN103@gz_head
$LN121@gz_head:
  002b5	8b cb		 mov	 ecx, ebx
  002b7	e8 00 00 00 00	 call	 _gz_avail
  002bc	83 f8 ff	 cmp	 eax, -1
  002bf	75 04		 jne	 SHORT $LN103@gz_head
  002c1	0b c8		 or	 ecx, eax
  002c3	eb 18		 jmp	 SHORT $LN68@gz_head
$LN103@gz_head:
  002c5	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002c8	85 c0		 test	 eax, eax
  002ca	75 05		 jne	 SHORT $LN67@gz_head
  002cc	83 c9 ff	 or	 ecx, -1
  002cf	eb 0c		 jmp	 SHORT $LN68@gz_head
$LN67@gz_head:
  002d1	48		 dec	 eax
  002d2	89 47 04	 mov	 DWORD PTR [edi+4], eax
  002d5	8b 07		 mov	 eax, DWORD PTR [edi]
  002d7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002da	40		 inc	 eax
  002db	89 07		 mov	 DWORD PTR [edi], eax
$LN68@gz_head:
  002dd	c1 e1 08	 shl	 ecx, 8
  002e0	03 f1		 add	 esi, ecx

; 179  :                 while (len--)

  002e2	74 25		 je	 SHORT $LN134@gz_head

; 173  :             NEXT();

  002e4	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
$LL2@gz_head:

; 179  :                 while (len--)

  002e7	4e		 dec	 esi

; 180  :                     if (NEXT() < 0)

  002e8	85 c0		 test	 eax, eax
  002ea	75 13		 jne	 SHORT $LN122@gz_head
  002ec	8b cb		 mov	 ecx, ebx
  002ee	e8 00 00 00 00	 call	 _gz_avail
  002f3	83 f8 ff	 cmp	 eax, -1
  002f6	74 11		 je	 SHORT $LN134@gz_head
  002f8	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  002fb	85 c0		 test	 eax, eax
  002fd	74 0a		 je	 SHORT $LN134@gz_head
$LN122@gz_head:
  002ff	ff 07		 inc	 DWORD PTR [edi]
  00301	48		 dec	 eax
  00302	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00305	85 f6		 test	 esi, esi
  00307	75 de		 jne	 SHORT $LL2@gz_head
$LN134@gz_head:

; 181  :                         break;
; 182  :             }
; 183  :             if (flags & 8)          /* file name */

  00309	8b 45 fc	 mov	 eax, DWORD PTR _flags$1$[ebp]
$LN116@gz_head:
  0030c	a8 08		 test	 al, 8
  0030e	74 2c		 je	 SHORT $LN118@gz_head

; 173  :             NEXT();

  00310	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
$LL4@gz_head:

; 184  :                 while (NEXT() > 0)

  00313	85 d2		 test	 edx, edx
  00315	75 13		 jne	 SHORT $LN123@gz_head
  00317	8b cb		 mov	 ecx, ebx
  00319	e8 00 00 00 00	 call	 _gz_avail
  0031e	83 f8 ff	 cmp	 eax, -1
  00321	74 16		 je	 SHORT $LN132@gz_head
  00323	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00326	85 d2		 test	 edx, edx
  00328	74 0f		 je	 SHORT $LN132@gz_head
$LN123@gz_head:
  0032a	8b 07		 mov	 eax, DWORD PTR [edi]
  0032c	4a		 dec	 edx
  0032d	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00330	8a 08		 mov	 cl, BYTE PTR [eax]
  00332	40		 inc	 eax
  00333	89 07		 mov	 DWORD PTR [edi], eax
  00335	84 c9		 test	 cl, cl
  00337	75 da		 jne	 SHORT $LL4@gz_head
$LN132@gz_head:
  00339	8b 45 fc	 mov	 eax, DWORD PTR _flags$1$[ebp]
$LN118@gz_head:

; 185  :                     ;
; 186  :             if (flags & 16)         /* comment */

  0033c	a8 10		 test	 al, 16			; 00000010H
  0033e	74 2c		 je	 SHORT $LN120@gz_head

; 173  :             NEXT();

  00340	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
$LL6@gz_head:

; 187  :                 while (NEXT() > 0)

  00343	85 d2		 test	 edx, edx
  00345	75 13		 jne	 SHORT $LN124@gz_head
  00347	8b cb		 mov	 ecx, ebx
  00349	e8 00 00 00 00	 call	 _gz_avail
  0034e	83 f8 ff	 cmp	 eax, -1
  00351	74 16		 je	 SHORT $LN133@gz_head
  00353	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00356	85 d2		 test	 edx, edx
  00358	74 0f		 je	 SHORT $LN133@gz_head
$LN124@gz_head:
  0035a	8b 07		 mov	 eax, DWORD PTR [edi]
  0035c	4a		 dec	 edx
  0035d	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00360	8a 08		 mov	 cl, BYTE PTR [eax]
  00362	40		 inc	 eax
  00363	89 07		 mov	 DWORD PTR [edi], eax
  00365	84 c9		 test	 cl, cl
  00367	75 da		 jne	 SHORT $LL6@gz_head
$LN133@gz_head:
  00369	8b 45 fc	 mov	 eax, DWORD PTR _flags$1$[ebp]
$LN120@gz_head:

; 188  :                     ;
; 189  :             if (flags & 2) {        /* header crc */

  0036c	a8 02		 test	 al, 2
  0036e	74 3f		 je	 SHORT $LN88@gz_head

; 190  :                 NEXT();

  00370	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00373	85 c0		 test	 eax, eax
  00375	75 13		 jne	 SHORT $LN150@gz_head
  00377	8b cb		 mov	 ecx, ebx
  00379	e8 00 00 00 00	 call	 _gz_avail
  0037e	83 f8 ff	 cmp	 eax, -1
  00381	74 0d		 je	 SHORT $LN84@gz_head
  00383	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  00386	85 c0		 test	 eax, eax
  00388	74 06		 je	 SHORT $LN84@gz_head
$LN150@gz_head:
  0038a	48		 dec	 eax
  0038b	ff 07		 inc	 DWORD PTR [edi]
  0038d	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN84@gz_head:

; 191  :                 NEXT();

  00390	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00394	75 0c		 jne	 SHORT $LN86@gz_head
  00396	8b cb		 mov	 ecx, ebx
  00398	e8 00 00 00 00	 call	 _gz_avail
  0039d	83 f8 ff	 cmp	 eax, -1
  003a0	74 0d		 je	 SHORT $LN88@gz_head
$LN86@gz_head:
  003a2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003a5	85 c0		 test	 eax, eax
  003a7	74 06		 je	 SHORT $LN88@gz_head
  003a9	48		 dec	 eax
  003aa	ff 07		 inc	 DWORD PTR [edi]
  003ac	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN88@gz_head:

; 192  :             }
; 193  :             /* an unexpected end of file is not checked for here -- it will be
; 194  :                noticed on the first request for uncompressed data */
; 195  : 
; 196  :             /* set up for decompression */
; 197  :             inflateReset(strm);

  003af	57		 push	 edi
  003b0	e8 00 00 00 00	 call	 _inflateReset@4

; 198  :             strm->adler = crc32(0L, Z_NULL, 0);

  003b5	6a 00		 push	 0
  003b7	6a 00		 push	 0
  003b9	6a 00		 push	 0
  003bb	e8 00 00 00 00	 call	 _crc32@12
  003c0	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 222  :     return 0;
; 223  : }

  003c3	33 c0		 xor	 eax, eax
  003c5	5f		 pop	 edi
  003c6	5e		 pop	 esi
  003c7	c7 43 34 02 00
	00 00		 mov	 DWORD PTR [ebx+52], 2
  003ce	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0
  003d5	5b		 pop	 ebx
  003d6	8b e5		 mov	 esp, ebp
  003d8	5d		 pop	 ebp
  003d9	c3		 ret	 0
$LN112@gz_head:

; 162  :                 gz_error(state, Z_DATA_ERROR, "unknown compression method");

  003da	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
$LN151@gz_head:

; 222  :     return 0;
; 223  : }

  003df	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH
  003e4	8b cb		 mov	 ecx, ebx
  003e6	e8 00 00 00 00	 call	 _gz_error
  003eb	83 c4 04	 add	 esp, 4
  003ee	83 c8 ff	 or	 eax, -1
  003f1	5f		 pop	 edi
  003f2	5e		 pop	 esi
  003f3	5b		 pop	 ebx
  003f4	8b e5		 mov	 esp, ebp
  003f6	5d		 pop	 ebp
  003f7	c3		 ret	 0
$LN128@gz_head:

; 199  :             state->how = GZIP;
; 200  :             state->direct = 0;
; 201  :             return 0;
; 202  :         }
; 203  :         else {
; 204  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 205  :             state->out[0] = 31;

  003f8	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  003fb	c6 00 1f	 mov	 BYTE PTR [eax], 31	; 0000001fH

; 206  :             state->have = 1;

  003fe	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [ebx+36], 1
$LN129@gz_head:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 211  :        input to output -- this assumes that the output buffer is larger than
; 212  :        the input buffer, which also assures space for gzungetc() */
; 213  :     state->raw = state->pos;

  00405	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 214  :     state->next = state->out;

  00408	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  0040b	89 43 30	 mov	 DWORD PTR [ebx+48], eax
  0040e	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx

; 215  :     if (strm->avail_in) {

  00411	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00414	85 c0		 test	 eax, eax
  00416	74 1e		 je	 SHORT $LN28@gz_head

; 216  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

  00418	50		 push	 eax
  00419	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0041c	ff 37		 push	 DWORD PTR [edi]
  0041e	03 c1		 add	 eax, ecx
  00420	50		 push	 eax
  00421	e8 00 00 00 00	 call	 _memcpy

; 217  :         state->have += strm->avail_in;

  00426	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00429	83 c4 0c	 add	 esp, 12			; 0000000cH
  0042c	01 43 24	 add	 DWORD PTR [ebx+36], eax

; 218  :         strm->avail_in = 0;

  0042f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
$LN28@gz_head:

; 219  :     }
; 220  :     state->how = COPY;

  00436	c7 43 34 01 00
	00 00		 mov	 DWORD PTR [ebx+52], 1

; 221  :     state->direct = 1;

  0043d	c7 43 38 01 00
	00 00		 mov	 DWORD PTR [ebx+56], 1
$LN136@gz_head:

; 222  :     return 0;
; 223  : }

  00444	5f		 pop	 edi
  00445	5e		 pop	 esi
  00446	33 c0		 xor	 eax, eax
  00448	5b		 pop	 ebx
  00449	8b e5		 mov	 esp, ebp
  0044b	5d		 pop	 ebp
  0044c	c3		 ret	 0
_gz_head ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_decomp
_TEXT	SEGMENT
_len$ = -8						; size = 4
_had$1$ = -4						; size = 4
_crc$ = -4						; size = 4
_gz_decomp PROC						; COMDAT
; _state$ = ecx

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 236  :     int ret;
; 237  :     unsigned had;
; 238  :     unsigned long crc, len;
; 239  :     z_streamp strm = &(state->strm);
; 240  : 
; 241  :     /* fill output buffer up to end of deflate stream */
; 242  :     had = strm->avail_out;

  00009	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8d 7b 54	 lea	 edi, DWORD PTR [ebx+84]
  00011	89 45 fc	 mov	 DWORD PTR _had$1$[ebp], eax
$LL4@gz_decomp:

; 243  :     do {
; 244  :         /* get more input for inflate() */
; 245  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00014	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00018	75 1a		 jne	 SHORT $LN29@gz_decomp
  0001a	8b cb		 mov	 ecx, ebx
  0001c	e8 00 00 00 00	 call	 _gz_avail
  00021	83 f8 ff	 cmp	 eax, -1
  00024	0f 84 55 01 00
	00		 je	 $LN21@gz_decomp

; 246  :             return -1;
; 247  :         if (strm->avail_in == 0) {

  0002a	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0002e	0f 84 d4 00 00
	00		 je	 $LN14@gz_decomp
$LN29@gz_decomp:

; 248  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");
; 249  :             return -1;
; 250  :         }
; 251  : 
; 252  :         /* decompress and handle errors */
; 253  :         ret = inflate(strm, Z_NO_FLUSH);

  00034	6a 00		 push	 0
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _inflate@8
  0003c	8b f0		 mov	 esi, eax

; 254  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  0003e	83 fe fe	 cmp	 esi, -2			; fffffffeH
  00041	0f 84 24 01 00
	00		 je	 $LN8@gz_decomp
  00047	83 fe 02	 cmp	 esi, 2
  0004a	0f 84 1b 01 00
	00		 je	 $LN8@gz_decomp

; 256  :                       "internal error: inflate stream corrupt");
; 257  :             return -1;
; 258  :         }
; 259  :         if (ret == Z_MEM_ERROR) {

  00050	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00053	0f 84 f4 00 00
	00		 je	 $LN24@gz_decomp

; 261  :             return -1;
; 262  :         }
; 263  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  00059	83 fe fd	 cmp	 esi, -3			; fffffffdH
  0005c	0f 84 c4 00 00
	00		 je	 $LN25@gz_decomp

; 265  :                       strm->msg == NULL ? "compressed data error" : strm->msg);
; 266  :             return -1;
; 267  :         }
; 268  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00062	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00065	85 c0		 test	 eax, eax
  00067	74 05		 je	 SHORT $LN11@gz_decomp
  00069	83 fe 01	 cmp	 esi, 1
  0006c	75 a6		 jne	 SHORT $LL4@gz_decomp
$LN11@gz_decomp:

; 269  : 
; 270  :     /* update available output and crc check value */
; 271  :     state->have = had - strm->avail_out;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _had$1$[ebp]
  00071	2b c8		 sub	 ecx, eax
  00073	89 4b 24	 mov	 DWORD PTR [ebx+36], ecx

; 272  :     state->next = strm->next_out - state->have;

  00076	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00079	2b c1		 sub	 eax, ecx

; 273  :     strm->adler = crc32(strm->adler, state->next, state->have);

  0007b	51		 push	 ecx
  0007c	50		 push	 eax
  0007d	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00080	ff 77 30	 push	 DWORD PTR [edi+48]
  00083	e8 00 00 00 00	 call	 _crc32@12
  00088	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 274  : 
; 275  :     /* check gzip trailer if at end of deflate stream */
; 276  :     if (ret == Z_STREAM_END) {

  0008b	83 fe 01	 cmp	 esi, 1
  0008e	75 6f		 jne	 SHORT $LN12@gz_decomp

; 277  :         if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

  00090	8d 55 fc	 lea	 edx, DWORD PTR _crc$[ebp]
  00093	8b cb		 mov	 ecx, ebx
  00095	e8 00 00 00 00	 call	 _gz_next4
  0009a	83 f8 ff	 cmp	 eax, -1
  0009d	74 69		 je	 SHORT $LN14@gz_decomp
  0009f	8d 55 f8	 lea	 edx, DWORD PTR _len$[ebp]
  000a2	8b cb		 mov	 ecx, ebx
  000a4	e8 00 00 00 00	 call	 _gz_next4
  000a9	83 f8 ff	 cmp	 eax, -1
  000ac	74 5a		 je	 SHORT $LN14@gz_decomp

; 279  :             return -1;
; 280  :         }
; 281  :         if (crc != strm->adler) {

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _crc$[ebp]
  000b1	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
  000b4	74 1c		 je	 SHORT $LN15@gz_decomp

; 282  :             gz_error(state, Z_DATA_ERROR, "incorrect data check");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  000bb	8d 56 fc	 lea	 edx, DWORD PTR [esi-4]

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  000be	8b cb		 mov	 ecx, ebx
  000c0	e8 00 00 00 00	 call	 _gz_error
  000c5	83 c4 04	 add	 esp, 4
  000c8	83 c8 ff	 or	 eax, -1
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
$LN15@gz_decomp:

; 283  :             return -1;
; 284  :         }
; 285  :         if (len != (strm->total_out & 0xffffffffL)) {

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000d5	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  000d8	74 1e		 je	 SHORT $LN16@gz_decomp

; 286  :             gz_error(state, Z_DATA_ERROR, "incorrect length check");

  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  000df	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  000e4	8b cb		 mov	 ecx, ebx
  000e6	e8 00 00 00 00	 call	 _gz_error
  000eb	83 c4 04	 add	 esp, 4
  000ee	83 c8 ff	 or	 eax, -1
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
$LN16@gz_decomp:

; 287  :             return -1;
; 288  :         }
; 289  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

  000f8	c7 43 34 00 00
	00 00		 mov	 DWORD PTR [ebx+52], 0
$LN12@gz_decomp:
  000ff	5f		 pop	 edi

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  00100	5e		 pop	 esi
  00101	33 c0		 xor	 eax, eax
  00103	5b		 pop	 ebx
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN14@gz_decomp:

; 278  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
  0010d	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  00112	8b cb		 mov	 ecx, ebx
  00114	e8 00 00 00 00	 call	 _gz_error
  00119	83 c4 04	 add	 esp, 4
  0011c	83 c8 ff	 or	 eax, -1
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
$LN25@gz_decomp:

; 264  :             gz_error(state, Z_DATA_ERROR,

  00126	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
  0012e	85 c0		 test	 eax, eax
  00130	ba fd ff ff ff	 mov	 edx, -3			; fffffffdH
  00135	0f 45 c8	 cmovne	 ecx, eax
  00138	51		 push	 ecx

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  00139	8b cb		 mov	 ecx, ebx
  0013b	e8 00 00 00 00	 call	 _gz_error
  00140	83 c4 04	 add	 esp, 4
  00143	83 c8 ff	 or	 eax, -1
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
$LN24@gz_decomp:

; 260  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  00152	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  00157	8b cb		 mov	 ecx, ebx
  00159	e8 00 00 00 00	 call	 _gz_error
  0015e	83 c4 04	 add	 esp, 4
  00161	83 c8 ff	 or	 eax, -1
  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	5b		 pop	 ebx
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN8@gz_decomp:

; 255  :             gz_error(state, Z_STREAM_ERROR,

  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
  00170	ba fe ff ff ff	 mov	 edx, -2			; fffffffeH

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;
; 295  : }

  00175	8b cb		 mov	 ecx, ebx
  00177	e8 00 00 00 00	 call	 _gz_error
  0017c	83 c4 04	 add	 esp, 4
$LN21@gz_decomp:
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	83 c8 ff	 or	 eax, -1
  00184	5b		 pop	 ebx
  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
_gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_make
_TEXT	SEGMENT
_gz_make PROC						; COMDAT
; _state$ = ecx

; 306  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 307  :     z_streamp strm = &(state->strm);
; 308  : 
; 309  :     if (state->how == LOOK) {           /* look for gzip header */

  00003	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00006	85 c0		 test	 eax, eax
  00008	75 18		 jne	 SHORT $LN12@gz_make

; 310  :         if (gz_head(state) == -1)

  0000a	e8 00 00 00 00	 call	 _gz_head
  0000f	83 f8 ff	 cmp	 eax, -1
  00012	74 58		 je	 SHORT $LN13@gz_make

; 311  :             return -1;
; 312  :         if (state->have)                /* got some data from gz_head() */

  00014	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00018	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  0001b	75 2c		 jne	 SHORT $LN9@gz_make
  0001d	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00020	eb 03		 jmp	 SHORT $LN4@gz_make
$LN12@gz_make:
  00022	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
$LN4@gz_make:

; 313  :             return 0;
; 314  :     }
; 315  :     if (state->how == COPY) {           /* straight copy */

  00025	83 f8 01	 cmp	 eax, 1
  00028	75 23		 jne	 SHORT $LN5@gz_make

; 316  :         if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)

  0002a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0002d	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00030	03 c0		 add	 eax, eax
  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 _gz_load
  0003b	83 c4 08	 add	 esp, 8
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	74 29		 je	 SHORT $LN13@gz_make

; 317  :             return -1;
; 318  :         state->next = state->out;

  00043	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00046	89 46 20	 mov	 DWORD PTR [esi+32], eax
$LN9@gz_make:

; 325  :     }
; 326  :     return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	5e		 pop	 esi

; 327  : }

  0004c	c3		 ret	 0
$LN5@gz_make:

; 319  :     }
; 320  :     else if (state->how == GZIP) {      /* decompress */

  0004d	83 f8 02	 cmp	 eax, 2
  00050	75 f7		 jne	 SHORT $LN9@gz_make

; 321  :         strm->avail_out = state->size << 1;

  00052	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 322  :         strm->next_out = state->out;
; 323  :         if (gz_decomp(state) == -1)

  00055	8b ce		 mov	 ecx, esi
  00057	03 c0		 add	 eax, eax
  00059	89 46 64	 mov	 DWORD PTR [esi+100], eax
  0005c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0005f	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00062	e8 00 00 00 00	 call	 _gz_decomp
  00067	83 f8 ff	 cmp	 eax, -1
  0006a	75 dd		 jne	 SHORT $LN9@gz_make
$LN13@gz_make:

; 324  :             return -1;

  0006c	83 c8 ff	 or	 eax, -1
  0006f	5e		 pop	 esi

; 327  : }

  00070	c3		 ret	 0
_gz_make ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gz_skip
_TEXT	SEGMENT
_gz_skip PROC						; COMDAT
; _state$ = ecx
; _len$ = edx

; 333  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b fa		 mov	 edi, edx
  00004	8b f1		 mov	 esi, ecx

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  00006	85 ff		 test	 edi, edi
  00008	74 47		 je	 SHORT $LN3@gz_skip
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@gz_skip:

; 338  :         /* skip over whatever is in output buffer */
; 339  :         if (state->have) {

  00010	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00013	85 c0		 test	 eax, eax
  00015	74 1e		 je	 SHORT $LN4@gz_skip

; 340  :             n = GT_OFF(state->have) || (z_off64_t)state->have > len ?

  00017	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0001c	77 06		 ja	 SHORT $LN11@gz_skip
  0001e	8b c8		 mov	 ecx, eax
  00020	3b c7		 cmp	 eax, edi
  00022	7e 02		 jle	 SHORT $LN12@gz_skip
$LN11@gz_skip:
  00024	8b cf		 mov	 ecx, edi
$LN12@gz_skip:

; 341  :                 (unsigned)len : state->have;
; 342  :             state->have -= n;
; 343  :             state->next += n;

  00026	01 4e 20	 add	 DWORD PTR [esi+32], ecx
  00029	2b c1		 sub	 eax, ecx

; 344  :             state->pos += n;

  0002b	01 4e 0c	 add	 DWORD PTR [esi+12], ecx

; 345  :             len -= n;

  0002e	2b f9		 sub	 edi, ecx
  00030	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 346  :         }

  00033	eb 18		 jmp	 SHORT $LN8@gz_skip
$LN4@gz_skip:

; 347  : 
; 348  :         /* output buffer empty -- return if we're at the end of the input */
; 349  :         else if (state->eof && state->strm.avail_in == 0)

  00035	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00039	74 06		 je	 SHORT $LN6@gz_skip
  0003b	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0003f	74 10		 je	 SHORT $LN3@gz_skip
$LN6@gz_skip:

; 350  :             break;
; 351  : 
; 352  :         /* need more data to skip -- load up output buffer */
; 353  :         else {
; 354  :             /* get more output, looking for header if required */
; 355  :             if (gz_make(state) == -1)

  00041	8b ce		 mov	 ecx, esi
  00043	e8 00 00 00 00	 call	 _gz_make
  00048	83 f8 ff	 cmp	 eax, -1
  0004b	74 09		 je	 SHORT $LN15@gz_skip
$LN8@gz_skip:

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  0004d	85 ff		 test	 edi, edi
  0004f	75 bf		 jne	 SHORT $LL2@gz_skip
$LN3@gz_skip:
  00051	5f		 pop	 edi

; 357  :         }
; 358  :     return 0;

  00052	33 c0		 xor	 eax, eax

; 359  : }

  00054	5e		 pop	 esi
  00055	c3		 ret	 0
$LN15@gz_skip:
  00056	5f		 pop	 edi

; 356  :                 return -1;

  00057	83 c8 ff	 or	 eax, -1

; 359  : }

  0005a	5e		 pop	 esi
  0005b	c3		 ret	 0
_gz_skip ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gzread@12
_TEXT	SEGMENT
_n$ = 8							; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_got$1$ = 16						; size = 4
_len$ = 16						; size = 4
_gzread@12 PROC						; COMDAT

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 367  :     unsigned got, n;
; 368  :     gz_statep state;
; 369  :     z_streamp strm;
; 370  : 
; 371  :     /* get internal structure */
; 372  :     if (file == NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00008	57		 push	 edi
  00009	85 f6		 test	 esi, esi
  0000b	74 29		 je	 SHORT $LN7@gzread

; 373  :         return -1;
; 374  :     state = (gz_statep)file;
; 375  :     strm = &(state->strm);
; 376  : 
; 377  :     /* check that we're reading and that there's no error */
; 378  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0000d	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  00013	75 21		 jne	 SHORT $LN7@gzread
  00015	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00019	75 1b		 jne	 SHORT $LN7@gzread

; 379  :         return -1;
; 380  : 
; 381  :     /* since an int is returned, make sure len fits in one, otherwise return
; 382  :        with an error (this avoids the flaw in the interface) */
; 383  :     if ((int)len < 0) {

  0001b	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  0001e	85 db		 test	 ebx, ebx
  00020	79 1e		 jns	 SHORT $LN34@gzread

; 384  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
  00027	ba fb ff ff ff	 mov	 edx, -5			; fffffffbH
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 _gz_error
  00033	83 c4 04	 add	 esp, 4
$LN7@gzread:

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	83 c8 ff	 or	 eax, -1
  0003b	5b		 pop	 ebx
  0003c	5d		 pop	 ebp
  0003d	c2 0c 00	 ret	 12			; 0000000cH
$LN34@gzread:

; 385  :         return -1;
; 386  :     }
; 387  : 
; 388  :     /* if len is zero, avoid unnecessary operations */
; 389  :     if (len == 0)

  00040	75 09		 jne	 SHORT $LN9@gzread

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	33 c0		 xor	 eax, eax
  00046	5b		 pop	 ebx
  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN9@gzread:

; 390  :         return 0;
; 391  : 
; 392  :     /* process a skip request */
; 393  :     if (state->seek) {

  0004b	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0004f	74 16		 je	 SHORT $LN11@gzread

; 394  :         state->seek = 0;
; 395  :         if (gz_skip(state, state->skip) == -1)

  00051	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00054	8b ce		 mov	 ecx, esi
  00056	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0005d	e8 00 00 00 00	 call	 _gz_skip
  00062	83 f8 ff	 cmp	 eax, -1
  00065	74 cf		 je	 SHORT $LN7@gzread
$LN11@gzread:

; 396  :             return -1;
; 397  :     }
; 398  : 
; 399  :     /* get len bytes to buf, or less than len if at the end */
; 400  :     got = 0;

  00067	33 c9		 xor	 ecx, ecx
  00069	89 4d 10	 mov	 DWORD PTR _got$1$[ebp], ecx
  0006c	0f 1f 40 00	 npad	 4
$LL4@gzread:

; 401  :     do {
; 402  :         /* first just try copying data from the output buffer */
; 403  :         if (state->have) {

  00070	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00073	85 c0		 test	 eax, eax
  00075	74 22		 je	 SHORT $LN12@gzread

; 404  :             n = state->have > len ? len : state->have;
; 405  :             memcpy(buf, state->next, n);

  00077	3b c3		 cmp	 eax, ebx
  00079	8b fb		 mov	 edi, ebx
  0007b	0f 46 f8	 cmovbe	 edi, eax
  0007e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00081	57		 push	 edi
  00082	ff 76 20	 push	 DWORD PTR [esi+32]
  00085	89 7d 08	 mov	 DWORD PTR _n$[ebp], edi
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _memcpy

; 406  :             state->next += n;

  0008e	01 7e 20	 add	 DWORD PTR [esi+32], edi
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 407  :             state->have -= n;

  00094	29 7e 24	 sub	 DWORD PTR [esi+36], edi

; 408  :         }

  00097	eb 69		 jmp	 SHORT $LN21@gzread
$LN12@gzread:

; 409  : 
; 410  :         /* output buffer empty -- return if we're at the end of the input */
; 411  :         else if (state->eof && strm->avail_in == 0)

  00099	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0009d	74 0a		 je	 SHORT $LN14@gzread
  0009f	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000a3	0f 84 86 00 00
	00		 je	 $LN3@gzread
$LN14@gzread:

; 412  :             break;
; 413  : 
; 414  :         /* need output data -- for small len or new stream load up our output
; 415  :            buffer */
; 416  :         else if (state->how == LOOK || len < (state->size << 1)) {

  000a9	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  000ac	85 c9		 test	 ecx, ecx
  000ae	74 64		 je	 SHORT $LN18@gzread
  000b0	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000b3	03 c0		 add	 eax, eax
  000b5	3b d8		 cmp	 ebx, eax
  000b7	72 5b		 jb	 SHORT $LN18@gzread

; 419  :                 return -1;
; 420  :             continue;       /* no progress yet -- go back to memcpy() above */
; 421  :             /* the copy above assures that we will leave with space in the
; 422  :                output buffer, allowing at least one gzungetc() to succeed */
; 423  :         }
; 424  : 
; 425  :         /* large len -- read directly into user buffer */
; 426  :         else if (state->how == COPY) {      /* read directly */

  000b9	83 f9 01	 cmp	 ecx, 1
  000bc	8b ce		 mov	 ecx, esi
  000be	75 1e		 jne	 SHORT $LN20@gzread

; 427  :             if (gz_load(state, buf, len, &n) == -1)

  000c0	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  000c3	8d 45 08	 lea	 eax, DWORD PTR _n$[ebp]
  000c6	50		 push	 eax
  000c7	53		 push	 ebx
  000c8	e8 00 00 00 00	 call	 _gz_load
  000cd	83 c4 08	 add	 esp, 8
  000d0	83 f8 ff	 cmp	 eax, -1
  000d3	0f 84 5d ff ff
	ff		 je	 $LN7@gzread

; 428  :                 return -1;
; 429  :         }

  000d9	8b 7d 08	 mov	 edi, DWORD PTR _n$[ebp]
  000dc	eb 24		 jmp	 SHORT $LN21@gzread
$LN20@gzread:

; 430  : 
; 431  :         /* large len -- decompress directly into user buffer */
; 432  :         else {  /* state->how == GZIP */
; 433  :             strm->avail_out = len;
; 434  :             strm->next_out = buf;

  000de	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000e1	89 5e 64	 mov	 DWORD PTR [esi+100], ebx
  000e4	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 435  :             if (gz_decomp(state) == -1)

  000e7	e8 00 00 00 00	 call	 _gz_decomp
  000ec	83 f8 ff	 cmp	 eax, -1
  000ef	0f 84 41 ff ff
	ff		 je	 $LN7@gzread

; 436  :                 return -1;
; 437  :             n = state->have;

  000f5	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  000f8	89 7d 08	 mov	 DWORD PTR _n$[ebp], edi

; 438  :             state->have = 0;

  000fb	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
$LN21@gzread:

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;
; 443  :         buf = (char *)buf + n;
; 444  :         got += n;

  00102	8b 4d 10	 mov	 ecx, DWORD PTR _got$1$[ebp]
  00105	2b df		 sub	 ebx, edi
  00107	01 7d 0c	 add	 DWORD PTR _buf$[ebp], edi
  0010a	03 cf		 add	 ecx, edi

; 445  :         state->pos += n;

  0010c	01 7e 0c	 add	 DWORD PTR [esi+12], edi
  0010f	89 4d 10	 mov	 DWORD PTR _got$1$[ebp], ecx
  00112	eb 13		 jmp	 SHORT $LN2@gzread
$LN18@gzread:

; 417  :             /* get more output, looking for header if required */
; 418  :             if (gz_make(state) == -1)

  00114	8b ce		 mov	 ecx, esi
  00116	e8 00 00 00 00	 call	 _gz_make
  0011b	83 f8 ff	 cmp	 eax, -1
  0011e	0f 84 12 ff ff
	ff		 je	 $LN7@gzread
  00124	8b 4d 10	 mov	 ecx, DWORD PTR _got$1$[ebp]
$LN2@gzread:

; 446  :     } while (len);

  00127	85 db		 test	 ebx, ebx
  00129	0f 85 41 ff ff
	ff		 jne	 $LL4@gzread
$LN3@gzread:
  0012f	5f		 pop	 edi

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;
; 450  : }

  00130	5e		 pop	 esi
  00131	8b c1		 mov	 eax, ecx
  00133	5b		 pop	 ebx
  00134	5d		 pop	 ebp
  00135	c2 0c 00	 ret	 12			; 0000000cH
_gzread@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gzgetc@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_gzgetc@4 PROC						; COMDAT

; 455  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 456  :     int ret;
; 457  :     unsigned char buf[1];
; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure */
; 461  :     if (file == NULL)

  00003	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 45		 je	 SHORT $LN4@gzgetc

; 462  :         return -1;
; 463  :     state = (gz_statep)file;
; 464  : 
; 465  :     /* check that we're reading and that there's no error */
; 466  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0000a	81 3a 4f 1c 00
	00		 cmp	 DWORD PTR [edx], 7247	; 00001c4fH
  00010	75 3d		 jne	 SHORT $LN4@gzgetc
  00012	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00016	75 37		 jne	 SHORT $LN4@gzgetc

; 467  :         return -1;
; 468  : 
; 469  :     /* try output buffer (no need to check for skip request) */
; 470  :     if (state->have) {

  00018	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0001b	85 c0		 test	 eax, eax
  0001d	74 17		 je	 SHORT $LN5@gzgetc

; 471  :         state->have--;
; 472  :         state->pos++;

  0001f	ff 42 0c	 inc	 DWORD PTR [edx+12]
  00022	48		 dec	 eax
  00023	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 473  :         return *(state->next)++;

  00026	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00029	8a 08		 mov	 cl, BYTE PTR [eax]
  0002b	40		 inc	 eax
  0002c	89 42 20	 mov	 DWORD PTR [edx+32], eax
  0002f	0f b6 c1	 movzx	 eax, cl

; 479  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN5@gzgetc:

; 474  :     }
; 475  : 
; 476  :     /* nothing there -- try gzread() */
; 477  :     ret = gzread(file, buf, 1);

  00036	6a 01		 push	 1
  00038	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  0003b	50		 push	 eax
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _gzread@12

; 478  :     return ret < 1 ? -1 : buf[0];

  00042	83 f8 01	 cmp	 eax, 1
  00045	7c 08		 jl	 SHORT $LN4@gzgetc
  00047	0f b6 45 0b	 movzx	 eax, BYTE PTR _buf$[ebp]

; 479  : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
$LN4@gzgetc:
  0004f	83 c8 ff	 or	 eax, -1
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
_gzgetc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gzungetc@8
_TEXT	SEGMENT
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc@8 PROC					; COMDAT

; 485  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure */
; 489  :     if (file == NULL)

  00005	8b 75 0c	 mov	 esi, DWORD PTR _file$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 d9 00 00
	00		 je	 $LN6@gzungetc

; 490  :         return -1;
; 491  :     state = (gz_statep)file;
; 492  : 
; 493  :     /* check that we're reading and that there's no error */
; 494  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00010	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  00016	0f 85 cd 00 00
	00		 jne	 $LN6@gzungetc
  0001c	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00020	0f 85 c3 00 00
	00		 jne	 $LN6@gzungetc

; 496  : 
; 497  :     /* process a skip request */
; 498  :     if (state->seek) {

  00026	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0002a	74 1a		 je	 SHORT $LN8@gzungetc

; 499  :         state->seek = 0;
; 500  :         if (gz_skip(state, state->skip) == -1)

  0002c	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0002f	8b ce		 mov	 ecx, esi
  00031	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00038	e8 00 00 00 00	 call	 _gz_skip
  0003d	83 f8 ff	 cmp	 eax, -1
  00040	0f 84 a3 00 00
	00		 je	 $LN6@gzungetc
$LN8@gzungetc:

; 501  :             return -1;
; 502  :     }
; 503  : 
; 504  :     /* can't push EOF */
; 505  :     if (c < 0)

  00046	8b 5d 08	 mov	 ebx, DWORD PTR _c$[ebp]
  00049	85 db		 test	 ebx, ebx
  0004b	0f 88 98 00 00
	00		 js	 $LN6@gzungetc

; 506  :         return -1;
; 507  : 
; 508  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 509  :     if (state->have == 0) {

  00051	57		 push	 edi
  00052	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  00055	85 ff		 test	 edi, edi
  00057	75 22		 jne	 SHORT $LN10@gzungetc

; 510  :         state->have = 1;
; 511  :         state->next = state->out + (state->size << 1) - 1;

  00059	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 512  :         state->next[0] = c;
; 513  :         state->pos--;
; 514  :         return c;

  0005c	8b c3		 mov	 eax, ebx
  0005e	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00061	c7 46 24 01 00
	00 00		 mov	 DWORD PTR [esi+36], 1
  00068	5f		 pop	 edi
  00069	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0006c	49		 dec	 ecx
  0006d	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00070	88 19		 mov	 BYTE PTR [ecx], bl
  00072	ff 4e 0c	 dec	 DWORD PTR [esi+12]
  00075	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  00076	5b		 pop	 ebx
  00077	5d		 pop	 ebp
  00078	c2 08 00	 ret	 8
$LN10@gzungetc:

; 515  :     }
; 516  : 
; 517  :     /* if no room, give up (must have already done a gzungetc()) */
; 518  :     if (state->have == (state->size << 1)) {

  0007b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007e	03 c0		 add	 eax, eax
  00080	3b f8		 cmp	 edi, eax
  00082	75 1e		 jne	 SHORT $LN11@gzungetc

; 519  :         gz_error(state, Z_BUF_ERROR, "out of room to push characters");

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
  00089	ba fb ff ff ff	 mov	 edx, -5			; fffffffbH
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 _gz_error
  00095	83 c4 04	 add	 esp, 4

; 520  :         return -1;

  00098	83 c8 ff	 or	 eax, -1
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  0009d	5b		 pop	 ebx
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
$LN11@gzungetc:

; 521  :     }
; 522  : 
; 523  :     /* slide output data if needed and insert byte before existing data */
; 524  :     if (state->next == state->out) {

  000a2	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  000a5	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000a8	3b d0		 cmp	 edx, eax
  000aa	75 23		 jne	 SHORT $LN3@gzungetc

; 525  :         unsigned char *src = state->out + state->have;
; 526  :         unsigned char *dest = state->out + (state->size << 1);

  000ac	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  000af	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000b2	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]

; 527  :         while (src > state->out)

  000b5	3b c8		 cmp	 ecx, eax
  000b7	76 16		 jbe	 SHORT $LN3@gzungetc
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@gzungetc:

; 528  :             *--dest = *--src;

  000c0	8a 41 ff	 mov	 al, BYTE PTR [ecx-1]
  000c3	49		 dec	 ecx
  000c4	4a		 dec	 edx
  000c5	88 02		 mov	 BYTE PTR [edx], al
  000c7	3b 4e 1c	 cmp	 ecx, DWORD PTR [esi+28]
  000ca	77 f4		 ja	 SHORT $LL2@gzungetc
  000cc	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
$LN3@gzungetc:

; 529  :         state->next = dest;
; 530  :     }
; 531  :     state->have++;

  000cf	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000d2	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 532  :     state->next--;

  000d5	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000d8	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 533  :     state->next[0] = c;

  000db	88 18		 mov	 BYTE PTR [eax], bl
  000dd	8b c3		 mov	 eax, ebx
  000df	ff 4e 0c	 dec	 DWORD PTR [esi+12]
  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  000e4	5b		 pop	 ebx
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
$LN6@gzungetc:
  000e9	5e		 pop	 esi

; 495  :         return -1;

  000ea	83 c8 ff	 or	 eax, -1

; 534  :     state->pos--;
; 535  :     return c;
; 536  : }

  000ed	5b		 pop	 ebx
  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
_gzungetc@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gzgets@12
_TEXT	SEGMENT
_left$1$ = 8						; size = 4
_file$ = 8						; size = 4
_str$1$ = 12						; size = 4
_buf$ = 12						; size = 4
_eol$1$ = 16						; size = 4
_len$ = 16						; size = 4
_gzgets@12 PROC						; COMDAT

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 544  :     unsigned left, n;
; 545  :     char *str;
; 546  :     unsigned char *eol;
; 547  :     gz_statep state;
; 548  : 
; 549  :     /* check parameters and get internal structure */
; 550  :     if (file == NULL || buf == NULL || len < 1)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	0f 84 e3 00 00
	00		 je	 $LN6@gzgets
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _buf$[ebp]
  00014	85 db		 test	 ebx, ebx
  00016	0f 84 d8 00 00
	00		 je	 $LN6@gzgets
  0001c	8b 75 10	 mov	 esi, DWORD PTR _len$[ebp]
  0001f	83 fe 01	 cmp	 esi, 1
  00022	0f 8c cc 00 00
	00		 jl	 $LN6@gzgets

; 551  :         return NULL;
; 552  :     state = (gz_statep)file;
; 553  : 
; 554  :     /* check that we're reading and that there's no error */
; 555  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00028	81 3f 4f 1c 00
	00		 cmp	 DWORD PTR [edi], 7247	; 00001c4fH
  0002e	0f 85 c0 00 00
	00		 jne	 $LN6@gzgets
  00034	83 7f 4c 00	 cmp	 DWORD PTR [edi+76], 0
  00038	0f 85 b6 00 00
	00		 jne	 $LN6@gzgets

; 556  :         return NULL;
; 557  : 
; 558  :     /* process a skip request */
; 559  :     if (state->seek) {

  0003e	83 7f 48 00	 cmp	 DWORD PTR [edi+72], 0
  00042	74 1a		 je	 SHORT $LN10@gzgets

; 560  :         state->seek = 0;
; 561  :         if (gz_skip(state, state->skip) == -1)

  00044	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00047	8b cf		 mov	 ecx, edi
  00049	c7 47 48 00 00
	00 00		 mov	 DWORD PTR [edi+72], 0
  00050	e8 00 00 00 00	 call	 _gz_skip
  00055	83 f8 ff	 cmp	 eax, -1
  00058	0f 84 96 00 00
	00		 je	 $LN6@gzgets
$LN10@gzgets:

; 562  :             return NULL;
; 563  :     }
; 564  : 
; 565  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 566  :        append a terminating zero to the string (we don't check for a zero in
; 567  :        the contents, let the user worry about that) */
; 568  :     str = buf;
; 569  :     left = (unsigned)len - 1;

  0005e	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  00061	8b c3		 mov	 eax, ebx
  00063	89 45 0c	 mov	 DWORD PTR _str$1$[ebp], eax
  00066	89 4d 08	 mov	 DWORD PTR _left$1$[ebp], ecx

; 570  :     if (left) do {

  00069	85 c9		 test	 ecx, ecx
  0006b	74 76		 je	 SHORT $LN3@gzgets
  0006d	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
$LL4@gzgets:

; 571  :         /* assure that something is in the output buffer */
; 572  :         if (state->have == 0) {

  00070	85 c0		 test	 eax, eax
  00072	75 16		 jne	 SHORT $LN14@gzgets

; 573  :             if (gz_make(state) == -1)

  00074	8b cf		 mov	 ecx, edi
  00076	e8 00 00 00 00	 call	 _gz_make
  0007b	83 f8 ff	 cmp	 eax, -1
  0007e	74 74		 je	 SHORT $LN6@gzgets

; 574  :                 return NULL;            /* error */
; 575  :             if (state->have == 0) {     /* end of file */

  00080	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00083	85 c0		 test	 eax, eax
  00085	74 66		 je	 SHORT $LN23@gzgets
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _left$1$[ebp]
$LN14@gzgets:

; 577  :                     return NULL;
; 578  :                 break;                  /* got something -- return it */
; 579  :             }
; 580  :         }
; 581  : 
; 582  :         /* look for end-of-line in current output buffer */
; 583  :         n = state->have > left ? left : state->have;
; 584  :         eol = memchr(state->next, '\n', n);

  0008a	3b c1		 cmp	 eax, ecx
  0008c	8b f1		 mov	 esi, ecx
  0008e	0f 46 f0	 cmovbe	 esi, eax
  00091	56		 push	 esi
  00092	6a 0a		 push	 10			; 0000000aH
  00094	ff 77 20	 push	 DWORD PTR [edi+32]
  00097	e8 00 00 00 00	 call	 _memchr
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	89 45 10	 mov	 DWORD PTR _eol$1$[ebp], eax

; 585  :         if (eol != NULL)

  000a2	85 c0		 test	 eax, eax
  000a4	74 0a		 je	 SHORT $LN26@gzgets

; 586  :             n = (unsigned)(eol - state->next) + 1;

  000a6	8b f0		 mov	 esi, eax
  000a8	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000ab	2b f0		 sub	 esi, eax
  000ad	46		 inc	 esi
  000ae	eb 03		 jmp	 SHORT $LN16@gzgets
$LN26@gzgets:

; 585  :         if (eol != NULL)

  000b0	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
$LN16@gzgets:

; 587  : 
; 588  :         /* copy through end-of-line, or remainder if not found */
; 589  :         memcpy(buf, state->next, n);

  000b3	56		 push	 esi
  000b4	50		 push	 eax
  000b5	53		 push	 ebx
  000b6	e8 00 00 00 00	 call	 _memcpy

; 590  :         state->have -= n;
; 591  :         state->next += n;
; 592  :         state->pos += n;
; 593  :         left -= n;

  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _left$1$[ebp]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000c4	2b ce		 sub	 ecx, esi
  000c6	01 77 20	 add	 DWORD PTR [edi+32], esi
  000c9	2b c6		 sub	 eax, esi
  000cb	01 77 0c	 add	 DWORD PTR [edi+12], esi

; 594  :         buf += n;

  000ce	03 de		 add	 ebx, esi
  000d0	89 47 24	 mov	 DWORD PTR [edi+36], eax
  000d3	89 4d 08	 mov	 DWORD PTR _left$1$[ebp], ecx

; 595  :     } while (left && eol == NULL);

  000d6	85 c9		 test	 ecx, ecx
  000d8	74 06		 je	 SHORT $LN28@gzgets
  000da	83 7d 10 00	 cmp	 DWORD PTR _eol$1$[ebp], 0
  000de	74 90		 je	 SHORT $LL4@gzgets
$LN28@gzgets:

; 596  : 
; 597  :     /* found end-of-line or out of space -- terminate string and return it */
; 598  :     buf[0] = 0;

  000e0	8b 45 0c	 mov	 eax, DWORD PTR _str$1$[ebp]
$LN3@gzgets:
  000e3	5f		 pop	 edi

; 599  :     return str;
; 600  : }

  000e4	5e		 pop	 esi
  000e5	c6 03 00	 mov	 BYTE PTR [ebx], 0
  000e8	5b		 pop	 ebx
  000e9	5d		 pop	 ebp
  000ea	c2 0c 00	 ret	 12			; 0000000cH
$LN23@gzgets:

; 576  :                 if (buf == str)         /* got bupkus */

  000ed	8b 45 0c	 mov	 eax, DWORD PTR _str$1$[ebp]
  000f0	3b d8		 cmp	 ebx, eax
  000f2	75 ef		 jne	 SHORT $LN3@gzgets
$LN6@gzgets:
  000f4	5f		 pop	 edi

; 599  :     return str;
; 600  : }

  000f5	5e		 pop	 esi
  000f6	33 c0		 xor	 eax, eax
  000f8	5b		 pop	 ebx
  000f9	5d		 pop	 ebp
  000fa	c2 0c 00	 ret	 12			; 0000000cH
_gzgets@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzread.c
;	COMDAT _gzdirect@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzdirect@4 PROC					; COMDAT

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 606  :     gz_statep state;
; 607  : 
; 608  :     /* get internal structure */
; 609  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 23		 je	 SHORT $LN6@gzdirect

; 610  :         return 0;
; 611  :     state = (gz_statep)file;
; 612  : 
; 613  :     /* check that we're reading */
; 614  :     if (state->mode != GZ_READ)

  0000b	81 3e 4f 1c 00
	00		 cmp	 DWORD PTR [esi], 7247	; 00001c4fH
  00011	75 1b		 jne	 SHORT $LN6@gzdirect

; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->how == LOOK && state->have == 0)

  00013	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  00017	75 0d		 jne	 SHORT $LN4@gzdirect
  00019	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  0001d	75 07		 jne	 SHORT $LN4@gzdirect

; 620  :         (void)gz_head(state);

  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 _gz_head
$LN4@gzdirect:

; 621  : 
; 622  :     /* return 1 if reading direct, 0 if decompressing a gzip stream */
; 623  :     return state->direct;

  00026	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00029	5e		 pop	 esi

; 624  : }

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN6@gzdirect:

; 615  :         return 0;

  0002e	33 c0		 xor	 eax, eax
  00030	5e		 pop	 esi

; 624  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
_gzdirect@4 ENDP
_TEXT	ENDS
END
