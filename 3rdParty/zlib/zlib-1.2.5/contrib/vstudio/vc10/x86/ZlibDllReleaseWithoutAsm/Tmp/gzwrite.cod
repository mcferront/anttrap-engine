; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ ; `string'
EXTRN	__imp__write:PROC
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ DB 'internal err'
	DB	'or: deflate stream corrupt', 00H		; `string'
PUBLIC	_gzsetparams@12
PUBLIC	_gzflush@8
PUBLIC	_gzprintf
PUBLIC	_gzputs@8
PUBLIC	_gzputc@8
PUBLIC	_gzwrite@12
PUBLIC	__vsnprintf
PUBLIC	_gzclose_w@4
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 503  :     int ret = 0;
; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure */
; 507  :     if (file == NULL)

  00005	8b 7d 08	 mov	 edi, DWORD PTR _file$[ebp]
  00008	33 db		 xor	 ebx, ebx
  0000a	85 ff		 test	 edi, edi
  0000c	74 72		 je	 SHORT $LN6@gzclose_w

; 508  :         return Z_STREAM_ERROR;
; 509  :     state = (gz_statep)file;
; 510  : 
; 511  :     /* check that we're writing */
; 512  :     if (state->mode != GZ_WRITE)

  0000e	81 3f b1 79 00
	00		 cmp	 DWORD PTR [edi], 31153	; 000079b1H
  00014	75 6a		 jne	 SHORT $LN6@gzclose_w

; 514  : 
; 515  :     /* check for seek request */
; 516  :     if (state->seek) {

  00016	39 5f 48	 cmp	 DWORD PTR [edi+72], ebx
  00019	74 0f		 je	 SHORT $LN4@gzclose_w

; 517  :         state->seek = 0;
; 518  :         ret += gz_zero(state, state->skip);

  0001b	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  0001e	8b cf		 mov	 ecx, edi
  00020	89 5f 48	 mov	 DWORD PTR [edi+72], ebx
  00023	e8 00 00 00 00	 call	 _gz_zero
  00028	8b d8		 mov	 ebx, eax
$LN4@gzclose_w:

; 519  :     }
; 520  : 
; 521  :     /* flush, free memory, and close file */
; 522  :     ret += gz_comp(state, Z_FINISH);

  0002a	56		 push	 esi
  0002b	ba 04 00 00 00	 mov	 edx, 4
  00030	8b cf		 mov	 ecx, edi
  00032	e8 00 00 00 00	 call	 _gz_comp

; 523  :     (void)deflateEnd(&(state->strm));

  00037	8d 4f 54	 lea	 ecx, DWORD PTR [edi+84]
  0003a	03 d8		 add	 ebx, eax
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _deflateEnd@4

; 524  :     free(state->out);

  00042	ff 77 1c	 push	 DWORD PTR [edi+28]
  00045	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  0004b	ff d6		 call	 esi

; 525  :     free(state->in);

  0004d	ff 77 18	 push	 DWORD PTR [edi+24]
  00050	ff d6		 call	 esi

; 526  :     gz_error(state, Z_OK, NULL);

  00052	6a 00		 push	 0
  00054	33 d2		 xor	 edx, edx
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 _gz_error

; 527  :     free(state->path);

  0005d	ff 77 08	 push	 DWORD PTR [edi+8]
  00060	ff d6		 call	 esi

; 528  :     ret += close(state->fd);

  00062	ff 77 04	 push	 DWORD PTR [edi+4]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__close

; 529  :     free(state);

  0006b	57		 push	 edi
  0006c	03 d8		 add	 ebx, eax
  0006e	ff d6		 call	 esi
  00070	83 c4 18	 add	 esp, 24			; 00000018H

; 530  :     return ret ? Z_ERRNO : Z_OK;

  00073	f7 db		 neg	 ebx
  00075	1b db		 sbb	 ebx, ebx
  00077	8b c3		 mov	 eax, ebx
  00079	5e		 pop	 esi
  0007a	5f		 pop	 edi

; 531  : }

  0007b	5b		 pop	 ebx
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
$LN6@gzclose_w:
  00080	5f		 pop	 edi

; 513  :         return Z_STREAM_ERROR;

  00081	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 531  : }

  00086	5b		 pop	 ebx
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__ArgList$ = 12						; size = 4
__vsnprintf PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$ = edx

; 1409 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00003	ff 75 0c	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 08	 push	 DWORD PTR __Format$[ebp]
  0000b	52		 push	 edx
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	83 c9 01	 or	 ecx, 1
  0001a	51		 push	 ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1410 :         #pragma warning(push)
; 1411 :         #pragma warning(disable: 4996) // Deprecation
; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1413 :         #pragma warning(pop)
; 1414 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_gz_init PROC						; COMDAT
; _state$ = ecx

; 17   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);
; 20   : 
; 21   :     /* allocate input and output buffers */
; 22   :     state->in = malloc(state->want);

  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__malloc
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	ff 77 14	 push	 DWORD PTR [edi+20]
  0000e	8d 5f 54	 lea	 ebx, DWORD PTR [edi+84]
  00011	ff d6		 call	 esi

; 23   :     state->out = malloc(state->want);

  00013	ff 77 14	 push	 DWORD PTR [edi+20]
  00016	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00019	ff d6		 call	 esi

; 24   :     if (state->in == NULL || state->out == NULL) {

  0001b	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0001e	83 c4 08	 add	 esp, 8
  00021	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  00024	85 c9		 test	 ecx, ecx
  00026	74 72		 je	 SHORT $LN8@gz_init
  00028	85 c0		 test	 eax, eax
  0002a	74 70		 je	 SHORT $LN9@gz_init

; 30   :         return -1;
; 31   :     }
; 32   : 
; 33   :     /* allocate deflate memory, set up for gzip compression */
; 34   :     strm->zalloc = Z_NULL;
; 35   :     strm->zfree = Z_NULL;
; 36   :     strm->opaque = Z_NULL;
; 37   :     ret = deflateInit2(strm, state->level, Z_DEFLATED,

  0002c	6a 38		 push	 56			; 00000038H
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_05DFCKICEH@1?42?45@
  00033	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [ebx+32], 0
  0003a	c7 43 24 00 00
	00 00		 mov	 DWORD PTR [ebx+36], 0
  00041	c7 43 28 00 00
	00 00		 mov	 DWORD PTR [ebx+40], 0
  00048	ff 77 40	 push	 DWORD PTR [edi+64]
  0004b	6a 08		 push	 8
  0004d	6a 1f		 push	 31			; 0000001fH
  0004f	6a 08		 push	 8
  00051	ff 77 3c	 push	 DWORD PTR [edi+60]
  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 _deflateInit2_@32

; 38   :                        15 + 16, 8, state->strategy);
; 39   :     if (ret != Z_OK) {

  0005a	85 c0		 test	 eax, eax
  0005c	74 24		 je	 SHORT $LN6@gz_init

; 40   :         free(state->in);

  0005e	ff 77 18	 push	 DWORD PTR [edi+24]
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free

; 41   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  0006c	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  00071	8b cf		 mov	 ecx, edi
  00073	e8 00 00 00 00	 call	 _gz_error
  00078	83 c4 08	 add	 esp, 8

; 53   : }

  0007b	83 c8 ff	 or	 eax, -1
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	c3		 ret	 0
$LN6@gz_init:

; 42   :         return -1;
; 43   :     }
; 44   : 
; 45   :     /* mark state as initialized */
; 46   :     state->size = state->want;

  00082	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00085	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 47   : 
; 48   :     /* initialize write buffer */
; 49   :     strm->avail_out = state->size;

  00088	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 50   :     strm->next_out = state->out;

  0008b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  0008e	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 51   :     state->next = strm->next_out;

  00091	89 47 20	 mov	 DWORD PTR [edi+32], eax

; 52   :     return 0;

  00094	33 c0		 xor	 eax, eax
  00096	5f		 pop	 edi

; 53   : }

  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	c3		 ret	 0
$LN8@gz_init:

; 25   :         if (state->out != NULL)

  0009a	85 c0		 test	 eax, eax
$LN9@gz_init:
  0009c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__free
  000a2	74 09		 je	 SHORT $LN4@gz_init

; 26   :             free(state->out);

  000a4	50		 push	 eax
  000a5	ff d6		 call	 esi
  000a7	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  000aa	83 c4 04	 add	 esp, 4
$LN4@gz_init:

; 27   :         if (state->in != NULL)

  000ad	85 c9		 test	 ecx, ecx
  000af	74 06		 je	 SHORT $LN5@gz_init

; 28   :             free(state->in);

  000b1	51		 push	 ecx
  000b2	ff d6		 call	 esi
  000b4	83 c4 04	 add	 esp, 4
$LN5@gz_init:

; 29   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  000bc	ba fc ff ff ff	 mov	 edx, -4			; fffffffcH
  000c1	8b cf		 mov	 ecx, edi
  000c3	e8 00 00 00 00	 call	 _gz_error
  000c8	83 c4 04	 add	 esp, 4

; 53   : }

  000cb	83 c8 ff	 or	 eax, -1
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx
  000d1	c3		 ret	 0
_gz_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gz_comp
_TEXT	SEGMENT
_flush$1$ = -4						; size = 4
_gz_comp PROC						; COMDAT
; _state$ = ecx
; _flush$ = edx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	89 55 fc	 mov	 DWORD PTR _flush$1$[ebp], edx

; 63   :     int ret, got;
; 64   :     unsigned have;
; 65   :     z_streamp strm = &(state->strm);
; 66   : 
; 67   :     /* allocate memory if this is the first time through */
; 68   :     if (state->size == 0 && gz_init(state) == -1)

  0000b	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000f	8d 5e 54	 lea	 ebx, DWORD PTR [esi+84]
  00012	75 15		 jne	 SHORT $LN22@gz_comp
  00014	e8 00 00 00 00	 call	 _gz_init
  00019	83 f8 ff	 cmp	 eax, -1
  0001c	75 08		 jne	 SHORT $LN23@gz_comp

; 69   :         return -1;

  0001e	5e		 pop	 esi
  0001f	0b c0		 or	 eax, eax

; 108  : }

  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
$LN23@gz_comp:

; 63   :     int ret, got;
; 64   :     unsigned have;
; 65   :     z_streamp strm = &(state->strm);
; 66   : 
; 67   :     /* allocate memory if this is the first time through */
; 68   :     if (state->size == 0 && gz_init(state) == -1)

  00026	8b 55 fc	 mov	 edx, DWORD PTR _flush$1$[ebp]
$LN22@gz_comp:

; 70   : 
; 71   :     /* run deflate() on provided input until it produces no more output */
; 72   :     ret = Z_OK;

  00029	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0002c	33 c9		 xor	 ecx, ecx
  0002e	57		 push	 edi
  0002f	90		 npad	 1
$LL4@gz_comp:

; 73   :     do {
; 74   :         /* write out current buffer contents if full, or if flushing, but if
; 75   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 76   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&

  00030	85 c0		 test	 eax, eax
  00032	74 10		 je	 SHORT $LN8@gz_comp
  00034	8b f8		 mov	 edi, eax
  00036	85 d2		 test	 edx, edx
  00038	74 4a		 je	 SHORT $LN6@gz_comp
  0003a	83 fa 04	 cmp	 edx, 4
  0003d	75 05		 jne	 SHORT $LN8@gz_comp
  0003f	83 f9 01	 cmp	 ecx, 1
  00042	75 40		 jne	 SHORT $LN6@gz_comp
$LN8@gz_comp:

; 77   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {
; 78   :             have = (unsigned)(strm->next_out - state->next);

  00044	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00047	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0004a	2b f8		 sub	 edi, eax

; 79   :             if (have && ((got = write(state->fd, state->next, have)) < 0 ||

  0004c	74 16		 je	 SHORT $LN9@gz_comp
  0004e	57		 push	 edi
  0004f	50		 push	 eax
  00050	ff 76 04	 push	 DWORD PTR [esi+4]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__write
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005c	85 c0		 test	 eax, eax
  0005e	78 3e		 js	 SHORT $LN10@gz_comp
  00060	3b c7		 cmp	 eax, edi
  00062	75 3a		 jne	 SHORT $LN10@gz_comp
$LN9@gz_comp:

; 82   :                 return -1;
; 83   :             }
; 84   :             if (strm->avail_out == 0) {

  00064	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  00068	75 0e		 jne	 SHORT $LN20@gz_comp

; 85   :                 strm->avail_out = state->size;

  0006a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0006d	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 86   :                 strm->next_out = state->out;

  00070	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00073	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00076	eb 03		 jmp	 SHORT $LN11@gz_comp
$LN20@gz_comp:
  00078	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
$LN11@gz_comp:
  0007b	8b 55 fc	 mov	 edx, DWORD PTR _flush$1$[ebp]

; 87   :             }
; 88   :             state->next = strm->next_out;

  0007e	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00081	8b 7e 64	 mov	 edi, DWORD PTR [esi+100]
$LN6@gz_comp:

; 89   :         }
; 90   : 
; 91   :         /* compress */
; 92   :         have = strm->avail_out;
; 93   :         ret = deflate(strm, flush);

  00084	52		 push	 edx
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 _deflate@8
  0008b	8b c8		 mov	 ecx, eax

; 94   :         if (ret == Z_STREAM_ERROR) {

  0008d	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  00090	74 47		 je	 SHORT $LN17@gz_comp

; 98   :         }
; 99   :         have -= strm->avail_out;

  00092	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00095	2b f8		 sub	 edi, eax

; 100  :     } while (have);

  00097	74 2b		 je	 SHORT $LN16@gz_comp
  00099	8b 55 fc	 mov	 edx, DWORD PTR _flush$1$[ebp]
  0009c	eb 92		 jmp	 SHORT $LL4@gz_comp
$LN10@gz_comp:

; 80   :                          (unsigned)got != have)) {
; 81   :                 gz_error(state, Z_ERRNO, zstrerror());

  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  000a4	ff 30		 push	 DWORD PTR [eax]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  000ac	50		 push	 eax
  000ad	83 ca ff	 or	 edx, -1
  000b0	8b ce		 mov	 ecx, esi
  000b2	e8 00 00 00 00	 call	 _gz_error
  000b7	83 c4 08	 add	 esp, 8

; 96   :                       "internal error: deflate stream corrupt");
; 97   :             return -1;

  000ba	83 c8 ff	 or	 eax, -1
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi

; 108  : }

  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN16@gz_comp:

; 101  : 
; 102  :     /* if that completed a deflate stream, allow another to start */
; 103  :     if (flush == Z_FINISH)

  000c4	83 7d fc 04	 cmp	 DWORD PTR _flush$1$[ebp], 4
  000c8	75 06		 jne	 SHORT $LN13@gz_comp

; 104  :         deflateReset(strm);

  000ca	53		 push	 ebx
  000cb	e8 00 00 00 00	 call	 _deflateReset@4
$LN13@gz_comp:

; 105  : 
; 106  :     /* all done, no errors */
; 107  :     return 0;

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	33 c0		 xor	 eax, eax

; 108  : }

  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
$LN17@gz_comp:

; 95   :             gz_error(state, Z_STREAM_ERROR,

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
  000de	ba fe ff ff ff	 mov	 edx, -2			; fffffffeH
  000e3	8b ce		 mov	 ecx, esi
  000e5	e8 00 00 00 00	 call	 _gz_error
  000ea	83 c4 04	 add	 esp, 4

; 96   :                       "internal error: deflate stream corrupt");
; 97   :             return -1;

  000ed	83 c8 ff	 or	 eax, -1
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi

; 108  : }

  000f2	5b		 pop	 ebx
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_gz_comp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gz_zero
_TEXT	SEGMENT
_first$1$ = -4						; size = 4
_gz_zero PROC						; COMDAT
; _state$ = ecx
; _len$ = edx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b da		 mov	 ebx, edx

; 115  :     int first;
; 116  :     unsigned n;
; 117  :     z_streamp strm = &(state->strm);
; 118  : 
; 119  :     /* consume whatever's left in the input buffer */
; 120  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000b	83 7f 58 00	 cmp	 DWORD PTR [edi+88], 0
  0000f	74 0c		 je	 SHORT $LN4@gz_zero
  00011	33 d2		 xor	 edx, edx
  00013	e8 00 00 00 00	 call	 _gz_comp
  00018	83 f8 ff	 cmp	 eax, -1
  0001b	74 67		 je	 SHORT $LN12@gz_zero
$LN4@gz_zero:

; 121  :         return -1;
; 122  : 
; 123  :     /* compress len zeros (len guaranteed > 0) */
; 124  :     first = 1;

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _first$1$[ebp], eax

; 125  :     while (len) {

  00025	85 db		 test	 ebx, ebx
  00027	74 52		 je	 SHORT $LN3@gz_zero
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@gz_zero:

; 126  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?

  00030	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00033	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00039	77 04		 ja	 SHORT $LN15@gz_zero
  0003b	3b f3		 cmp	 esi, ebx
  0003d	7e 02		 jle	 SHORT $LN10@gz_zero
$LN15@gz_zero:
  0003f	8b f3		 mov	 esi, ebx
$LN10@gz_zero:

; 127  :             (unsigned)len : state->size;
; 128  :         if (first) {

  00041	85 c0		 test	 eax, eax
  00043	74 15		 je	 SHORT $LN5@gz_zero

; 129  :             memset(state->in, 0, n);

  00045	56		 push	 esi
  00046	6a 00		 push	 0
  00048	ff 77 18	 push	 DWORD PTR [edi+24]
  0004b	e8 00 00 00 00	 call	 _memset
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 130  :             first = 0;

  00053	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$1$[ebp], 0
$LN5@gz_zero:

; 131  :         }
; 132  :         strm->avail_in = n;

  0005a	89 77 58	 mov	 DWORD PTR [edi+88], esi

; 133  :         strm->next_in = state->in;
; 134  :         state->pos += n;
; 135  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  0005d	33 d2		 xor	 edx, edx
  0005f	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00062	8b cf		 mov	 ecx, edi
  00064	89 47 54	 mov	 DWORD PTR [edi+84], eax
  00067	01 77 0c	 add	 DWORD PTR [edi+12], esi
  0006a	e8 00 00 00 00	 call	 _gz_comp
  0006f	83 f8 ff	 cmp	 eax, -1
  00072	74 10		 je	 SHORT $LN12@gz_zero

; 136  :             return -1;
; 137  :         len -= n;

  00074	8b 45 fc	 mov	 eax, DWORD PTR _first$1$[ebp]
  00077	2b de		 sub	 ebx, esi
  00079	75 b5		 jne	 SHORT $LL2@gz_zero
$LN3@gz_zero:
  0007b	5f		 pop	 edi

; 138  :     }
; 139  :     return 0;
; 140  : }

  0007c	5e		 pop	 esi
  0007d	33 c0		 xor	 eax, eax
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN12@gz_zero:
  00084	5f		 pop	 edi
  00085	5e		 pop	 esi
  00086	83 c8 ff	 or	 eax, -1
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_gz_zero ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$1$ = 12						; size = 4
_buf$ = 12						; size = 4
_put$1$ = 16						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 148  :     unsigned put = len;

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _len$[ebp]
  00007	56		 push	 esi

; 149  :     unsigned n;
; 150  :     gz_statep state;
; 151  :     z_streamp strm;
; 152  : 
; 153  :     /* get internal structure */
; 154  :     if (file == NULL)

  00008	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  0000b	89 5d 10	 mov	 DWORD PTR _put$1$[ebp], ebx
  0000e	57		 push	 edi
  0000f	85 f6		 test	 esi, esi
  00011	74 26		 je	 SHORT $LN7@gzwrite

; 155  :         return 0;
; 156  :     state = (gz_statep)file;
; 157  :     strm = &(state->strm);
; 158  : 
; 159  :     /* check that we're writing and that there's no error */
; 160  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00013	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00019	75 1e		 jne	 SHORT $LN7@gzwrite
  0001b	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0001f	75 18		 jne	 SHORT $LN7@gzwrite

; 161  :         return 0;
; 162  : 
; 163  :     /* since an int is returned, make sure len fits in one, otherwise return
; 164  :        with an error (this avoids the flaw in the interface) */
; 165  :     if ((int)len < 0) {

  00021	85 db		 test	 ebx, ebx
  00023	79 1d		 jns	 SHORT $LN30@gzwrite

; 166  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
  0002a	ba fb ff ff ff	 mov	 edx, -5			; fffffffbH
  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 _gz_error
  00036	83 c4 04	 add	 esp, 4
$LN7@gzwrite:

; 218  : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	33 c0		 xor	 eax, eax
  0003d	5b		 pop	 ebx
  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
$LN30@gzwrite:

; 167  :         return 0;
; 168  :     }
; 169  : 
; 170  :     /* if len is zero, avoid unnecessary operations */
; 171  :     if (len == 0)

  00042	74 f5		 je	 SHORT $LN7@gzwrite

; 172  :         return 0;
; 173  : 
; 174  :     /* allocate memory if this is the first time through */
; 175  :     if (state->size == 0 && gz_init(state) == -1)

  00044	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00048	75 0c		 jne	 SHORT $LN28@gzwrite
  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 _gz_init
  00051	83 f8 ff	 cmp	 eax, -1
  00054	74 e3		 je	 SHORT $LN7@gzwrite
$LN28@gzwrite:

; 176  :         return 0;
; 177  : 
; 178  :     /* check for seek request */
; 179  :     if (state->seek) {

  00056	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0005a	74 16		 je	 SHORT $LN12@gzwrite

; 180  :         state->seek = 0;
; 181  :         if (gz_zero(state, state->skip) == -1)

  0005c	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0005f	8b ce		 mov	 ecx, esi
  00061	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00068	e8 00 00 00 00	 call	 _gz_zero
  0006d	83 f8 ff	 cmp	 eax, -1
  00070	74 c7		 je	 SHORT $LN7@gzwrite
$LN12@gzwrite:

; 182  :             return 0;
; 183  :     }
; 184  : 
; 185  :     /* for small len, copy to input buffer, otherwise compress directly */
; 186  :     if (len < state->size) {

  00072	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00075	73 5b		 jae	 SHORT $LN13@gzwrite
  00077	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0007a	89 45 0c	 mov	 DWORD PTR _buf$1$[ebp], eax
  0007d	0f 1f 00	 npad	 3
$LL4@gzwrite:

; 187  :         /* copy to input buffer, compress when full */
; 188  :         do {
; 189  :             if (strm->avail_in == 0)

  00080	8b 56 58	 mov	 edx, DWORD PTR [esi+88]
  00083	85 d2		 test	 edx, edx
  00085	75 08		 jne	 SHORT $LN29@gzwrite

; 190  :                 strm->next_in = state->in;

  00087	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0008a	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  0008d	eb 03		 jmp	 SHORT $LN26@gzwrite
$LN29@gzwrite:
  0008f	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
$LN26@gzwrite:

; 191  :             n = state->size - strm->avail_in;

  00092	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 192  :             if (n > len)
; 193  :                 n = len;
; 194  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  00095	8b fb		 mov	 edi, ebx
  00097	2b c2		 sub	 eax, edx
  00099	3b c3		 cmp	 eax, ebx
  0009b	0f 46 f8	 cmovbe	 edi, eax
  0009e	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000a1	57		 push	 edi
  000a2	ff 75 0c	 push	 DWORD PTR _buf$1$[ebp]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _memcpy

; 195  :             strm->avail_in += n;

  000ab	01 7e 58	 add	 DWORD PTR [esi+88], edi
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  :             state->pos += n;

  000b1	01 7e 0c	 add	 DWORD PTR [esi+12], edi

; 197  :             buf = (char *)buf + n;

  000b4	01 7d 0c	 add	 DWORD PTR _buf$1$[ebp], edi

; 198  :             len -= n;

  000b7	2b df		 sub	 ebx, edi

; 199  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000b9	74 4d		 je	 SHORT $LN19@gzwrite
  000bb	33 d2		 xor	 edx, edx
  000bd	8b ce		 mov	 ecx, esi
  000bf	e8 00 00 00 00	 call	 _gz_comp
  000c4	83 f8 ff	 cmp	 eax, -1
  000c7	75 b7		 jne	 SHORT $LL4@gzwrite

; 218  : }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	33 c0		 xor	 eax, eax
  000cd	5b		 pop	 ebx
  000ce	5d		 pop	 ebp
  000cf	c2 0c 00	 ret	 12			; 0000000cH
$LN13@gzwrite:

; 200  :                 return 0;
; 201  :         } while (len);
; 202  :     }
; 203  :     else {
; 204  :         /* consume whatever's left in the input buffer */
; 205  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000d2	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000d6	74 12		 je	 SHORT $LN18@gzwrite
  000d8	33 d2		 xor	 edx, edx
  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 _gz_comp
  000e1	83 f8 ff	 cmp	 eax, -1
  000e4	0f 84 4f ff ff
	ff		 je	 $LN7@gzwrite
$LN18@gzwrite:

; 206  :             return 0;
; 207  : 
; 208  :         /* directly compress user buffer to file */
; 209  :         strm->avail_in = len;
; 210  :         strm->next_in = (voidp)buf;

  000ea	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]

; 211  :         state->pos += len;
; 212  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000ed	33 d2		 xor	 edx, edx
  000ef	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  000f2	8b ce		 mov	 ecx, esi
  000f4	89 46 54	 mov	 DWORD PTR [esi+84], eax
  000f7	01 5e 0c	 add	 DWORD PTR [esi+12], ebx
  000fa	e8 00 00 00 00	 call	 _gz_comp
  000ff	83 f8 ff	 cmp	 eax, -1
  00102	0f 84 31 ff ff
	ff		 je	 $LN7@gzwrite
$LN19@gzwrite:

; 213  :             return 0;
; 214  :     }
; 215  : 
; 216  :     /* input was all buffered or compressed (put will fit in int) */
; 217  :     return (int)put;

  00108	8b 45 10	 mov	 eax, DWORD PTR _put$1$[ebp]
  0010b	5f		 pop	 edi

; 218  : }

  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	5d		 pop	 ebp
  0010f	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 11						; size = 1
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 225  :     unsigned char buf[1];
; 226  :     gz_statep state;
; 227  :     z_streamp strm;
; 228  : 
; 229  :     /* get internal structure */
; 230  :     if (file == NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 82 00 00
	00		 je	 $LN4@gzputc

; 231  :         return -1;
; 232  :     state = (gz_statep)file;
; 233  :     strm = &(state->strm);
; 234  : 
; 235  :     /* check that we're writing and that there's no error */
; 236  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00010	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00016	75 7a		 jne	 SHORT $LN4@gzputc
  00018	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  0001c	75 74		 jne	 SHORT $LN4@gzputc

; 238  : 
; 239  :     /* check for seek request */
; 240  :     if (state->seek) {

  0001e	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00022	74 16		 je	 SHORT $LN6@gzputc

; 241  :         state->seek = 0;
; 242  :         if (gz_zero(state, state->skip) == -1)

  00024	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00027	8b ce		 mov	 ecx, esi
  00029	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00030	e8 00 00 00 00	 call	 _gz_zero
  00035	83 f8 ff	 cmp	 eax, -1
  00038	74 58		 je	 SHORT $LN4@gzputc
$LN6@gzputc:

; 243  :             return -1;
; 244  :     }
; 245  : 
; 246  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 247  :        initialized) */
; 248  :     if (strm->avail_in < state->size) {

  0003a	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0003d	3b 4e 10	 cmp	 ecx, DWORD PTR [esi+16]
  00040	73 31		 jae	 SHORT $LN7@gzputc

; 249  :         if (strm->avail_in == 0)

  00042	85 c9		 test	 ecx, ecx
  00044	75 18		 jne	 SHORT $LN11@gzputc

; 250  :             strm->next_in = state->in;

  00046	8b 56 18	 mov	 edx, DWORD PTR [esi+24]

; 251  :         strm->next_in[strm->avail_in++] = c;

  00049	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0004c	89 56 54	 mov	 DWORD PTR [esi+84], edx
  0004f	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00052	ff 46 58	 inc	 DWORD PTR [esi+88]

; 252  :         state->pos++;

  00055	ff 46 0c	 inc	 DWORD PTR [esi+12]
  00058	5e		 pop	 esi

; 261  : }

  00059	5b		 pop	 ebx
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
$LN11@gzputc:

; 250  :             strm->next_in = state->in;

  0005e	8b 56 54	 mov	 edx, DWORD PTR [esi+84]

; 251  :         strm->next_in[strm->avail_in++] = c;

  00061	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00064	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00067	ff 46 58	 inc	 DWORD PTR [esi+88]

; 252  :         state->pos++;

  0006a	ff 46 0c	 inc	 DWORD PTR [esi+12]
  0006d	5e		 pop	 esi

; 261  : }

  0006e	5b		 pop	 ebx
  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
$LN7@gzputc:

; 253  :         return c;
; 254  :     }
; 255  : 
; 256  :     /* no room in buffer or not initialized, use gz_write() */
; 257  :     buf[0] = c;

  00073	8b 5d 0c	 mov	 ebx, DWORD PTR _c$[ebp]

; 258  :     if (gzwrite(file, buf, 1) != 1)

  00076	8d 45 0b	 lea	 eax, DWORD PTR _buf$[ebp]
  00079	6a 01		 push	 1
  0007b	50		 push	 eax
  0007c	56		 push	 esi
  0007d	88 5d 0b	 mov	 BYTE PTR _buf$[ebp], bl
  00080	e8 00 00 00 00	 call	 _gzwrite@12
  00085	83 f8 01	 cmp	 eax, 1
  00088	75 08		 jne	 SHORT $LN4@gzputc

; 259  :         return -1;
; 260  :     return c;

  0008a	5e		 pop	 esi
  0008b	8b c3		 mov	 eax, ebx

; 261  : }

  0008d	5b		 pop	 ebx
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
$LN4@gzputc:
  00092	5e		 pop	 esi

; 237  :         return -1;

  00093	83 c8 ff	 or	 eax, -1

; 261  : }

  00096	5b		 pop	 ebx
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
_gzputc@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzputs@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 268  :     int ret;
; 269  :     unsigned len;
; 270  : 
; 271  :     /* write string */
; 272  :     len = (unsigned)strlen(str);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  0000c	0f 1f 40 00	 npad	 4
$LL5@gzputs:
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	46		 inc	 esi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL5@gzputs
  00017	2b f2		 sub	 esi, edx

; 273  :     ret = gzwrite(file, str, len);

  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	ff 75 08	 push	 DWORD PTR _file$[ebp]
  0001e	e8 00 00 00 00	 call	 _gzwrite@12

; 274  :     return ret == 0 && len != 0 ? -1 : ret;

  00023	85 c0		 test	 eax, eax
  00025	75 07		 jne	 SHORT $LN4@gzputs
  00027	85 f6		 test	 esi, esi
  00029	74 03		 je	 SHORT $LN4@gzputs
  0002b	83 c8 ff	 or	 eax, -1
$LN4@gzputs:
  0002e	5e		 pop	 esi

; 275  : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzprintf
_TEXT	SEGMENT
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 283  :     int size, len;
; 284  :     gz_statep state;
; 285  :     z_streamp strm;
; 286  :     va_list va;
; 287  : 
; 288  :     /* get internal structure */
; 289  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 06		 jne	 SHORT $LN2@gzprintf

; 290  :         return -1;

  0000b	83 c8 ff	 or	 eax, -1
  0000e	5e		 pop	 esi

; 346  :     return len;
; 347  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
$LN2@gzprintf:

; 291  :     state = (gz_statep)file;
; 292  :     strm = &(state->strm);
; 293  : 
; 294  :     /* check that we're writing and that there's no error */
; 295  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00017	57		 push	 edi
  00018	0f 85 a6 00 00
	00		 jne	 $LN4@gzprintf
  0001e	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00022	0f 85 9c 00 00
	00		 jne	 $LN4@gzprintf

; 297  : 
; 298  :     /* make sure we have some buffer space */
; 299  :     if (state->size == 0 && gz_init(state) == -1)

  00028	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0002c	75 10		 jne	 SHORT $LN17@gzprintf
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 _gz_init
  00035	83 f8 ff	 cmp	 eax, -1
  00038	0f 84 86 00 00
	00		 je	 $LN4@gzprintf
$LN17@gzprintf:

; 300  :         return 0;
; 301  : 
; 302  :     /* check for seek request */
; 303  :     if (state->seek) {

  0003e	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00042	74 16		 je	 SHORT $LN7@gzprintf

; 304  :         state->seek = 0;
; 305  :         if (gz_zero(state, state->skip) == -1)

  00044	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00047	8b ce		 mov	 ecx, esi
  00049	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00050	e8 00 00 00 00	 call	 _gz_zero
  00055	83 f8 ff	 cmp	 eax, -1
  00058	74 6a		 je	 SHORT $LN4@gzprintf
$LN7@gzprintf:

; 306  :             return 0;
; 307  :     }
; 308  : 
; 309  :     /* consume whatever's left in the input buffer */
; 310  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0005a	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  0005e	74 0e		 je	 SHORT $LN8@gzprintf
  00060	33 d2		 xor	 edx, edx
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 _gz_comp
  00069	83 f8 ff	 cmp	 eax, -1
  0006c	74 56		 je	 SHORT $LN4@gzprintf
$LN8@gzprintf:

; 311  :         return 0;
; 312  : 
; 313  :     /* do the printf() into the input buffer, put length in len */
; 314  :     size = (int)(state->size);

  0006e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 315  :     state->in[size - 1] = 0;

  00071	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00074	c6 44 38 ff 00	 mov	 BYTE PTR [eax+edi-1], 0
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00079	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  0007c	50		 push	 eax
  0007d	6a 00		 push	 0
  0007f	ff 75 0c	 push	 DWORD PTR _format$[ebp]
  00082	57		 push	 edi
  00083	ff 76 18	 push	 DWORD PTR [esi+24]
  00086	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	ff 70 04	 push	 DWORD PTR [eax+4]
  00090	83 c9 01	 or	 ecx, 1
  00093	51		 push	 ecx
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0009a	83 c9 ff	 or	 ecx, -1
  0009d	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a0	85 c0		 test	 eax, eax
  000a2	0f 48 c1	 cmovs	 eax, ecx
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c

; 339  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000a5	85 c0		 test	 eax, eax
  000a7	7e 1b		 jle	 SHORT $LN4@gzprintf
  000a9	3b c7		 cmp	 eax, edi
  000ab	7d 17		 jge	 SHORT $LN4@gzprintf
  000ad	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  000b0	80 7c 39 ff 00	 cmp	 BYTE PTR [ecx+edi-1], 0
  000b5	75 0d		 jne	 SHORT $LN4@gzprintf

; 340  :         return 0;
; 341  : 
; 342  :     /* update buffer and position, defer compression until needed */
; 343  :     strm->avail_in = (unsigned)len;

  000b7	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 344  :     strm->next_in = state->in;

  000ba	89 4e 54	 mov	 DWORD PTR [esi+84], ecx

; 345  :     state->pos += len;

  000bd	01 46 0c	 add	 DWORD PTR [esi+12], eax
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi

; 346  :     return len;
; 347  : }

  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
$LN4@gzprintf:
  000c4	5f		 pop	 edi

; 296  :         return 0;

  000c5	33 c0		 xor	 eax, eax
  000c7	5e		 pop	 esi

; 346  :     return len;
; 347  : }

  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 430  :     gz_statep state;
; 431  : 
; 432  :     /* get internal structure */
; 433  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 4c		 je	 SHORT $LN12@gzflush

; 434  :         return -1;
; 435  :     state = (gz_statep)file;
; 436  : 
; 437  :     /* check that we're writing and that there's no error */
; 438  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000b	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00011	75 3a		 jne	 SHORT $LN4@gzflush
  00013	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00017	75 34		 jne	 SHORT $LN4@gzflush

; 440  : 
; 441  :     /* check flush parameter */
; 442  :     if (flush < 0 || flush > Z_FINISH)

  00019	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0001d	77 2e		 ja	 SHORT $LN4@gzflush

; 443  :         return Z_STREAM_ERROR;
; 444  : 
; 445  :     /* check for seek request */
; 446  :     if (state->seek) {

  0001f	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  00023	74 16		 je	 SHORT $LN11@gzflush

; 447  :         state->seek = 0;
; 448  :         if (gz_zero(state, state->skip) == -1)

  00025	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00028	8b ce		 mov	 ecx, esi
  0002a	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00031	e8 00 00 00 00	 call	 _gz_zero
  00036	83 f8 ff	 cmp	 eax, -1
  00039	74 1c		 je	 SHORT $LN12@gzflush
$LN11@gzflush:

; 450  :     }
; 451  : 
; 452  :     /* compress remaining data with requested flush */
; 453  :     gz_comp(state, flush);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 _gz_comp

; 454  :     return state->err;

  00045	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00048	5e		 pop	 esi

; 455  : }

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN4@gzflush:

; 439  :         return Z_STREAM_ERROR;

  0004d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00052	5e		 pop	 esi

; 455  : }

  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
$LN12@gzflush:

; 449  :             return -1;

  00057	83 c8 ff	 or	 eax, -1
  0005a	5e		 pop	 esi

; 455  : }

  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\gzwrite.c
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 463  :     gz_statep state;
; 464  :     z_streamp strm;
; 465  : 
; 466  :     /* get internal structure */
; 467  :     if (file == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _file$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	0f 84 90 00 00
	00		 je	 $LN4@gzsetparam

; 468  :         return Z_STREAM_ERROR;
; 469  :     state = (gz_statep)file;
; 470  :     strm = &(state->strm);
; 471  : 
; 472  :     /* check that we're writing and that there's no error */
; 473  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000f	81 3e b1 79 00
	00		 cmp	 DWORD PTR [esi], 31153	; 000079b1H
  00015	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
  00018	0f 85 81 00 00
	00		 jne	 $LN4@gzsetparam
  0001e	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00022	75 7b		 jne	 SHORT $LN4@gzsetparam

; 475  : 
; 476  :     /* if no change is requested, then do nothing */
; 477  :     if (level == state->level && strategy == state->strategy)

  00024	53		 push	 ebx
  00025	8b 5d 0c	 mov	 ebx, DWORD PTR _level$[ebp]
  00028	57		 push	 edi
  00029	8b 7d 10	 mov	 edi, DWORD PTR _strategy$[ebp]
  0002c	3b 5e 3c	 cmp	 ebx, DWORD PTR [esi+60]
  0002f	75 05		 jne	 SHORT $LN5@gzsetparam
  00031	3b 7e 40	 cmp	 edi, DWORD PTR [esi+64]
  00034	74 60		 je	 SHORT $LN17@gzsetparam
$LN5@gzsetparam:

; 478  :         return Z_OK;
; 479  : 
; 480  :     /* check for seek request */
; 481  :     if (state->seek) {

  00036	83 7e 48 00	 cmp	 DWORD PTR [esi+72], 0
  0003a	74 22		 je	 SHORT $LN12@gzsetparam

; 482  :         state->seek = 0;
; 483  :         if (gz_zero(state, state->skip) == -1)

  0003c	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0003f	8b ce		 mov	 ecx, esi
  00041	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  00048	e8 00 00 00 00	 call	 _gz_zero
  0004d	83 f8 ff	 cmp	 eax, -1
  00050	75 09		 jne	 SHORT $LN14@gzsetparam

; 484  :             return -1;

  00052	5f		 pop	 edi
  00053	5b		 pop	 ebx
  00054	0b c0		 or	 eax, eax
  00056	5e		 pop	 esi

; 497  : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN14@gzsetparam:

; 482  :         state->seek = 0;
; 483  :         if (gz_zero(state, state->skip) == -1)

  0005b	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
$LN12@gzsetparam:

; 485  :     }
; 486  : 
; 487  :     /* change compression parameters for subsequent input */
; 488  :     if (state->size) {

  0005e	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00062	74 2c		 je	 SHORT $LN8@gzsetparam

; 489  :         /* flush previous input with previous parameters before changing */
; 490  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00064	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00068	74 1e		 je	 SHORT $LN9@gzsetparam
  0006a	ba 01 00 00 00	 mov	 edx, 1
  0006f	8b ce		 mov	 ecx, esi
  00071	e8 00 00 00 00	 call	 _gz_comp
  00076	83 f8 ff	 cmp	 eax, -1
  00079	75 0a		 jne	 SHORT $LN13@gzsetparam

; 491  :             return state->err;

  0007b	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0007e	5f		 pop	 edi
  0007f	5b		 pop	 ebx
  00080	5e		 pop	 esi

; 497  : }

  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
$LN13@gzsetparam:

; 489  :         /* flush previous input with previous parameters before changing */
; 490  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00085	8d 46 54	 lea	 eax, DWORD PTR [esi+84]
$LN9@gzsetparam:

; 492  :         deflateParams(strm, level, strategy);

  00088	57		 push	 edi
  00089	53		 push	 ebx
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _deflateParams@12
$LN8@gzsetparam:

; 493  :     }
; 494  :     state->level = level;

  00090	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx

; 495  :     state->strategy = strategy;

  00093	89 7e 40	 mov	 DWORD PTR [esi+64], edi
$LN17@gzsetparam:

; 496  :     return Z_OK;

  00096	5f		 pop	 edi
  00097	5b		 pop	 ebx
  00098	33 c0		 xor	 eax, eax
  0009a	5e		 pop	 esi

; 497  : }

  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@gzsetparam:

; 474  :         return Z_STREAM_ERROR;

  0009f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000a4	5e		 pop	 esi

; 497  : }

  000a5	5d		 pop	 ebp
  000a6	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
END
