; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateMark@4
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 9c 00 00
	00		 je	 $LN3@inflateRes
  0000e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00011	85 c9		 test	 ecx, ecx
  00013	0f 84 91 00 00
	00		 je	 $LN3@inflateRes

; 109  :     state = (struct inflate_state FAR *)strm->state;
; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00019	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
  00020	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  00027	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 111  :     strm->msg = Z_NULL;

  0002e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  00035	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1

; 113  :     state->mode = HEAD;
; 114  :     state->last = 0;
; 115  :     state->havedict = 0;
; 116  :     state->dmax = 32768U;
; 117  :     state->head = Z_NULL;
; 118  :     state->wsize = 0;
; 119  :     state->whave = 0;
; 120  :     state->wnext = 0;
; 121  :     state->hold = 0;
; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  0003c	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00042	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00045	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00048	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 124  :     state->sane = 1;
; 125  :     state->back = -1;
; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  0004b	33 c0		 xor	 eax, eax
  0004d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00053	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0005a	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00061	c7 41 14 00 80
	00 00		 mov	 DWORD PTR [ecx+20], 32768 ; 00008000H
  00068	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  0006f	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00076	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  0007d	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
  00084	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0008b	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00092	c7 81 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7104], 1
  0009c	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 128  : }

  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
$LN3@inflateRes:

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000aa	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 128  : }

  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 a3 00 00
	00		 je	 $LN3@inflateIni
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 9a 00 00
	00		 jne	 $LN3@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 90 00 00
	00		 jne	 $LN3@inflateIni

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 199  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 182  :     if (strm->zalloc == (alloc_func)0) {

  00031	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN10@inflateIni

; 183  :         strm->zalloc = zcalloc;
; 184  :         strm->opaque = (voidpf)0;

  0003f	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00050	eb 03		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  00052	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN5@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00055	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00059	75 07		 jne	 SHORT $LN6@inflateIni
  0005b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:
  00062	57		 push	 edi

; 187  :     state = (struct inflate_state FAR *)

  00063	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00068	6a 01		 push	 1
  0006a	51		 push	 ecx
  0006b	ff d0		 call	 eax
  0006d	8b f8		 mov	 edi, eax
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00072	85 ff		 test	 edi, edi
  00074	75 09		 jne	 SHORT $LN7@inflateIni
  00076	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 199  : }

  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007f	53		 push	 ebx

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;
; 192  :     state->window = Z_NULL;
; 193  :     ret = inflateReset2(strm, windowBits);

  00080	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  00083	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00086	56		 push	 esi
  00087	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
  0008e	e8 00 00 00 00	 call	 _inflateReset2@8
  00093	8b d8		 mov	 ebx, eax

; 194  :     if (ret != Z_OK) {

  00095	85 db		 test	 ebx, ebx
  00097	74 13		 je	 SHORT $LN8@inflateIni

; 195  :         ZFREE(strm, state);

  00099	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0009c	57		 push	 edi
  0009d	ff 76 28	 push	 DWORD PTR [esi+40]
  000a0	ff d1		 call	 ecx
  000a2	83 c4 08	 add	 esp, 8

; 196  :         strm->state = Z_NULL;

  000a5	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 197  :     }
; 198  :     return ret;

  000ac	8b c3		 mov	 eax, ebx
  000ae	5b		 pop	 ebx
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi

; 199  : }

  000b1	5d		 pop	 ebp
  000b2	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 178  :         stream_size != (int)(sizeof(z_stream)))
; 179  :         return Z_VERSION_ERROR;

  000b5	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000ba	5e		 pop	 esi

; 199  : }

  000bb	5d		 pop	 ebp
  000bc	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv5496 = -64						; size = 4
tv5490 = -64						; size = 4
tv5484 = -64						; size = 4
tv5445 = -64						; size = 4
tv5433 = -64						; size = 4
tv5423 = -64						; size = 4
$T1 = -60						; size = 4
$T2 = -60						; size = 4
$T3 = -60						; size = 4
_copy$7$ = -60						; size = 4
tv5608 = -60						; size = 4
tv5577 = -60						; size = 4
tv5540 = -60						; size = 4
tv5521 = -60						; size = 4
tv5520 = -60						; size = 4
tv5491 = -60						; size = 4
tv5465 = -60						; size = 4
tv5450 = -60						; size = 4
tv5173 = -60						; size = 4
_copy$3$ = -60						; size = 4
_copy$2$ = -60						; size = 4
_copy$1$ = -60						; size = 4
_len$1$ = -60						; size = 4
_here$ = -60						; size = 4
_in$1$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -52						; size = 4
$T6 = -52						; size = 4
$T7 = -52						; size = 4
$T8 = -52						; size = 4
$T9 = -52						; size = 4
_from$1$ = -52						; size = 4
tv5453 = -52						; size = 4
tv5452 = -52						; size = 4
tv5424 = -52						; size = 4
_len$2$ = -52						; size = 4
_last$ = -52						; size = 4
_ret$1$ = -48						; size = 4
$T10 = -44						; size = 4
$T11 = -44						; size = 4
_copy$4$ = -44						; size = 4
tv5605 = -44						; size = 4
tv5599 = -44						; size = 4
tv5581 = -44						; size = 4
tv5489 = -44						; size = 4
_out$1$ = -40						; size = 4
_put$1$ = -36						; size = 4
_left$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
tv5446 = -24						; size = 4
_bits$1$ = -24						; size = 4
tv5455 = -20						; size = 4
_next$1$ = -20						; size = 4
_have$1$ = -16						; size = 4
_state$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
tv5580 = -1						; size = 1
tv5579 = -1						; size = 1
tv5410 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 592  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	85 d2		 test	 edx, edx
  0000e	0f 84 b5 10 00
	00		 je	 $LN341@inflate
  00014	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00017	89 4d f4	 mov	 DWORD PTR _state$1$[ebp], ecx
  0001a	85 c9		 test	 ecx, ecx
  0001c	0f 84 a7 10 00
	00		 je	 $LN341@inflate
  00022	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00025	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 99 10 00
	00		 je	 $LN341@inflate
  00030	8b 3a		 mov	 edi, DWORD PTR [edx]
  00032	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00035	85 ff		 test	 edi, edi
  00037	75 09		 jne	 SHORT $LN764@inflate
  00039	39 7a 04	 cmp	 DWORD PTR [edx+4], edi
  0003c	0f 85 87 10 00
	00		 jne	 $LN341@inflate
$LN764@inflate:

; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 614  :         return Z_STREAM_ERROR;
; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;
; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00042	8b 01		 mov	 eax, DWORD PTR [ecx]
  00044	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00047	75 16		 jne	 SHORT $LN4@inflate
  00049	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
  0004f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00052	8b 3a		 mov	 edi, DWORD PTR [edx]
  00054	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  00057	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0005c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
$LN4@inflate:

; 618  :     LOAD();

  0005f	8b 7a 10	 mov	 edi, DWORD PTR [edx+16]
  00062	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00065	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00068	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  0006b	89 7d e0	 mov	 DWORD PTR _left$1$[ebp], edi

; 619  :     in = have;
; 620  :     out = left;

  0006e	89 7d d8	 mov	 DWORD PTR _out$1$[ebp], edi

; 621  :     ret = Z_OK;

  00071	33 ff		 xor	 edi, edi
  00073	89 7d d0	 mov	 DWORD PTR _ret$1$[ebp], edi

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00076	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00079	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0007c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0007f	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00082	89 5d c8	 mov	 DWORD PTR _in$1$[ebp], ebx
  00085	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00088	0f 87 3b 10 00
	00		 ja	 $LN341@inflate

; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +

  0008e	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
$LL5@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00091	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1001@inflate[eax*4]
$LN343@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  00098	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0009b	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 0b		 jne	 SHORT $LN12@inflate

; 626  :                 state->mode = TYPEDO;

  000a2	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH

; 627  :                 break;

  000a8	e9 0e 10 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  000ad	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b0	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000b2	85 db		 test	 ebx, ebx
  000b4	0f 84 ce 14 00
	00		 je	 $LN952@inflate
  000ba	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000bd	8b ce		 mov	 ecx, esi
  000bf	d3 e0		 shl	 eax, cl
  000c1	83 c6 08	 add	 esi, 8
  000c4	4b		 dec	 ebx
  000c5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  000c8	03 d0		 add	 edx, eax
  000ca	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  000cd	47		 inc	 edi
  000ce	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000d1	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  000d4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000d7	72 d9		 jb	 SHORT $LL13@inflate
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000dc	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
$LN10@inflate:

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000df	a8 02		 test	 al, 2
  000e1	74 48		 je	 SHORT $LN346@inflate
  000e3	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000e9	75 40		 jne	 SHORT $LN346@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	6a 00		 push	 0
  000f1	e8 00 00 00 00	 call	 _crc32@12
  000f6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 633  :                 CRC2(state->check, hold);

  000f9	6a 02		 push	 2
  000fb	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  000fe	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00101	50		 push	 eax
  00102	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00108	ff 71 18	 push	 DWORD PTR [ecx+24]
  0010b	e8 00 00 00 00	 call	 _crc32@12
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 634  :                 INITBITS();

  00113	33 d2		 xor	 edx, edx
  00115	33 f6		 xor	 esi, esi
  00117	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0011a	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0011d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 635  :                 state->mode = FLAGS;

  00120	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 636  :                 break;

  00126	e9 90 0f 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */
; 639  :             if (state->head != Z_NULL)

  0012b	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0012e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00135	85 c0		 test	 eax, eax
  00137	74 07		 je	 SHORT $LN960@inflate

; 640  :                 state->head->done = -1;

  00139	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN960@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00140	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00143	a8 01		 test	 al, 1
  00145	0f 84 c1 00 00
	00		 je	 $LN349@inflate
  0014b	0f b6 ca	 movzx	 ecx, dl
  0014e	8b c2		 mov	 eax, edx
  00150	c1 e1 08	 shl	 ecx, 8
  00153	33 d2		 xor	 edx, edx
  00155	c1 e8 08	 shr	 eax, 8
  00158	03 c1		 add	 eax, ecx
  0015a	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0015f	f7 f1		 div	 ecx
  00161	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00164	85 d2		 test	 edx, edx
  00166	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00169	0f 85 9d 00 00
	00		 jne	 $LN349@inflate

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  0016f	8b c2		 mov	 eax, edx
  00171	24 0f		 and	 al, 15			; 0000000fH
  00173	3c 08		 cmp	 al, 8
  00175	74 15		 je	 SHORT $LN26@inflate
$LN998@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00177	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0017a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  00181	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00187	e9 2f 0f 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 651  :                 strm->msg = (char *)"unknown compression method";
; 652  :                 state->mode = BAD;
; 653  :                 break;
; 654  :             }
; 655  :             DROPBITS(4);

  0018c	c1 ea 04	 shr	 edx, 4
  0018f	83 ee 04	 sub	 esi, 4

; 656  :             len = BITS(4) + 8;

  00192	8b c2		 mov	 eax, edx
  00194	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00197	83 e0 0f	 and	 eax, 15			; 0000000fH
  0019a	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0019d	83 c0 08	 add	 eax, 8

; 657  :             if (state->wbits == 0)

  001a0	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  001a4	89 45 c4	 mov	 DWORD PTR _len$1$[ebp], eax
  001a7	75 49		 jne	 SHORT $LN351@inflate

; 658  :                 state->wbits = len;

  001a9	89 41 24	 mov	 DWORD PTR [ecx+36], eax
$LN353@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  001ac	8b 4d c4	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001af	b8 01 00 00 00	 mov	 eax, 1
  001b4	d3 e0		 shl	 eax, cl
  001b6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001b9	6a 00		 push	 0
  001bb	6a 00		 push	 0
  001bd	6a 00		 push	 0
  001bf	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  001c2	e8 00 00 00 00	 call	 _adler32@12
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001ca	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001cd	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001d0	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001d3	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001d6	c1 ea 08	 shr	 edx, 8
  001d9	f7 d2		 not	 edx
  001db	83 e2 02	 and	 edx, 2
  001de	83 ca 09	 or	 edx, 9
  001e1	89 11		 mov	 DWORD PTR [ecx], edx

; 668  :             INITBITS();

  001e3	33 d2		 xor	 edx, edx
  001e5	33 f6		 xor	 esi, esi
  001e7	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001ea	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 669  :             break;

  001ed	e9 c9 0e 00 00	 jmp	 $LN8@inflate
$LN351@inflate:

; 659  :             else if (len > state->wbits) {

  001f2	3b 41 24	 cmp	 eax, DWORD PTR [ecx+36]
  001f5	76 b5		 jbe	 SHORT $LN353@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  001f7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  001fa	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 661  :                 state->mode = BAD;

  00201	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 662  :                 break;

  00207	e9 af 0e 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 646  :                 strm->msg = (char *)"incorrect header check";

  0020c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0020f	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 647  :                 state->mode = BAD;

  00216	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH

; 648  :                 break;

  0021c	e9 9a 0e 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00221	83 fe 10	 cmp	 esi, 16			; 00000010H
  00224	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00226	85 db		 test	 ebx, ebx
  00228	0f 84 5a 13 00
	00		 je	 $LN952@inflate
  0022e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00231	8b ce		 mov	 ecx, esi
  00233	d3 e0		 shl	 eax, cl
  00235	83 c6 08	 add	 esi, 8
  00238	4b		 dec	 ebx
  00239	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0023c	03 d0		 add	 edx, eax
  0023e	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00241	47		 inc	 edi
  00242	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00245	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00248	83 fe 10	 cmp	 esi, 16			; 00000010H
  0024b	72 d9		 jb	 SHORT $LL33@inflate
  0024d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 673  :             state->flags = (int)(hold);

  00250	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00253	80 fa 08	 cmp	 dl, 8
  00256	0f 85 1b ff ff
	ff		 jne	 $LN998@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";
; 676  :                 state->mode = BAD;
; 677  :                 break;
; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  0025c	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  00262	74 15		 je	 SHORT $LN357@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  00264	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00267	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  0026e	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00274	e9 42 0e 00 00	 jmp	 $LN8@inflate
$LN357@inflate:

; 681  :                 state->mode = BAD;
; 682  :                 break;
; 683  :             }
; 684  :             if (state->head != Z_NULL)

  00279	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0027c	8b c2		 mov	 eax, edx
  0027e	c1 e8 08	 shr	 eax, 8
  00281	89 55 cc	 mov	 DWORD PTR $T7[ebp], edx
  00284	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  00287	85 f6		 test	 esi, esi
  00289	74 0e		 je	 SHORT $LN765@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  0028b	83 e0 01	 and	 eax, 1
  0028e	89 06		 mov	 DWORD PTR [esi], eax
  00290	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00293	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
  00296	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
$LN765@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00299	f7 45 cc 00 02
	00 00		 test	 DWORD PTR $T7[ebp], 512	; 00000200H
  002a0	74 1a		 je	 SHORT $LN39@inflate
  002a2	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002a5	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002a8	6a 02		 push	 2
  002aa	50		 push	 eax
  002ab	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002ae	ff 71 18	 push	 DWORD PTR [ecx+24]
  002b1	e8 00 00 00 00	 call	 _crc32@12
  002b6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002b9	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN39@inflate:

; 687  :             INITBITS();

  002bc	33 d2		 xor	 edx, edx

; 688  :             state->mode = TIME;

  002be	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
  002c4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  002c7	33 f6		 xor	 esi, esi

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  002c9	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002cb	83 fe 20	 cmp	 esi, 32			; 00000020H
  002ce	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  002d0	85 db		 test	 ebx, ebx
  002d2	0f 84 b0 12 00
	00		 je	 $LN952@inflate
  002d8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002db	8b ce		 mov	 ecx, esi
  002dd	d3 e0		 shl	 eax, cl
  002df	4b		 dec	 ebx
  002e0	03 d0		 add	 edx, eax
  002e2	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  002e5	47		 inc	 edi
  002e6	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  002e9	83 c6 08	 add	 esi, 8
  002ec	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  002ef	83 fe 20	 cmp	 esi, 32			; 00000020H
  002f2	72 dc		 jb	 SHORT $LL47@inflate
  002f4	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 691  :             if (state->head != Z_NULL)

  002f7	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  002fa	85 c0		 test	 eax, eax
  002fc	74 03		 je	 SHORT $LN362@inflate

; 692  :                 state->head->time = hold;

  002fe	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN362@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  00301	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00308	74 2d		 je	 SHORT $LN53@inflate
  0030a	8b c2		 mov	 eax, edx
  0030c	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0030f	c1 e8 08	 shr	 eax, 8
  00312	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00315	8b c2		 mov	 eax, edx
  00317	c1 e8 10	 shr	 eax, 16			; 00000010H
  0031a	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0031d	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00320	6a 04		 push	 4
  00322	c1 ea 18	 shr	 edx, 24			; 00000018H
  00325	50		 push	 eax
  00326	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  00329	ff 71 18	 push	 DWORD PTR [ecx+24]
  0032c	e8 00 00 00 00	 call	 _crc32@12
  00331	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00334	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN53@inflate:

; 694  :             INITBITS();

  00337	33 d2		 xor	 edx, edx

; 695  :             state->mode = OS;

  00339	c7 01 03 00 00
	00		 mov	 DWORD PTR [ecx], 3
  0033f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00342	33 f6		 xor	 esi, esi

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  00344	eb 0a		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00346	83 fe 10	 cmp	 esi, 16			; 00000010H
  00349	73 2c		 jae	 SHORT $LN58@inflate
  0034b	0f 1f 44 00 00	 npad	 5
$LL61@inflate:
  00350	85 db		 test	 ebx, ebx
  00352	0f 84 30 12 00
	00		 je	 $LN952@inflate
  00358	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0035b	8b ce		 mov	 ecx, esi
  0035d	d3 e0		 shl	 eax, cl
  0035f	4b		 dec	 ebx
  00360	03 d0		 add	 edx, eax
  00362	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00365	47		 inc	 edi
  00366	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00369	83 c6 08	 add	 esi, 8
  0036c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0036f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00372	72 dc		 jb	 SHORT $LL61@inflate
  00374	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 698  :             if (state->head != Z_NULL) {

  00377	8b 71 20	 mov	 esi, DWORD PTR [ecx+32]
  0037a	8b c2		 mov	 eax, edx
  0037c	c1 e8 08	 shr	 eax, 8
  0037f	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
  00382	85 f6		 test	 esi, esi
  00384	74 11		 je	 SHORT $LN766@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  00386	0f b6 c2	 movzx	 eax, dl
  00389	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 700  :                 state->head->os = (int)(hold >> 8);

  0038c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0038f	8b 75 cc	 mov	 esi, DWORD PTR $T9[ebp]
  00392	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00395	8b c6		 mov	 eax, esi
$LN766@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00397	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0039e	74 1a		 je	 SHORT $LN67@inflate
  003a0	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  003a3	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003a6	6a 02		 push	 2
  003a8	50		 push	 eax
  003a9	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003ac	ff 71 18	 push	 DWORD PTR [ecx+24]
  003af	e8 00 00 00 00	 call	 _crc32@12
  003b4	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003b7	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN67@inflate:

; 703  :             INITBITS();

  003ba	33 d2		 xor	 edx, edx

; 704  :             state->mode = EXLEN;

  003bc	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
  003c2	33 f6		 xor	 esi, esi
  003c4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003c7	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN368@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  003ca	f7 41 10 00 04
	00 00		 test	 DWORD PTR [ecx+16], 1024 ; 00000400H
  003d1	74 6d		 je	 SHORT $LN369@inflate

; 707  :                 NEEDBITS(16);

  003d3	83 fe 10	 cmp	 esi, 16			; 00000010H
  003d6	73 27		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  003d8	85 db		 test	 ebx, ebx
  003da	0f 84 a8 11 00
	00		 je	 $LN952@inflate
  003e0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  003e3	8b ce		 mov	 ecx, esi
  003e5	d3 e0		 shl	 eax, cl
  003e7	4b		 dec	 ebx
  003e8	03 d0		 add	 edx, eax
  003ea	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  003ed	47		 inc	 edi
  003ee	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003f1	83 c6 08	 add	 esi, 8
  003f4	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  003f7	83 fe 10	 cmp	 esi, 16			; 00000010H
  003fa	72 dc		 jb	 SHORT $LL75@inflate
  003fc	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 708  :                 state->length = (unsigned)(hold);
; 709  :                 if (state->head != Z_NULL)

  003ff	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00402	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  00405	85 c0		 test	 eax, eax
  00407	74 03		 je	 SHORT $LN372@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  00409	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN372@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  0040c	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00413	74 1d		 je	 SHORT $LN81@inflate
  00415	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00418	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0041b	6a 02		 push	 2
  0041d	c1 ea 08	 shr	 edx, 8
  00420	50		 push	 eax
  00421	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00424	ff 71 18	 push	 DWORD PTR [ecx+24]
  00427	e8 00 00 00 00	 call	 _crc32@12
  0042c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0042f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN81@inflate:

; 712  :                 INITBITS();

  00432	33 f6		 xor	 esi, esi
  00434	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0043b	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 713  :             }

  0043e	eb 0e		 jmp	 SHORT $LN374@inflate
$LN369@inflate:

; 714  :             else if (state->head != Z_NULL)

  00440	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00443	85 c0		 test	 eax, eax
  00445	74 07		 je	 SHORT $LN374@inflate

; 715  :                 state->head->extra = Z_NULL;

  00447	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN374@inflate:

; 716  :             state->mode = EXTRA;

  0044e	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN375@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  00454	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00457	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  0045c	0f 84 9a 00 00
	00		 je	 $LN381@inflate

; 719  :                 copy = state->length;

  00462	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]

; 720  :                 if (copy > have) copy = have;
; 721  :                 if (copy) {

  00465	39 59 40	 cmp	 DWORD PTR [ecx+64], ebx
  00468	89 55 cc	 mov	 DWORD PTR $T6[ebp], edx
  0046b	8b d3		 mov	 edx, ebx
  0046d	0f 46 51 40	 cmovbe	 edx, DWORD PTR [ecx+64]
  00471	89 55 d4	 mov	 DWORD PTR tv5581[ebp], edx
  00474	85 d2		 test	 edx, edx
  00476	0f 84 75 00 00
	00		 je	 $LN959@inflate

; 722  :                     if (state->head != Z_NULL &&

  0047c	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00480	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00483	74 45		 je	 SHORT $LN379@inflate
  00485	8b 59 20	 mov	 ebx, DWORD PTR [ecx+32]
  00488	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  0048b	85 db		 test	 ebx, ebx
  0048d	89 5d ec	 mov	 DWORD PTR tv5455[ebp], ebx
  00490	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00493	74 35		 je	 SHORT $LN379@inflate

; 723  :                         state->head->extra != Z_NULL) {
; 724  :                         len = state->head->extra_len - state->length;

  00495	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00498	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0049b	2b 45 cc	 sub	 eax, DWORD PTR $T6[ebp]

; 725  :                         zmemcpy(state->head->extra + len, next,

  0049e	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  004a1	89 45 cc	 mov	 DWORD PTR _len$2$[ebp], eax
  004a4	03 c2		 add	 eax, edx
  004a6	3b c1		 cmp	 eax, ecx
  004a8	8b 45 cc	 mov	 eax, DWORD PTR _len$2$[ebp]
  004ab	76 04		 jbe	 SHORT $LN516@inflate
  004ad	2b c8		 sub	 ecx, eax
  004af	eb 02		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  004b1	8b ca		 mov	 ecx, edx
$LN517@inflate:
  004b3	03 45 ec	 add	 eax, DWORD PTR tv5455[ebp]
  004b6	51		 push	 ecx
  004b7	57		 push	 edi
  004b8	50		 push	 eax
  004b9	e8 00 00 00 00	 call	 _memcpy
  004be	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c4	8b 55 d4	 mov	 edx, DWORD PTR tv5581[ebp]
  004c7	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
$LN379@inflate:

; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);
; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  004ca	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  004cf	74 10		 je	 SHORT $LN380@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  004d1	52		 push	 edx
  004d2	57		 push	 edi
  004d3	ff 71 18	 push	 DWORD PTR [ecx+24]
  004d6	e8 00 00 00 00	 call	 _crc32@12
  004db	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004de	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN380@inflate:

; 731  :                     have -= copy;

  004e1	8b 45 d4	 mov	 eax, DWORD PTR tv5581[ebp]
  004e4	2b d8		 sub	 ebx, eax

; 732  :                     next += copy;

  004e6	03 f8		 add	 edi, eax
  004e8	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx

; 733  :                     state->length -= copy;

  004eb	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  004ee	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
$LN959@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  004f1	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  004f4	85 c0		 test	 eax, eax
  004f6	0f 85 8c 10 00
	00		 jne	 $LN952@inflate
$LN381@inflate:

; 736  :             }
; 737  :             state->length = 0;

  004fc	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 738  :             state->mode = NAME;

  00503	c7 01 06 00 00
	00		 mov	 DWORD PTR [ecx], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  00509	f7 41 10 00 08
	00 00		 test	 DWORD PTR [ecx+16], 2048 ; 00000800H
  00510	0f 84 7f 00 00
	00		 je	 $LN383@inflate

; 741  :                 if (have == 0) goto inf_leave;

  00516	85 db		 test	 ebx, ebx
  00518	0f 84 6a 10 00
	00		 je	 $LN952@inflate

; 742  :                 copy = 0;

  0051e	33 d2		 xor	 edx, edx
$LL88@inflate:

; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);

  00520	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  00523	42		 inc	 edx
  00524	88 45 ff	 mov	 BYTE PTR tv5580[ebp], al

; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&

  00527	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0052a	85 c0		 test	 eax, eax
  0052c	74 23		 je	 SHORT $LN86@inflate
  0052e	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00531	89 75 cc	 mov	 DWORD PTR tv5453[ebp], esi
  00534	85 f6		 test	 esi, esi
  00536	74 19		 je	 SHORT $LN86@inflate
  00538	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  0053b	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  0053e	73 11		 jae	 SHORT $LN86@inflate

; 747  :                             state->length < state->head->name_max)
; 748  :                         state->head->name[state->length++] = len;

  00540	8a 5d ff	 mov	 bl, BYTE PTR tv5580[ebp]
  00543	8b c6		 mov	 eax, esi
  00545	8b 75 cc	 mov	 esi, DWORD PTR tv5453[ebp]
  00548	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  0054b	ff 41 40	 inc	 DWORD PTR [ecx+64]
  0054e	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 749  :                 } while (len && copy < have);

  00551	8a 45 ff	 mov	 al, BYTE PTR tv5580[ebp]
  00554	84 c0		 test	 al, al
  00556	74 04		 je	 SHORT $LN387@inflate
  00558	3b d3		 cmp	 edx, ebx
  0055a	72 c4		 jb	 SHORT $LL88@inflate
$LN387@inflate:

; 750  :                 if (state->flags & 0x0200)

  0055c	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  00563	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00566	89 55 c4	 mov	 DWORD PTR _copy$1$[ebp], edx
  00569	74 16		 je	 SHORT $LN388@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  0056b	52		 push	 edx
  0056c	57		 push	 edi
  0056d	ff 71 18	 push	 DWORD PTR [ecx+24]
  00570	e8 00 00 00 00	 call	 _crc32@12
  00575	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00578	8b 55 c4	 mov	 edx, DWORD PTR _copy$1$[ebp]
  0057b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0057e	8a 45 ff	 mov	 al, BYTE PTR tv5580[ebp]
$LN388@inflate:

; 752  :                 have -= copy;

  00581	2b da		 sub	 ebx, edx

; 753  :                 next += copy;

  00583	03 fa		 add	 edi, edx
  00585	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00588	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 754  :                 if (len) goto inf_leave;

  0058b	84 c0		 test	 al, al
  0058d	0f 85 f5 0f 00
	00		 jne	 $LN952@inflate

; 755  :             }

  00593	eb 0e		 jmp	 SHORT $LN390@inflate
$LN383@inflate:

; 756  :             else if (state->head != Z_NULL)

  00595	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  00598	85 c0		 test	 eax, eax
  0059a	74 07		 je	 SHORT $LN390@inflate

; 757  :                 state->head->name = Z_NULL;

  0059c	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN390@inflate:

; 758  :             state->length = 0;

  005a3	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 759  :             state->mode = COMMENT;

  005aa	c7 01 07 00 00
	00		 mov	 DWORD PTR [ecx], 7
$LN391@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  005b0	f7 41 10 00 10
	00 00		 test	 DWORD PTR [ecx+16], 4096 ; 00001000H
  005b7	0f 84 7f 00 00
	00		 je	 $LN392@inflate

; 762  :                 if (have == 0) goto inf_leave;

  005bd	85 db		 test	 ebx, ebx
  005bf	0f 84 c3 0f 00
	00		 je	 $LN952@inflate

; 763  :                 copy = 0;

  005c5	33 d2		 xor	 edx, edx
$LL91@inflate:

; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  005c7	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  005ca	42		 inc	 edx
  005cb	88 45 ff	 mov	 BYTE PTR tv5579[ebp], al

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&

  005ce	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  005d1	85 c0		 test	 eax, eax
  005d3	74 23		 je	 SHORT $LN89@inflate
  005d5	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  005d8	89 75 cc	 mov	 DWORD PTR tv5452[ebp], esi
  005db	85 f6		 test	 esi, esi
  005dd	74 19		 je	 SHORT $LN89@inflate
  005df	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  005e2	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  005e5	73 11		 jae	 SHORT $LN89@inflate

; 768  :                             state->length < state->head->comm_max)
; 769  :                         state->head->comment[state->length++] = len;

  005e7	8a 5d ff	 mov	 bl, BYTE PTR tv5579[ebp]
  005ea	8b c6		 mov	 eax, esi
  005ec	8b 75 cc	 mov	 esi, DWORD PTR tv5452[ebp]
  005ef	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  005f2	ff 41 40	 inc	 DWORD PTR [ecx+64]
  005f5	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 770  :                 } while (len && copy < have);

  005f8	8a 45 ff	 mov	 al, BYTE PTR tv5579[ebp]
  005fb	84 c0		 test	 al, al
  005fd	74 04		 je	 SHORT $LN396@inflate
  005ff	3b d3		 cmp	 edx, ebx
  00601	72 c4		 jb	 SHORT $LL91@inflate
$LN396@inflate:

; 771  :                 if (state->flags & 0x0200)

  00603	f7 41 10 00 02
	00 00		 test	 DWORD PTR [ecx+16], 512	; 00000200H
  0060a	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  0060d	89 55 c4	 mov	 DWORD PTR _copy$2$[ebp], edx
  00610	74 16		 je	 SHORT $LN397@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  00612	52		 push	 edx
  00613	57		 push	 edi
  00614	ff 71 18	 push	 DWORD PTR [ecx+24]
  00617	e8 00 00 00 00	 call	 _crc32@12
  0061c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0061f	8b 55 c4	 mov	 edx, DWORD PTR _copy$2$[ebp]
  00622	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00625	8a 45 ff	 mov	 al, BYTE PTR tv5579[ebp]
$LN397@inflate:

; 773  :                 have -= copy;

  00628	2b da		 sub	 ebx, edx

; 774  :                 next += copy;

  0062a	03 fa		 add	 edi, edx
  0062c	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0062f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 775  :                 if (len) goto inf_leave;

  00632	84 c0		 test	 al, al
  00634	0f 85 4e 0f 00
	00		 jne	 $LN952@inflate

; 776  :             }

  0063a	eb 0e		 jmp	 SHORT $LN399@inflate
$LN392@inflate:

; 777  :             else if (state->head != Z_NULL)

  0063c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0063f	85 c0		 test	 eax, eax
  00641	74 07		 je	 SHORT $LN399@inflate

; 778  :                 state->head->comment = Z_NULL;

  00643	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN399@inflate:
  0064a	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 779  :             state->mode = HCRC;

  0064d	c7 01 08 00 00
	00		 mov	 DWORD PTR [ecx], 8
$LN400@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00653	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00656	89 45 c4	 mov	 DWORD PTR tv5173[ebp], eax
  00659	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0065e	74 58		 je	 SHORT $LN101@inflate

; 782  :                 NEEDBITS(16);

  00660	83 fe 10	 cmp	 esi, 16			; 00000010H
  00663	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00665	85 db		 test	 ebx, ebx
  00667	0f 84 1b 0f 00
	00		 je	 $LN952@inflate
  0066d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00670	8b ce		 mov	 ecx, esi
  00672	d3 e0		 shl	 eax, cl
  00674	83 c6 08	 add	 esi, 8
  00677	4b		 dec	 ebx
  00678	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0067b	03 d0		 add	 edx, eax
  0067d	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00680	47		 inc	 edi
  00681	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00684	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00687	83 fe 10	 cmp	 esi, 16			; 00000010H
  0068a	72 d9		 jb	 SHORT $LL95@inflate
  0068c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 783  :                 if (hold != (state->check & 0xffff)) {

  0068f	0f b7 41 18	 movzx	 eax, WORD PTR [ecx+24]
  00693	3b d0		 cmp	 edx, eax
  00695	74 15		 je	 SHORT $LN102@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  00697	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0069a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  006a1	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  006a7	e9 0f 0a 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 785  :                     state->mode = BAD;
; 786  :                     break;
; 787  :                 }
; 788  :                 INITBITS();

  006ac	33 f6		 xor	 esi, esi
  006ae	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  006b5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  006b8	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  006bb	85 c0		 test	 eax, eax
  006bd	74 16		 je	 SHORT $LN404@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006bf	8b 55 c4	 mov	 edx, DWORD PTR tv5173[ebp]
  006c2	c1 fa 09	 sar	 edx, 9
  006c5	83 e2 01	 and	 edx, 1
  006c8	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 792  :                 state->head->done = 1;

  006cb	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  006ce	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN404@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  006d5	6a 00		 push	 0
  006d7	6a 00		 push	 0
  006d9	6a 00		 push	 0
  006db	e8 00 00 00 00	 call	 _crc32@12
  006e0	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006e3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  006e6	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  006e9	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 795  :             state->mode = TYPE;
; 796  :             break;

  006ec	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  006ef	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
  006f5	e9 c1 09 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  006fa	83 fe 20	 cmp	 esi, 32			; 00000020H
  006fd	73 25		 jae	 SHORT $LN103@inflate
  006ff	90		 npad	 1
$LL106@inflate:
  00700	85 db		 test	 ebx, ebx
  00702	0f 84 80 0e 00
	00		 je	 $LN952@inflate
  00708	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0070b	8b ce		 mov	 ecx, esi
  0070d	d3 e0		 shl	 eax, cl
  0070f	4b		 dec	 ebx
  00710	03 d0		 add	 edx, eax
  00712	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00715	47		 inc	 edi
  00716	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00719	83 c6 08	 add	 esi, 8
  0071c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0071f	83 fe 20	 cmp	 esi, 32			; 00000020H
  00722	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 800  :             strm->adler = state->check = REVERSE(hold);

  00724	8b ca		 mov	 ecx, edx
  00726	8b c2		 mov	 eax, edx
  00728	c1 e0 10	 shl	 eax, 16			; 00000010H
  0072b	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00731	03 c8		 add	 ecx, eax
  00733	8b c2		 mov	 eax, edx
  00735	c1 e8 08	 shr	 eax, 8
  00738	c1 e1 08	 shl	 ecx, 8
  0073b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00740	c1 ea 18	 shr	 edx, 24			; 00000018H
  00743	03 c1		 add	 eax, ecx
  00745	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00748	03 c2		 add	 eax, edx
  0074a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0074d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00750	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 801  :             INITBITS();

  00753	33 d2		 xor	 edx, edx
  00755	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00758	33 f6		 xor	 esi, esi

; 802  :             state->mode = DICT;

  0075a	c7 01 0a 00 00
	00		 mov	 DWORD PTR [ecx], 10	; 0000000aH
$LN407@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  00760	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00764	0f 84 cb 0d 00
	00		 je	 $LN595@inflate

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0076a	6a 00		 push	 0
  0076c	6a 00		 push	 0
  0076e	6a 00		 push	 0
  00770	e8 00 00 00 00	 call	 _adler32@12
  00775	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00778	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0077b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0077e	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00781	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 809  :             state->mode = TYPE;

  00784	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH
$LN409@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  0078a	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  0078d	83 f8 05	 cmp	 eax, 5
  00790	0f 84 f2 0d 00
	00		 je	 $LN952@inflate
  00796	83 f8 06	 cmp	 eax, 6
  00799	0f 84 e9 0d 00
	00		 je	 $LN952@inflate
$LN410@inflate:

; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  0079f	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  007a3	74 1d		 je	 SHORT $LN122@inflate

; 814  :                 BYTEBITS();

  007a5	8b ce		 mov	 ecx, esi
  007a7	83 e1 07	 and	 ecx, 7
  007aa	d3 ea		 shr	 edx, cl
  007ac	2b f1		 sub	 esi, ecx

; 815  :                 state->mode = CHECK;

  007ae	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007b1	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007b4	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  007b7	c7 01 1a 00 00
	00		 mov	 DWORD PTR [ecx], 26	; 0000001aH

; 816  :                 break;

  007bd	e9 f9 08 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  007c2	83 fe 03	 cmp	 esi, 3
  007c5	73 27		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  007c7	85 db		 test	 ebx, ebx
  007c9	0f 84 b9 0d 00
	00		 je	 $LN952@inflate
  007cf	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  007d2	8b ce		 mov	 ecx, esi
  007d4	d3 e0		 shl	 eax, cl
  007d6	4b		 dec	 ebx
  007d7	03 d0		 add	 edx, eax
  007d9	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  007dc	47		 inc	 edi
  007dd	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007e0	83 c6 08	 add	 esi, 8
  007e3	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  007e6	83 fe 03	 cmp	 esi, 3
  007e9	72 dc		 jb	 SHORT $LL123@inflate
  007eb	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 819  :             state->last = BITS(1);

  007ee	8b c2		 mov	 eax, edx

; 820  :             DROPBITS(1);

  007f0	d1 ea		 shr	 edx, 1
  007f2	83 e0 01	 and	 eax, 1
  007f5	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  007f8	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 821  :             switch (BITS(2)) {

  007fb	8b c2		 mov	 eax, edx
  007fd	83 e0 03	 and	 eax, 3
  00800	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN1002@inflate[eax*4]
$LN415@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  00807	c1 ea 02	 shr	 edx, 2
  0080a	83 ee 03	 sub	 esi, 3
  0080d	c7 01 0d 00 00
	00		 mov	 DWORD PTR [ecx], 13	; 0000000dH
  00813	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00816	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  00819	e9 9d 08 00 00	 jmp	 $LN8@inflate
$LN416@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;
; 826  :                 break;
; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  0081e	e8 00 00 00 00	 call	 _fixedtables

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */
; 832  :                 if (flush == Z_TREES) {

  00823	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00827	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0082a	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00830	0f 84 2a 0d 00
	00		 je	 $LN596@inflate

; 835  :                 }
; 836  :                 break;

  00836	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 845  :             }
; 846  :             DROPBITS(2);

  00839	c1 ea 02	 shr	 edx, 2
  0083c	83 ee 03	 sub	 esi, 3
  0083f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00842	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  00845	e9 71 08 00 00	 jmp	 $LN8@inflate
$LN418@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  0084a	c1 ea 02	 shr	 edx, 2
  0084d	83 ee 03	 sub	 esi, 3
  00850	c7 01 10 00 00
	00		 mov	 DWORD PTR [ecx], 16	; 00000010H
  00856	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00859	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  0085c	e9 5a 08 00 00	 jmp	 $LN8@inflate
$LN419@inflate:

; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;
; 841  :                 break;
; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  00861	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00864	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 844  :                 state->mode = BAD;

  0086b	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN138@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  00871	c1 ea 02	 shr	 edx, 2
  00874	83 ee 03	 sub	 esi, 3
  00877	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0087a	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 847  :             break;

  0087d	e9 39 08 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  00882	8b ce		 mov	 ecx, esi
  00884	83 e1 07	 and	 ecx, 7
  00887	2b f1		 sub	 esi, ecx
  00889	d3 ea		 shr	 edx, cl
  0088b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0088e	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 850  :             NEEDBITS(32);

  00891	83 fe 20	 cmp	 esi, 32			; 00000020H
  00894	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00896	85 db		 test	 ebx, ebx
  00898	0f 84 ea 0c 00
	00		 je	 $LN952@inflate
  0089e	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  008a1	8b ce		 mov	 ecx, esi
  008a3	d3 e0		 shl	 eax, cl
  008a5	83 c6 08	 add	 esi, 8
  008a8	4b		 dec	 ebx
  008a9	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  008ac	03 d0		 add	 edx, eax
  008ae	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  008b1	47		 inc	 edi
  008b2	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008b5	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  008b8	83 fe 20	 cmp	 esi, 32			; 00000020H
  008bb	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  008bd	8b c2		 mov	 eax, edx
  008bf	0f b7 ca	 movzx	 ecx, dx
  008c2	f7 d0		 not	 eax
  008c4	89 4d c4	 mov	 DWORD PTR tv5450[ebp], ecx
  008c7	c1 e8 10	 shr	 eax, 16			; 00000010H
  008ca	3b c8		 cmp	 ecx, eax
  008cc	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  008cf	74 15		 je	 SHORT $LN422@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  008d1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  008d4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  008db	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  008e1	e9 d5 07 00 00	 jmp	 $LN8@inflate
$LN422@inflate:

; 853  :                 state->mode = BAD;
; 854  :                 break;
; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  008e6	8b 45 c4	 mov	 eax, DWORD PTR tv5450[ebp]

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  008e9	33 d2		 xor	 edx, edx
  008eb	33 f6		 xor	 esi, esi
  008ed	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 860  :             state->mode = COPY_;
; 861  :             if (flush == Z_TREES) goto inf_leave;

  008f0	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008f4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008f7	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  008fa	c7 01 0e 00 00
	00		 mov	 DWORD PTR [ecx], 14	; 0000000eH
  00900	0f 84 82 0c 00
	00		 je	 $LN952@inflate
$LN423@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  00906	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH
$LN425@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  0090c	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0090f	89 45 c4	 mov	 DWORD PTR _copy$3$[ebp], eax

; 866  :             if (copy) {

  00912	85 c0		 test	 eax, eax
  00914	74 4a		 je	 SHORT $LN426@inflate

; 867  :                 if (copy > have) copy = have;
; 868  :                 if (copy > left) copy = left;

  00916	39 5d c4	 cmp	 DWORD PTR _copy$3$[ebp], ebx
  00919	8b c3		 mov	 eax, ebx

; 869  :                 if (copy == 0) goto inf_leave;

  0091b	8b 4d e0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  0091e	0f 46 45 c4	 cmovbe	 eax, DWORD PTR _copy$3$[ebp]
  00922	3b c1		 cmp	 eax, ecx
  00924	0f 46 c8	 cmovbe	 ecx, eax
  00927	89 4d c4	 mov	 DWORD PTR tv5577[ebp], ecx
  0092a	85 c9		 test	 ecx, ecx
  0092c	0f 84 56 0c 00
	00		 je	 $LN952@inflate

; 870  :                 zmemcpy(put, next, copy);

  00932	51		 push	 ecx
  00933	57		 push	 edi
  00934	ff 75 dc	 push	 DWORD PTR _put$1$[ebp]
  00937	e8 00 00 00 00	 call	 _memcpy

; 871  :                 have -= copy;

  0093c	8b 45 c4	 mov	 eax, DWORD PTR tv5577[ebp]
  0093f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 872  :                 next += copy;
; 873  :                 left -= copy;
; 874  :                 put += copy;
; 875  :                 state->length -= copy;

  00942	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00945	2b d8		 sub	 ebx, eax
  00947	29 45 e0	 sub	 DWORD PTR _left$1$[ebp], eax
  0094a	03 f8		 add	 edi, eax
  0094c	01 45 dc	 add	 DWORD PTR _put$1$[ebp], eax

; 876  :                 break;

  0094f	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00952	29 41 40	 sub	 DWORD PTR [ecx+64], eax
  00955	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00958	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0095b	e9 5b 07 00 00	 jmp	 $LN8@inflate
$LN426@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;

  00960	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 880  :             break;

  00966	e9 50 07 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  0096b	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0096e	73 24		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00970	85 db		 test	 ebx, ebx
  00972	0f 84 10 0c 00
	00		 je	 $LN952@inflate
  00978	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0097b	8b ce		 mov	 ecx, esi
  0097d	d3 e0		 shl	 eax, cl
  0097f	4b		 dec	 ebx
  00980	03 d0		 add	 edx, eax
  00982	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00985	47		 inc	 edi
  00986	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00989	83 c6 08	 add	 esi, 8
  0098c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0098f	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00992	72 dc		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 883  :             state->nlen = BITS(5) + 257;

  00994	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00997	8b ca		 mov	 ecx, edx

; 884  :             DROPBITS(5);

  00999	c1 ea 05	 shr	 edx, 5
  0099c	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 885  :             state->ndist = BITS(5) + 1;

  0099f	8b fa		 mov	 edi, edx
  009a1	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  009a7	83 e7 1f	 and	 edi, 31			; 0000001fH

; 886  :             DROPBITS(5);

  009aa	c1 ea 05	 shr	 edx, 5
  009ad	47		 inc	 edi
  009ae	89 48 60	 mov	 DWORD PTR [eax+96], ecx
  009b1	89 78 64	 mov	 DWORD PTR [eax+100], edi

; 887  :             state->ncode = BITS(4) + 4;
; 888  :             DROPBITS(4);

  009b4	83 ee 0e	 sub	 esi, 14			; 0000000eH
  009b7	89 7d c4	 mov	 DWORD PTR tv5608[ebp], edi
  009ba	8b c2		 mov	 eax, edx
  009bc	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  009bf	83 e0 0f	 and	 eax, 15			; 0000000fH
  009c2	83 c0 04	 add	 eax, 4
  009c5	c1 ea 04	 shr	 edx, 4
  009c8	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  009cb	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  009ce	89 47 5c	 mov	 DWORD PTR [edi+92], eax

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  009d1	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  009d4	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  009da	0f 87 02 01 00
	00		 ja	 $LN433@inflate
  009e0	83 7d c4 1e	 cmp	 DWORD PTR tv5608[ebp], 30 ; 0000001eH
  009e4	0f 87 f8 00 00
	00		 ja	 $LN433@inflate

; 893  :                 break;
; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  009ea	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009ed	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 898  :             state->mode = LENLENS;

  009f4	c7 01 11 00 00
	00		 mov	 DWORD PTR [ecx], 17	; 00000011H
$LN539@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  009fa	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  009fd	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a00	73 60		 jae	 SHORT $LN541@inflate
$LL170@inflate:

; 901  :                 NEEDBITS(3);

  00a02	83 fe 03	 cmp	 esi, 3
  00a05	73 24		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00a07	85 db		 test	 ebx, ebx
  00a09	0f 84 79 0b 00
	00		 je	 $LN952@inflate
  00a0f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a12	8b ce		 mov	 ecx, esi
  00a14	d3 e0		 shl	 eax, cl
  00a16	4b		 dec	 ebx
  00a17	03 d0		 add	 edx, eax
  00a19	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a1c	47		 inc	 edi
  00a1d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a20	83 c6 08	 add	 esi, 8
  00a23	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00a26	83 fe 03	 cmp	 esi, 3
  00a29	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a2b	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00a2e	8b ca		 mov	 ecx, edx
  00a30	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00a33	83 e1 07	 and	 ecx, 7

; 903  :                 DROPBITS(3);

  00a36	c1 ea 03	 shr	 edx, 3
  00a39	83 ee 03	 sub	 esi, 3
  00a3c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a3f	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00a42	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a45	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a4d	66 89 4c 47 70	 mov	 WORD PTR [edi+eax*2+112], cx
  00a52	8b cf		 mov	 ecx, edi
  00a54	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00a57	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a5a	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a5d	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00a60	72 a0		 jb	 SHORT $LL170@inflate
$LN541@inflate:

; 904  :             }
; 905  :             while (state->have < 19)

  00a62	83 f8 13	 cmp	 eax, 19			; 00000013H
  00a65	73 24		 jae	 SHORT $LN184@inflate
  00a67	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL183@inflate:

; 906  :                 state->lens[order[state->have++]] = 0;

  00a70	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00a73	33 d2		 xor	 edx, edx
  00a75	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00a7d	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00a82	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00a85	83 79 68 13	 cmp	 DWORD PTR [ecx+104], 19	; 00000013H
  00a89	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 907  :             state->next = state->codes;

  00a8b	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]

; 908  :             state->lencode = (code const FAR *)(state->next);
; 909  :             state->lenbits = 7;

  00a91	c7 41 54 07 00
	00 00		 mov	 DWORD PTR [ecx+84], 7
  00a98	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]
  00a9b	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00a9e	89 02		 mov	 DWORD PTR [edx], eax
  00aa0	83 c1 54	 add	 ecx, 84			; 00000054H

; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00aa3	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00aa6	05 f0 02 00 00	 add	 eax, 752		; 000002f0H
  00aab	50		 push	 eax
  00aac	51		 push	 ecx
  00aad	52		 push	 edx
  00aae	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00ab1	33 c9		 xor	 ecx, ecx
  00ab3	6a 13		 push	 19			; 00000013H
  00ab5	8d 52 70	 lea	 edx, DWORD PTR [edx+112]
  00ab8	e8 00 00 00 00	 call	 _inflate_table

; 911  :                                 &(state->lenbits), state->work);
; 912  :             if (ret) {

  00abd	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ac0	83 c4 10	 add	 esp, 16			; 00000010H
  00ac3	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00ac6	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ac9	85 c0		 test	 eax, eax
  00acb	74 2d		 je	 SHORT $LN436@inflate

; 913  :                 strm->msg = (char *)"invalid code lengths set";

  00acd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ad0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00ad7	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00add	e9 d9 05 00 00	 jmp	 $LN8@inflate
$LN433@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  00ae2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 892  :                 state->mode = BAD;

  00ae5	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ae8	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00aef	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00af5	e9 c1 05 00 00	 jmp	 $LN8@inflate
$LN436@inflate:

; 914  :                 state->mode = BAD;
; 915  :                 break;
; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  00afa	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0

; 919  :             state->mode = CODELENS;

  00b01	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
  00b07	c7 45 cc 12 00
	00 00		 mov	 DWORD PTR $T5[ebp], 18	; 00000012H
$LN542@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00b0e	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00b11	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00b14	39 41 68	 cmp	 DWORD PTR [ecx+104], eax
  00b17	0f 83 ad 02 00
	00		 jae	 $LN958@inflate
  00b1d	0f 1f 00	 npad	 3
$LL185@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  00b20	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00b23	b8 01 00 00 00	 mov	 eax, 1
  00b28	d3 e0		 shl	 eax, cl
  00b2a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00b2d	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b30	89 4d e8	 mov	 DWORD PTR tv5446[ebp], ecx
  00b33	23 ca		 and	 ecx, edx
  00b35	8b 78 4c	 mov	 edi, DWORD PTR [eax+76]
  00b38	89 7d c0	 mov	 DWORD PTR tv5490[ebp], edi
  00b3b	8b 04 8f	 mov	 eax, DWORD PTR [edi+ecx*4]
  00b3e	8b c8		 mov	 ecx, eax
  00b40	c1 e9 08	 shr	 ecx, 8
  00b43	8b f8		 mov	 edi, eax
  00b45	c1 ef 10	 shr	 edi, 16			; 00000010H
  00b48	89 4d d4	 mov	 DWORD PTR $T11[ebp], ecx
  00b4b	0f b6 c9	 movzx	 ecx, cl
  00b4e	89 7d cc	 mov	 DWORD PTR $T4[ebp], edi

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  00b51	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00b54	89 45 c4	 mov	 DWORD PTR _here$[ebp], eax
  00b57	3b ce		 cmp	 ecx, esi
  00b59	76 4c		 jbe	 SHORT $LN666@inflate
  00b5b	0f 1f 44 00 00	 npad	 5
$LL187@inflate:

; 925  :                     PULLBYTE();

  00b60	85 db		 test	 ebx, ebx
  00b62	0f 84 20 0a 00
	00		 je	 $LN952@inflate
  00b68	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00b6b	8b ce		 mov	 ecx, esi
  00b6d	d3 e0		 shl	 eax, cl
  00b6f	4b		 dec	 ebx
  00b70	8b 4d c0	 mov	 ecx, DWORD PTR tv5490[ebp]
  00b73	03 d0		 add	 edx, eax
  00b75	8b 45 e8	 mov	 eax, DWORD PTR tv5446[ebp]
  00b78	47		 inc	 edi
  00b79	23 c2		 and	 eax, edx
  00b7b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00b7e	83 c6 08	 add	 esi, 8
  00b81	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00b84	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00b87	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00b8a	8b c8		 mov	 ecx, eax
  00b8c	c1 e9 08	 shr	 ecx, 8
  00b8f	8b d8		 mov	 ebx, eax
  00b91	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00b94	89 4d d4	 mov	 DWORD PTR $T11[ebp], ecx
  00b97	0f b6 c9	 movzx	 ecx, cl
  00b9a	89 5d cc	 mov	 DWORD PTR $T4[ebp], ebx
  00b9d	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00ba0	89 45 c4	 mov	 DWORD PTR _here$[ebp], eax
  00ba3	3b ce		 cmp	 ecx, esi
  00ba5	77 b9		 ja	 SHORT $LL187@inflate
$LN666@inflate:

; 926  :                 }
; 927  :                 if (here.val < 16) {

  00ba7	8b 7d cc	 mov	 edi, DWORD PTR $T4[ebp]
  00baa	8b 4d d4	 mov	 ecx, DWORD PTR $T11[ebp]
  00bad	0f b7 ff	 movzx	 edi, di
  00bb0	89 7d cc	 mov	 DWORD PTR tv5424[ebp], edi
  00bb3	0f b7 ff	 movzx	 edi, di
  00bb6	89 7d c0	 mov	 DWORD PTR tv5423[ebp], edi
  00bb9	83 ff 10	 cmp	 edi, 16			; 00000010H
  00bbc	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00bbf	89 4d d4	 mov	 DWORD PTR $T10[ebp], ecx
  00bc2	73 60		 jae	 SHORT $LN440@inflate

; 928  :                     NEEDBITS(here.bits);

  00bc4	0f b6 c9	 movzx	 ecx, cl
  00bc7	89 4d c0	 mov	 DWORD PTR tv5484[ebp], ecx
  00bca	3b f1		 cmp	 esi, ecx
  00bcc	73 27		 jae	 SHORT $LN193@inflate
  00bce	66 90		 npad	 2
$LL196@inflate:
  00bd0	85 db		 test	 ebx, ebx
  00bd2	0f 84 b0 09 00
	00		 je	 $LN952@inflate
  00bd8	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00bdb	8b ce		 mov	 ecx, esi
  00bdd	d3 e2		 shl	 edx, cl
  00bdf	4b		 dec	 ebx
  00be0	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00be3	47		 inc	 edi
  00be4	83 c6 08	 add	 esi, 8
  00be7	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00bea	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00bed	3b 75 c0	 cmp	 esi, DWORD PTR tv5484[ebp]
  00bf0	72 de		 jb	 SHORT $LL196@inflate
  00bf2	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN193@inflate:

; 929  :                     DROPBITS(here.bits);
; 930  :                     state->lens[state->have++] = here.val;

  00bf5	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00bf8	0f b6 cc	 movzx	 ecx, ah
  00bfb	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bfe	2b f1		 sub	 esi, ecx
  00c00	d3 ea		 shr	 edx, cl
  00c02	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c05	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c08	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00c0b	66 8b 45 c6	 mov	 ax, WORD PTR _here$[ebp+2]
  00c0f	66 89 44 4f 70	 mov	 WORD PTR [edi+ecx*2+112], ax
  00c14	8b cf		 mov	 ecx, edi
  00c16	ff 41 68	 inc	 DWORD PTR [ecx+104]
  00c19	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00c1c	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax

; 931  :                 }

  00c1f	e9 7b 01 00 00	 jmp	 $LN993@inflate
$LN440@inflate:

; 932  :                 else {
; 933  :                     if (here.val == 16) {

  00c24	66 83 7d c0 10	 cmp	 WORD PTR tv5423[ebp], 16 ; 00000010H
  00c29	8b 4d d4	 mov	 ecx, DWORD PTR $T10[ebp]
  00c2c	0f b6 c9	 movzx	 ecx, cl
  00c2f	89 4d d4	 mov	 DWORD PTR tv5605[ebp], ecx
  00c32	75 71		 jne	 SHORT $LN443@inflate

; 934  :                         NEEDBITS(here.bits + 2);

  00c34	83 c1 02	 add	 ecx, 2
  00c37	3b f1		 cmp	 esi, ecx
  00c39	73 2f		 jae	 SHORT $LN204@inflate
  00c3b	0f 1f 44 00 00	 npad	 5
$LL207@inflate:
  00c40	85 db		 test	 ebx, ebx
  00c42	0f 84 40 09 00
	00		 je	 $LN952@inflate
  00c48	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c4b	8b ce		 mov	 ecx, esi
  00c4d	d3 e2		 shl	 edx, cl
  00c4f	4b		 dec	 ebx
  00c50	8b 4d d4	 mov	 ecx, DWORD PTR tv5605[ebp]
  00c53	47		 inc	 edi
  00c54	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00c57	83 c6 08	 add	 esi, 8
  00c5a	83 c1 02	 add	 ecx, 2
  00c5d	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c60	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00c63	3b f1		 cmp	 esi, ecx
  00c65	72 d9		 jb	 SHORT $LL207@inflate
  00c67	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN204@inflate:

; 935  :                         DROPBITS(here.bits);

  00c6a	0f b6 cc	 movzx	 ecx, ah
  00c6d	d3 ea		 shr	 edx, cl
  00c6f	2b f1		 sub	 esi, ecx

; 936  :                         if (state->have == 0) {

  00c71	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c74	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c77	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c7a	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  00c7e	0f 84 31 01 00
	00		 je	 $LN576@inflate

; 937  :                             strm->msg = (char *)"invalid bit length repeat";
; 938  :                             state->mode = BAD;
; 939  :                             break;
; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];
; 942  :                         copy = 3 + BITS(2);
; 943  :                         DROPBITS(2);

  00c84	8b 79 68	 mov	 edi, DWORD PTR [ecx+104]
  00c87	8b c2		 mov	 eax, edx
  00c89	83 e0 03	 and	 eax, 3
  00c8c	c1 ea 02	 shr	 edx, 2
  00c8f	83 c0 03	 add	 eax, 3
  00c92	83 ee 02	 sub	 esi, 2
  00c95	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00c98	0f b7 7c 79 6e	 movzx	 edi, WORD PTR [ecx+edi*2+110]
  00c9d	89 7d cc	 mov	 DWORD PTR $T8[ebp], edi

; 944  :                     }

  00ca0	e9 ae 00 00 00	 jmp	 $LN994@inflate
$LN443@inflate:

; 945  :                     else if (here.val == 17) {

  00ca5	66 83 7d cc 11	 cmp	 WORD PTR tv5424[ebp], 17 ; 00000011H
  00caa	75 4b		 jne	 SHORT $LN234@inflate

; 946  :                         NEEDBITS(here.bits + 3);

  00cac	83 c1 03	 add	 ecx, 3
  00caf	3b f1		 cmp	 esi, ecx
  00cb1	73 2a		 jae	 SHORT $LN218@inflate
$LL221@inflate:
  00cb3	85 db		 test	 ebx, ebx
  00cb5	0f 84 cd 08 00
	00		 je	 $LN952@inflate
  00cbb	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00cbe	8b ce		 mov	 ecx, esi
  00cc0	d3 e2		 shl	 edx, cl
  00cc2	4b		 dec	 ebx
  00cc3	8b 4d d4	 mov	 ecx, DWORD PTR tv5605[ebp]
  00cc6	47		 inc	 edi
  00cc7	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00cca	83 c6 08	 add	 esi, 8
  00ccd	83 c1 03	 add	 ecx, 3
  00cd0	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00cd3	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00cd6	3b f1		 cmp	 esi, ecx
  00cd8	72 d9		 jb	 SHORT $LL221@inflate
  00cda	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN218@inflate:

; 947  :                         DROPBITS(here.bits);

  00cdd	0f b6 cc	 movzx	 ecx, ah
  00ce0	d3 ea		 shr	 edx, cl

; 948  :                         len = 0;
; 949  :                         copy = 3 + BITS(3);

  00ce2	8b c2		 mov	 eax, edx
  00ce4	83 e0 07	 and	 eax, 7
  00ce7	83 c0 03	 add	 eax, 3

; 950  :                         DROPBITS(3);

  00cea	c1 ea 03	 shr	 edx, 3
  00ced	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00cf0	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 951  :                     }

  00cf5	eb 4b		 jmp	 SHORT $LN995@inflate
$LN234@inflate:

; 952  :                     else {
; 953  :                         NEEDBITS(here.bits + 7);

  00cf7	83 c1 07	 add	 ecx, 7
  00cfa	3b f1		 cmp	 esi, ecx
  00cfc	73 2c		 jae	 SHORT $LN232@inflate
  00cfe	66 90		 npad	 2
$LL235@inflate:
  00d00	85 db		 test	 ebx, ebx
  00d02	0f 84 80 08 00
	00		 je	 $LN952@inflate
  00d08	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d0b	8b ce		 mov	 ecx, esi
  00d0d	d3 e2		 shl	 edx, cl
  00d0f	4b		 dec	 ebx
  00d10	8b 4d d4	 mov	 ecx, DWORD PTR tv5605[ebp]
  00d13	47		 inc	 edi
  00d14	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d17	83 c6 08	 add	 esi, 8
  00d1a	83 c1 07	 add	 ecx, 7
  00d1d	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d20	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d23	3b f1		 cmp	 esi, ecx
  00d25	72 d9		 jb	 SHORT $LL235@inflate
  00d27	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN232@inflate:

; 954  :                         DROPBITS(here.bits);

  00d2a	0f b6 cc	 movzx	 ecx, ah
  00d2d	d3 ea		 shr	 edx, cl

; 955  :                         len = 0;
; 956  :                         copy = 11 + BITS(7);

  00d2f	8b c2		 mov	 eax, edx
  00d31	83 e0 7f	 and	 eax, 127		; 0000007fH
  00d34	83 c0 0b	 add	 eax, 11			; 0000000bH

; 957  :                         DROPBITS(7);

  00d37	c1 ea 07	 shr	 edx, 7
  00d3a	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d3d	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN995@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d42	2b c1		 sub	 eax, ecx
  00d44	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], 0
  00d4b	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d4e	03 f0		 add	 esi, eax
  00d50	8b 45 d4	 mov	 eax, DWORD PTR _copy$4$[ebp]
$LN994@inflate:
  00d53	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  00d56	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d59	03 c8		 add	 ecx, eax
  00d5b	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00d5e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d61	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00d64	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00d67	03 47 60	 add	 eax, DWORD PTR [edi+96]
  00d6a	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00d6d	3b c8		 cmp	 ecx, eax
  00d6f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d72	77 41		 ja	 SHORT $LN576@inflate
  00d74	8b 5d d4	 mov	 ebx, DWORD PTR _copy$4$[ebp]
  00d77	8b 55 cc	 mov	 edx, DWORD PTR $T8[ebp]
  00d7a	66 0f 1f 44 00
	00		 npad	 6
$LL246@inflate:

; 960  :                         strm->msg = (char *)"invalid bit length repeat";
; 961  :                         state->mode = BAD;
; 962  :                         break;
; 963  :                     }
; 964  :                     while (copy--)
; 965  :                         state->lens[state->have++] = (unsigned short)len;

  00d80	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00d83	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00d88	8b 79 68	 mov	 edi, DWORD PTR [ecx+104]
  00d8b	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00d8e	89 7d c4	 mov	 DWORD PTR $T1[ebp], edi
  00d91	89 79 68	 mov	 DWORD PTR [ecx+104], edi
  00d94	83 eb 01	 sub	 ebx, 1
  00d97	75 e7		 jne	 SHORT $LL246@inflate
  00d99	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00d9c	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN993@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00d9f	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00da2	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00da5	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00da8	39 45 c4	 cmp	 DWORD PTR $T1[ebp], eax
  00dab	0f 82 6f fd ff
	ff		 jb	 $LL185@inflate

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  00db1	8b 01		 mov	 eax, DWORD PTR [ecx]
  00db3	eb 18		 jmp	 SHORT $LN186@inflate
$LN576@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00db5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00db8	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00dbf	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00dc5	e9 f1 02 00 00	 jmp	 $LN8@inflate
$LN958@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00dca	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
$LN186@inflate:

; 966  :                 }
; 967  :             }
; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  00dcd	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00dd0	0f 84 e5 02 00
	00		 je	 $LN8@inflate

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  00dd6	66 83 b9 70 02
	00 00 00	 cmp	 WORD PTR [ecx+624], 0
  00dde	75 15		 jne	 SHORT $LN453@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00de0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00de3	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00dea	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00df0	e9 c6 02 00 00	 jmp	 $LN8@inflate
$LN453@inflate:

; 975  :                 state->mode = BAD;
; 976  :                 break;
; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;

  00df5	8d 51 6c	 lea	 edx, DWORD PTR [ecx+108]

; 983  :             state->lencode = (code const FAR *)(state->next);
; 984  :             state->lenbits = 9;

  00df8	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9
  00dff	8d 81 30 05 00
	00		 lea	 eax, DWORD PTR [ecx+1328]
  00e05	89 55 c0	 mov	 DWORD PTR tv5496[ebp], edx

; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e08	8d b9 f0 02 00
	00		 lea	 edi, DWORD PTR [ecx+752]
  00e0e	89 02		 mov	 DWORD PTR [edx], eax
  00e10	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
  00e13	8d 41 54	 lea	 eax, DWORD PTR [ecx+84]
  00e16	57		 push	 edi
  00e17	50		 push	 eax
  00e18	52		 push	 edx
  00e19	ff 71 60	 push	 DWORD PTR [ecx+96]
  00e1c	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00e1f	89 7d c4	 mov	 DWORD PTR tv5491[ebp], edi
  00e22	b9 01 00 00 00	 mov	 ecx, 1
  00e27	e8 00 00 00 00	 call	 _inflate_table

; 986  :                                 &(state->lenbits), state->work);
; 987  :             if (ret) {

  00e2c	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e2f	83 c4 10	 add	 esp, 16			; 00000010H
  00e32	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e35	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e38	85 c0		 test	 eax, eax
  00e3a	74 18		 je	 SHORT $LN454@inflate

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";

  00e3c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 989  :                 state->mode = BAD;
; 990  :                 break;

  00e3f	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e42	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00e49	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00e4f	e9 67 02 00 00	 jmp	 $LN8@inflate
$LN454@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  00e54	8b 55 c0	 mov	 edx, DWORD PTR tv5496[ebp]

; 993  :             state->distbits = 6;
; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e57	ff 75 c4	 push	 DWORD PTR tv5491[ebp]
  00e5a	c7 41 58 06 00
	00 00		 mov	 DWORD PTR [ecx+88], 6
  00e61	8b 02		 mov	 eax, DWORD PTR [edx]
  00e63	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00e66	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e69	50		 push	 eax
  00e6a	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00e6d	52		 push	 edx
  00e6e	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e71	83 c1 70	 add	 ecx, 112		; 00000070H
  00e74	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00e77	b9 02 00 00 00	 mov	 ecx, 2
  00e7c	e8 00 00 00 00	 call	 _inflate_table

; 995  :                             &(state->next), &(state->distbits), state->work);
; 996  :             if (ret) {

  00e81	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e84	83 c4 10	 add	 esp, 16			; 00000010H
  00e87	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e8a	85 c0		 test	 eax, eax
  00e8c	74 18		 je	 SHORT $LN455@inflate

; 997  :                 strm->msg = (char *)"invalid distances set";

  00e8e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 998  :                 state->mode = BAD;
; 999  :                 break;

  00e91	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00e94	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00e9b	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  00ea1	e9 15 02 00 00	 jmp	 $LN8@inflate
$LN455@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;
; 1003 :             if (flush == Z_TREES) goto inf_leave;

  00ea6	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00eaa	c7 01 13 00 00
	00		 mov	 DWORD PTR [ecx], 19	; 00000013H
  00eb0	0f 84 d2 06 00
	00		 je	 $LN952@inflate
  00eb6	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN456@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  00eb9	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN458@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  00ebf	83 fb 06	 cmp	 ebx, 6
  00ec2	72 71		 jb	 SHORT $LN459@inflate
  00ec4	81 7d e0 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00ecb	72 68		 jb	 SHORT $LN459@inflate

; 1008 :                 RESTORE();

  00ecd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ed0	8b 7d dc	 mov	 edi, DWORD PTR _put$1$[ebp]
  00ed3	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00ed6	8b 7d e0	 mov	 edi, DWORD PTR _left$1$[ebp]
  00ed9	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00edc	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00edf	89 38		 mov	 DWORD PTR [eax], edi
  00ee1	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00ee4	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 1009 :                 inflate_fast(strm, out);

  00ee7	8b 55 d8	 mov	 edx, DWORD PTR _out$1$[ebp]
  00eea	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  00eed	8b c8		 mov	 ecx, eax
  00eef	e8 00 00 00 00	 call	 _inflate_fast

; 1010 :                 LOAD();

  00ef4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ef7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00efa	8b 38		 mov	 edi, DWORD PTR [eax]
  00efc	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00eff	89 4d dc	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f02	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f05	89 4d e0	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f08	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f0b	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00f0e	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1011 :                 if (state->mode == TYPE)

  00f11	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  00f14	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00f17	8b 71 3c	 mov	 esi, DWORD PTR [ecx+60]
  00f1a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f1d	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f20	0f 85 95 01 00
	00		 jne	 $LN8@inflate

; 1012 :                     state->back = -1;

  00f26	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 1013 :                 break;

  00f30	e9 86 01 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1014 :             }
; 1015 :             state->back = 0;

  00f35	c7 81 c4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7108], 0

; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  00f3f	b8 01 00 00 00	 mov	 eax, 1
  00f44	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00f47	d3 e0		 shl	 eax, cl
  00f49	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00f4c	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00f4f	89 4d c0	 mov	 DWORD PTR tv5445[ebp], ecx
  00f52	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00f55	89 45 d4	 mov	 DWORD PTR tv5489[ebp], eax
  00f58	8b c1		 mov	 eax, ecx
  00f5a	8b 4d d4	 mov	 ecx, DWORD PTR tv5489[ebp]
  00f5d	23 c2		 and	 eax, edx
  00f5f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00f62	8b c8		 mov	 ecx, eax
  00f64	c1 e9 08	 shr	 ecx, 8
  00f67	0f b6 c9	 movzx	 ecx, cl

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  00f6a	3b ce		 cmp	 ecx, esi
  00f6c	76 38		 jbe	 SHORT $LN578@inflate
  00f6e	66 90		 npad	 2
$LL254@inflate:

; 1019 :                 PULLBYTE();

  00f70	85 db		 test	 ebx, ebx
  00f72	0f 84 10 06 00
	00		 je	 $LN952@inflate
  00f78	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00f7b	8b ce		 mov	 ecx, esi
  00f7d	d3 e0		 shl	 eax, cl
  00f7f	4b		 dec	 ebx
  00f80	8b 4d d4	 mov	 ecx, DWORD PTR tv5489[ebp]
  00f83	03 d0		 add	 edx, eax
  00f85	8b 45 c0	 mov	 eax, DWORD PTR tv5445[ebp]
  00f88	47		 inc	 edi
  00f89	23 c2		 and	 eax, edx
  00f8b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00f8e	83 c6 08	 add	 esi, 8
  00f91	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f94	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00f97	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00f9a	8b c8		 mov	 ecx, eax
  00f9c	c1 e9 08	 shr	 ecx, 8
  00f9f	0f b6 c9	 movzx	 ecx, cl
  00fa2	3b ce		 cmp	 ecx, esi
  00fa4	77 ca		 ja	 SHORT $LL254@inflate
$LN578@inflate:

; 1020 :             }
; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  00fa6	84 c0		 test	 al, al
  00fa8	0f 84 ae 00 00
	00		 je	 $LN956@inflate
  00fae	a8 f0		 test	 al, 240			; 000000f0H
  00fb0	0f 85 a6 00 00
	00		 jne	 $LN956@inflate

; 1022 :                 last = here;

  00fb6	8b c8		 mov	 ecx, eax

; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +

  00fb8	bf 01 00 00 00	 mov	 edi, 1
  00fbd	c1 e9 08	 shr	 ecx, 8
  00fc0	8b d0		 mov	 edx, eax
  00fc2	0f b6 d9	 movzx	 ebx, cl
  00fc5	0f b6 c8	 movzx	 ecx, al
  00fc8	03 cb		 add	 ecx, ebx
  00fca	c1 e8 10	 shr	 eax, 16			; 00000010H
  00fcd	d3 e7		 shl	 edi, cl
  00fcf	8b cb		 mov	 ecx, ebx
  00fd1	4f		 dec	 edi
  00fd2	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  00fd5	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  00fd8	d3 ef		 shr	 edi, cl
  00fda	8b 4d d4	 mov	 ecx, DWORD PTR tv5489[ebp]
  00fdd	03 f8		 add	 edi, eax
  00fdf	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  00fe2	8b c8		 mov	 ecx, eax
  00fe4	c1 e9 08	 shr	 ecx, 8

; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00fe7	0f b6 c9	 movzx	 ecx, cl
  00fea	03 cb		 add	 ecx, ebx
  00fec	3b ce		 cmp	 ecx, esi
  00fee	76 54		 jbe	 SHORT $LN268@inflate
$LL260@inflate:

; 1027 :                     PULLBYTE();

  00ff0	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  00ff3	85 c0		 test	 eax, eax
  00ff5	0f 84 90 05 00
	00		 je	 $inf_leave$1003
  00ffb	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  00ffe	48		 dec	 eax
  00fff	89 45 f0	 mov	 DWORD PTR _have$1$[ebp], eax
  01002	8b ce		 mov	 ecx, esi
  01004	bf 01 00 00 00	 mov	 edi, 1
  01009	83 c6 08	 add	 esi, 8
  0100c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0100f	43		 inc	 ebx
  01010	d3 e0		 shl	 eax, cl
  01012	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01015	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  01019	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  0101c	0f b6 de	 movzx	 ebx, dh
  0101f	0f b6 ca	 movzx	 ecx, dl
  01022	03 cb		 add	 ecx, ebx
  01024	d3 e7		 shl	 edi, cl
  01026	8b cb		 mov	 ecx, ebx
  01028	4f		 dec	 edi
  01029	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0102c	d3 ef		 shr	 edi, cl
  0102e	03 f8		 add	 edi, eax
  01030	8b 45 d4	 mov	 eax, DWORD PTR tv5489[ebp]
  01033	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01036	8b c8		 mov	 ecx, eax
  01038	c1 e9 08	 shr	 ecx, 8
  0103b	0f b6 c9	 movzx	 ecx, cl
  0103e	03 cb		 add	 ecx, ebx
  01040	3b ce		 cmp	 ecx, esi
  01042	77 ac		 ja	 SHORT $LL260@inflate
$LN268@inflate:

; 1028 :                 }
; 1029 :                 DROPBITS(last.bits);
; 1030 :                 state->back += last.bits;

  01044	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  01047	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0104a	0f b6 ce	 movzx	 ecx, dh
  0104d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01050	d3 ea		 shr	 edx, cl
  01052	2b f1		 sub	 esi, ecx
  01054	89 8f c4 1b 00
	00		 mov	 DWORD PTR [edi+7108], ecx
  0105a	eb 03		 jmp	 SHORT $LN271@inflate
$LN956@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);

  0105c	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
$LN271@inflate:
  0105f	8b c8		 mov	 ecx, eax
  01061	c1 e9 08	 shr	 ecx, 8
  01064	0f b6 c9	 movzx	 ecx, cl

; 1033 :             state->back += here.bits;

  01067	01 8f c4 1b 00
	00		 add	 DWORD PTR [edi+7108], ecx
  0106d	2b f1		 sub	 esi, ecx
  0106f	d3 ea		 shr	 edx, cl

; 1034 :             state->length = (unsigned)here.val;

  01071	8b c8		 mov	 ecx, eax
  01073	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01076	89 4f 40	 mov	 DWORD PTR [edi+64], ecx

; 1035 :             if ((int)(here.op) == 0) {

  01079	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0107c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0107f	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01082	84 c0		 test	 al, al
  01084	75 08		 jne	 SHORT $LN466@inflate

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  01086	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H

; 1040 :                 break;

  0108c	eb 2a		 jmp	 SHORT $LN953@inflate
$LN466@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  0108e	a8 20		 test	 al, 32			; 00000020H
  01090	74 12		 je	 SHORT $LN467@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  01092	c7 81 c4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7108], -1

; 1045 :                 state->mode = TYPE;

  0109c	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1046 :                 break;

  010a2	eb 14		 jmp	 SHORT $LN953@inflate
$LN467@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  010a4	a8 40		 test	 al, 64			; 00000040H
  010a6	74 2f		 je	 SHORT $LN468@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  010a8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010ab	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
$LN997@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  010b2	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
$LN953@inflate:
  010b8	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
$LN8@inflate:
  010bb	8b 01		 mov	 eax, DWORD PTR [ecx]
  010bd	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  010c0	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  010c3	0f 86 c8 ef ff
	ff		 jbe	 $LL5@inflate
$LN341@inflate:
  010c9	5f		 pop	 edi

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  010ca	5e		 pop	 esi
  010cb	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  010d0	5b		 pop	 ebx
  010d1	8b e5		 mov	 esp, ebp
  010d3	5d		 pop	 ebp
  010d4	c2 08 00	 ret	 8
$LN468@inflate:

; 1050 :                 state->mode = BAD;
; 1051 :                 break;
; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  010d7	0f b6 c0	 movzx	 eax, al
  010da	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1054 :             state->mode = LENEXT;

  010dd	c7 01 15 00 00
	00		 mov	 DWORD PTR [ecx], 21	; 00000015H
  010e3	89 41 48	 mov	 DWORD PTR [ecx+72], eax
$LN469@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  010e6	8b 79 48	 mov	 edi, DWORD PTR [ecx+72]
  010e9	85 ff		 test	 edi, edi
  010eb	74 4f		 je	 SHORT $LN767@inflate

; 1057 :                 NEEDBITS(state->extra);

  010ed	3b f7		 cmp	 esi, edi
  010ef	73 27		 jae	 SHORT $LN272@inflate
  010f1	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
$LL275@inflate:
  010f4	85 db		 test	 ebx, ebx
  010f6	0f 84 8c 04 00
	00		 je	 $LN952@inflate
  010fc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  010ff	8b ce		 mov	 ecx, esi
  01101	d3 e0		 shl	 eax, cl
  01103	4b		 dec	 ebx
  01104	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01107	42		 inc	 edx
  01108	83 c6 08	 add	 esi, 8
  0110b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0110e	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  01111	3b f7		 cmp	 esi, edi
  01113	72 df		 jb	 SHORT $LL275@inflate
  01115	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN272@inflate:

; 1058 :                 state->length += BITS(state->extra);

  01118	8b cf		 mov	 ecx, edi
  0111a	b8 01 00 00 00	 mov	 eax, 1
  0111f	d3 e0		 shl	 eax, cl

; 1059 :                 DROPBITS(state->extra);

  01121	2b f7		 sub	 esi, edi
  01123	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01126	48		 dec	 eax
  01127	23 c2		 and	 eax, edx
  01129	01 41 40	 add	 DWORD PTR [ecx+64], eax
  0112c	8b cf		 mov	 ecx, edi
  0112e	d3 ea		 shr	 edx, cl

; 1060 :                 state->back += state->extra;

  01130	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01133	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01136	01 b9 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], edi
$LN767@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  0113c	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0113f	89 81 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], eax

; 1064 :             state->mode = DIST;

  01145	c7 01 16 00 00
	00		 mov	 DWORD PTR [ecx], 22	; 00000016H
$LN472@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  0114b	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  0114e	b8 01 00 00 00	 mov	 eax, 1
  01153	d3 e0		 shl	 eax, cl
  01155	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  01158	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0115b	89 4d c0	 mov	 DWORD PTR tv5433[ebp], ecx
  0115e	23 ca		 and	 ecx, edx
  01160	8b 78 50	 mov	 edi, DWORD PTR [eax+80]
  01163	89 7d c4	 mov	 DWORD PTR tv5465[ebp], edi
  01166	8b 04 8f	 mov	 eax, DWORD PTR [edi+ecx*4]
  01169	8b c8		 mov	 ecx, eax
  0116b	c1 e9 08	 shr	 ecx, 8
  0116e	0f b6 c9	 movzx	 ecx, cl

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  01171	3b ce		 cmp	 ecx, esi
  01173	76 3c		 jbe	 SHORT $LN583@inflate
  01175	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
$LL283@inflate:

; 1069 :                 PULLBYTE();

  01178	85 db		 test	 ebx, ebx
  0117a	0f 84 08 04 00
	00		 je	 $LN952@inflate
  01180	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01183	8b ce		 mov	 ecx, esi
  01185	d3 e0		 shl	 eax, cl
  01187	4b		 dec	 ebx
  01188	8b 4d f8	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  0118b	42		 inc	 edx
  0118c	03 c8		 add	 ecx, eax
  0118e	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  01191	8b 45 c0	 mov	 eax, DWORD PTR tv5433[ebp]
  01194	83 c6 08	 add	 esi, 8
  01197	23 c1		 and	 eax, ecx
  01199	89 4d f8	 mov	 DWORD PTR _hold$1$[ebp], ecx
  0119c	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  0119f	8b 04 87	 mov	 eax, DWORD PTR [edi+eax*4]
  011a2	8b c8		 mov	 ecx, eax
  011a4	c1 e9 08	 shr	 ecx, 8
  011a7	0f b6 c9	 movzx	 ecx, cl
  011aa	3b ce		 cmp	 ecx, esi
  011ac	77 ca		 ja	 SHORT $LL283@inflate
  011ae	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN583@inflate:

; 1070 :             }
; 1071 :             if ((here.op & 0xf0) == 0) {

  011b1	a8 f0		 test	 al, 240			; 000000f0H
  011b3	0f 85 a3 00 00
	00		 jne	 $LN957@inflate

; 1072 :                 last = here;

  011b9	8b c8		 mov	 ecx, eax

; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +

  011bb	bf 01 00 00 00	 mov	 edi, 1
  011c0	c1 e9 08	 shr	 ecx, 8
  011c3	8b d0		 mov	 edx, eax
  011c5	0f b6 d9	 movzx	 ebx, cl
  011c8	0f b6 c8	 movzx	 ecx, al
  011cb	03 cb		 add	 ecx, ebx
  011cd	c1 e8 10	 shr	 eax, 16			; 00000010H
  011d0	d3 e7		 shl	 edi, cl
  011d2	8b cb		 mov	 ecx, ebx
  011d4	4f		 dec	 edi
  011d5	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  011d8	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  011db	d3 ef		 shr	 edi, cl
  011dd	8b 4d c4	 mov	 ecx, DWORD PTR tv5465[ebp]
  011e0	03 f8		 add	 edi, eax
  011e2	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  011e5	8b c8		 mov	 ecx, eax
  011e7	c1 e9 08	 shr	 ecx, 8

; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011ea	0f b6 c9	 movzx	 ecx, cl
  011ed	03 cb		 add	 ecx, ebx
  011ef	3b ce		 cmp	 ecx, esi
  011f1	76 54		 jbe	 SHORT $LN297@inflate
$LL289@inflate:

; 1077 :                     PULLBYTE();

  011f3	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  011f6	85 c0		 test	 eax, eax
  011f8	0f 84 8d 03 00
	00		 je	 $inf_leave$1003
  011fe	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  01201	48		 dec	 eax
  01202	89 45 f0	 mov	 DWORD PTR _have$1$[ebp], eax
  01205	8b ce		 mov	 ecx, esi
  01207	bf 01 00 00 00	 mov	 edi, 1
  0120c	83 c6 08	 add	 esi, 8
  0120f	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01212	43		 inc	 ebx
  01213	d3 e0		 shl	 eax, cl
  01215	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  01218	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  0121c	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  0121f	0f b6 de	 movzx	 ebx, dh
  01222	0f b6 ca	 movzx	 ecx, dl
  01225	03 cb		 add	 ecx, ebx
  01227	d3 e7		 shl	 edi, cl
  01229	8b cb		 mov	 ecx, ebx
  0122b	4f		 dec	 edi
  0122c	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0122f	d3 ef		 shr	 edi, cl
  01231	03 f8		 add	 edi, eax
  01233	8b 45 c4	 mov	 eax, DWORD PTR tv5465[ebp]
  01236	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01239	8b c8		 mov	 ecx, eax
  0123b	c1 e9 08	 shr	 ecx, 8
  0123e	0f b6 c9	 movzx	 ecx, cl
  01241	03 cb		 add	 ecx, ebx
  01243	3b ce		 cmp	 ecx, esi
  01245	77 ac		 ja	 SHORT $LL289@inflate
$LN297@inflate:

; 1078 :                 }
; 1079 :                 DROPBITS(last.bits);
; 1080 :                 state->back += last.bits;

  01247	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0124a	0f b6 ce	 movzx	 ecx, dh
  0124d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01250	2b f1		 sub	 esi, ecx
  01252	d3 ea		 shr	 edx, cl
  01254	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  0125a	eb 03		 jmp	 SHORT $LN300@inflate
$LN957@inflate:

; 1070 :             }
; 1071 :             if ((here.op & 0xf0) == 0) {

  0125c	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN300@inflate:

; 1081 :             }
; 1082 :             DROPBITS(here.bits);

  0125f	8b c8		 mov	 ecx, eax
  01261	c1 e9 08	 shr	 ecx, 8
  01264	0f b6 c9	 movzx	 ecx, cl

; 1083 :             state->back += here.bits;

  01267	01 8b c4 1b 00
	00		 add	 DWORD PTR [ebx+7108], ecx
  0126d	2b f1		 sub	 esi, ecx
  0126f	d3 ea		 shr	 edx, cl
  01271	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01274	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 1084 :             if (here.op & 64) {

  01277	a8 40		 test	 al, 64			; 00000040H
  01279	74 15		 je	 SHORT $LN478@inflate

; 1085 :                 strm->msg = (char *)"invalid distance code";

  0127b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1086 :                 state->mode = BAD;

  0127e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1087 :                 break;

  01281	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01284	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  0128b	e9 22 fe ff ff	 jmp	 $LN997@inflate
$LN478@inflate:

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  01290	8b c8		 mov	 ecx, eax

; 1090 :             state->extra = (unsigned)(here.op) & 15;

  01292	0f b6 c0	 movzx	 eax, al
  01295	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01298	83 e0 0f	 and	 eax, 15			; 0000000fH
  0129b	89 4b 44	 mov	 DWORD PTR [ebx+68], ecx
  0129e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012a1	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012a4	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1091 :             state->mode = DISTEXT;

  012a7	c7 01 17 00 00
	00		 mov	 DWORD PTR [ecx], 23	; 00000017H
$LN479@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  012ad	8b 79 48	 mov	 edi, DWORD PTR [ecx+72]
  012b0	85 ff		 test	 edi, edi
  012b2	74 57		 je	 SHORT $LN769@inflate

; 1094 :                 NEEDBITS(state->extra);

  012b4	3b f7		 cmp	 esi, edi
  012b6	73 2c		 jae	 SHORT $LN301@inflate
  012b8	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
  012bb	0f 1f 44 00 00	 npad	 5
$LL304@inflate:
  012c0	85 db		 test	 ebx, ebx
  012c2	0f 84 c0 02 00
	00		 je	 $LN952@inflate
  012c8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  012cb	8b ce		 mov	 ecx, esi
  012cd	d3 e0		 shl	 eax, cl
  012cf	4b		 dec	 ebx
  012d0	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  012d3	42		 inc	 edx
  012d4	83 c6 08	 add	 esi, 8
  012d7	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  012da	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  012dd	3b f7		 cmp	 esi, edi
  012df	72 df		 jb	 SHORT $LL304@inflate
  012e1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN301@inflate:

; 1095 :                 state->offset += BITS(state->extra);

  012e4	8b cf		 mov	 ecx, edi
  012e6	b8 01 00 00 00	 mov	 eax, 1
  012eb	d3 e0		 shl	 eax, cl

; 1096 :                 DROPBITS(state->extra);

  012ed	2b f7		 sub	 esi, edi
  012ef	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012f2	48		 dec	 eax
  012f3	23 c2		 and	 eax, edx
  012f5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  012f8	01 41 44	 add	 DWORD PTR [ecx+68], eax
  012fb	8b cf		 mov	 ecx, edi
  012fd	d3 ea		 shr	 edx, cl

; 1097 :                 state->back += state->extra;

  012ff	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01302	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01305	01 b9 c4 1b 00
	00		 add	 DWORD PTR [ecx+7108], edi
$LN769@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  0130b	c7 01 18 00 00
	00		 mov	 DWORD PTR [ecx], 24	; 00000018H
$LN482@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  01311	8b 7d e0	 mov	 edi, DWORD PTR _left$1$[ebp]
  01314	85 ff		 test	 edi, edi
  01316	0f 84 6c 02 00
	00		 je	 $LN952@inflate

; 1110 :             copy = out - left;

  0131c	8b 45 d8	 mov	 eax, DWORD PTR _out$1$[ebp]
  0131f	2b c7		 sub	 eax, edi

; 1111 :             if (state->offset > copy) {         /* copy from window */

  01321	8b 79 44	 mov	 edi, DWORD PTR [ecx+68]
  01324	3b f8		 cmp	 edi, eax
  01326	76 4b		 jbe	 SHORT $LN484@inflate

; 1112 :                 copy = state->offset - copy;

  01328	2b f8		 sub	 edi, eax

; 1113 :                 if (copy > state->whave) {

  0132a	3b 79 2c	 cmp	 edi, DWORD PTR [ecx+44]
  0132d	76 18		 jbe	 SHORT $LN487@inflate

; 1114 :                     if (state->sane) {

  0132f	83 b9 c0 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7104], 0
  01336	74 0f		 je	 SHORT $LN487@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  01338	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0133b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1116 :                         state->mode = BAD;
; 1117 :                         break;

  01342	e9 6b fd ff ff	 jmp	 $LN997@inflate
$LN487@inflate:

; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  01347	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0134a	3b fa		 cmp	 edi, edx
  0134c	76 0c		 jbe	 SHORT $LN488@inflate

; 1134 :                     copy -= state->wnext;
; 1135 :                     from = state->window + (state->wsize - copy);

  0134e	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  01351	2b fa		 sub	 edi, edx
  01353	2b c7		 sub	 eax, edi
  01355	03 41 34	 add	 eax, DWORD PTR [ecx+52]

; 1136 :                 }

  01358	eb 07		 jmp	 SHORT $LN996@inflate
$LN488@inflate:

; 1137 :                 else
; 1138 :                     from = state->window + (state->wnext - copy);

  0135a	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0135d	2b c7		 sub	 eax, edi
  0135f	03 c2		 add	 eax, edx
$LN996@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  01361	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax
  01364	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]

; 1140 :             }

  01367	3b f8		 cmp	 edi, eax
  01369	8b d0		 mov	 edx, eax
  0136b	0f 46 d7	 cmovbe	 edx, edi
  0136e	89 55 c4	 mov	 DWORD PTR _copy$7$[ebp], edx
  01371	eb 0e		 jmp	 SHORT $LN485@inflate
$LN484@inflate:

; 1141 :             else {                              /* copy from output */
; 1142 :                 from = put - state->offset;

  01373	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  01376	2b c7		 sub	 eax, edi
  01378	89 45 cc	 mov	 DWORD PTR _from$1$[ebp], eax

; 1143 :                 copy = state->length;

  0137b	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  0137e	89 45 c4	 mov	 DWORD PTR _copy$7$[ebp], eax
$LN485@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;
; 1146 :             left -= copy;

  01381	8b 55 e0	 mov	 edx, DWORD PTR _left$1$[ebp]
  01384	8b fa		 mov	 edi, edx
  01386	39 55 c4	 cmp	 DWORD PTR _copy$7$[ebp], edx

; 1147 :             state->length -= copy;

  01389	8b 5d cc	 mov	 ebx, DWORD PTR _from$1$[ebp]
  0138c	0f 46 7d c4	 cmovbe	 edi, DWORD PTR _copy$7$[ebp]
  01390	2b d7		 sub	 edx, edi
  01392	2b c7		 sub	 eax, edi
  01394	89 55 e0	 mov	 DWORD PTR _left$1$[ebp], edx
  01397	8b 55 dc	 mov	 edx, DWORD PTR _put$1$[ebp]
  0139a	2b da		 sub	 ebx, edx
  0139c	89 41 40	 mov	 DWORD PTR [ecx+64], eax
  0139f	90		 npad	 1
$LL314@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  013a0	8a 04 13	 mov	 al, BYTE PTR [ebx+edx]
  013a3	88 02		 mov	 BYTE PTR [edx], al
  013a5	42		 inc	 edx

; 1150 :             } while (--copy);

  013a6	83 ef 01	 sub	 edi, 1
  013a9	75 f5		 jne	 SHORT $LL314@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  013ab	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  013ae	89 55 dc	 mov	 DWORD PTR _put$1$[ebp], edx
  013b1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  013b4	39 79 40	 cmp	 DWORD PTR [ecx+64], edi
  013b7	0f 85 fb fc ff
	ff		 jne	 $LN953@inflate
  013bd	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H

; 1152 :             break;

  013c3	e9 f0 fc ff ff	 jmp	 $LN953@inflate
$LN493@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  013c8	83 7d e0 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  013cc	0f 84 b6 01 00
	00		 je	 $LN952@inflate

; 1155 :             *put++ = (unsigned char)(state->length);

  013d2	8b 55 dc	 mov	 edx, DWORD PTR _put$1$[ebp]
  013d5	8a 41 40	 mov	 al, BYTE PTR [ecx+64]
  013d8	ff 45 dc	 inc	 DWORD PTR _put$1$[ebp]

; 1156 :             left--;

  013db	ff 4d e0	 dec	 DWORD PTR _left$1$[ebp]
  013de	88 02		 mov	 BYTE PTR [edx], al

; 1157 :             state->mode = LEN;
; 1158 :             break;

  013e0	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  013e3	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
  013e9	e9 cd fc ff ff	 jmp	 $LN8@inflate
$LN495@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  013ee	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  013f2	0f 84 da 00 00
	00		 je	 $LN324@inflate

; 1161 :                 NEEDBITS(32);

  013f8	83 fe 20	 cmp	 esi, 32			; 00000020H
  013fb	73 2d		 jae	 SHORT $LN315@inflate
  013fd	0f 1f 00	 npad	 3
$LL318@inflate:
  01400	85 db		 test	 ebx, ebx
  01402	0f 84 80 01 00
	00		 je	 $LN952@inflate
  01408	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0140b	8b ce		 mov	 ecx, esi
  0140d	d3 e0		 shl	 eax, cl
  0140f	83 c6 08	 add	 esi, 8
  01412	4b		 dec	 ebx
  01413	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01416	03 d0		 add	 edx, eax
  01418	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0141b	47		 inc	 edi
  0141c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0141f	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01422	83 fe 20	 cmp	 esi, 32			; 00000020H
  01425	72 d9		 jb	 SHORT $LL318@inflate
  01427	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN315@inflate:

; 1162 :                 out -= left;

  0142a	8b 45 e0	 mov	 eax, DWORD PTR _left$1$[ebp]
  0142d	29 45 d8	 sub	 DWORD PTR _out$1$[ebp], eax

; 1163 :                 strm->total_out += out;

  01430	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01433	8b 7d d8	 mov	 edi, DWORD PTR _out$1$[ebp]
  01436	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1164 :                 state->total += out;

  01439	8b c7		 mov	 eax, edi
  0143b	01 41 1c	 add	 DWORD PTR [ecx+28], eax

; 1165 :                 if (out)

  0143e	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  01441	85 c0		 test	 eax, eax
  01443	74 2f		 je	 SHORT $LN498@inflate

; 1166 :                     strm->adler = state->check =

  01445	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  01448	ff 75 d8	 push	 DWORD PTR _out$1$[ebp]
  0144b	2b 45 d8	 sub	 eax, DWORD PTR _out$1$[ebp]
  0144e	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01452	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01455	50		 push	 eax
  01456	52		 push	 edx
  01457	74 07		 je	 SHORT $LN518@inflate
  01459	e8 00 00 00 00	 call	 _crc32@12
  0145e	eb 05		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01460	e8 00 00 00 00	 call	 _adler32@12
$LN519@inflate:
  01465	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01468	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0146b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0146e	89 42 30	 mov	 DWORD PTR [edx+48], eax
  01471	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN498@inflate:

; 1167 :                         UPDATE(state->check, put - out, out);
; 1168 :                 out = left;
; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  01474	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01478	8b 45 e0	 mov	 eax, DWORD PTR _left$1$[ebp]
  0147b	89 45 d8	 mov	 DWORD PTR _out$1$[ebp], eax
  0147e	8b c2		 mov	 eax, edx
  01480	75 2c		 jne	 SHORT $LN521@inflate
  01482	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01487	89 45 d4	 mov	 DWORD PTR tv5599[ebp], eax
  0148a	8b c2		 mov	 eax, edx
  0148c	c1 e0 10	 shl	 eax, 16			; 00000010H
  0148f	01 45 d4	 add	 DWORD PTR tv5599[ebp], eax
  01492	8b c2		 mov	 eax, edx
  01494	c1 65 d4 08	 shl	 DWORD PTR tv5599[ebp], 8
  01498	c1 e8 08	 shr	 eax, 8
  0149b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014a0	01 45 d4	 add	 DWORD PTR tv5599[ebp], eax
  014a3	8b c2		 mov	 eax, edx
  014a5	c1 e8 18	 shr	 eax, 24			; 00000018H
  014a8	01 45 d4	 add	 DWORD PTR tv5599[ebp], eax
  014ab	8b 45 d4	 mov	 eax, DWORD PTR tv5599[ebp]
$LN521@inflate:
  014ae	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  014b1	74 15		 je	 SHORT $LN325@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  014b3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014b6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  014bd	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  014c3	e9 f3 fb ff ff	 jmp	 $LN8@inflate
$LN325@inflate:

; 1175 :                     state->mode = BAD;
; 1176 :                     break;
; 1177 :                 }
; 1178 :                 INITBITS();

  014c8	33 d2		 xor	 edx, edx
  014ca	33 f6		 xor	 esi, esi
  014cc	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  014cf	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN324@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  014d2	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH
$LN500@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  014d8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  014dc	0f 84 90 00 00
	00		 je	 $LN335@inflate
  014e2	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  014e6	0f 84 86 00 00
	00		 je	 $LN335@inflate

; 1185 :                 NEEDBITS(32);

  014ec	83 fe 20	 cmp	 esi, 32			; 00000020H
  014ef	73 2a		 jae	 SHORT $LN326@inflate
$LL329@inflate:
  014f1	85 db		 test	 ebx, ebx
  014f3	0f 84 8f 00 00
	00		 je	 $LN952@inflate
  014f9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  014fc	8b ce		 mov	 ecx, esi
  014fe	d3 e0		 shl	 eax, cl
  01500	83 c6 08	 add	 esi, 8
  01503	4b		 dec	 ebx
  01504	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01507	03 d0		 add	 edx, eax
  01509	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0150c	47		 inc	 edi
  0150d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01510	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01513	83 fe 20	 cmp	 esi, 32			; 00000020H
  01516	72 d9		 jb	 SHORT $LL329@inflate
  01518	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN326@inflate:

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  0151b	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  0151e	74 49		 je	 SHORT $LN336@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  01520	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01523	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  0152a	c7 01 1d 00 00
	00		 mov	 DWORD PTR [ecx], 29	; 0000001dH
  01530	e9 86 fb ff ff	 jmp	 $LN8@inflate
$LN595@inflate:

; 805  :                 RESTORE();

  01535	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01538	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0153b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0153e	8b 4d e0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01541	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01544	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01547	89 38		 mov	 DWORD PTR [eax], edi
  01549	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 806  :                 return Z_NEED_DICT;

  0154c	b8 02 00 00 00	 mov	 eax, 2
  01551	5f		 pop	 edi
  01552	89 71 3c	 mov	 DWORD PTR [ecx+60], esi

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  01555	5e		 pop	 esi
  01556	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  01559	5b		 pop	 ebx
  0155a	8b e5		 mov	 esp, ebp
  0155c	5d		 pop	 ebp
  0155d	c2 08 00	 ret	 8
$LN596@inflate:

; 833  :                     DROPBITS(2);

  01560	c1 6d f8 02	 shr	 DWORD PTR _hold$1$[ebp], 2
  01564	83 ee 03	 sub	 esi, 3

; 834  :                     goto inf_leave;

  01567	eb 1f		 jmp	 SHORT $LN952@inflate
$LN336@inflate:

; 1188 :                     state->mode = BAD;
; 1189 :                     break;
; 1190 :                 }
; 1191 :                 INITBITS();

  01569	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  01570	33 f6		 xor	 esi, esi
$LN335@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  01572	c7 01 1c 00 00
	00		 mov	 DWORD PTR [ecx], 28	; 0000001cH
$LN504@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  01578	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1198 :             goto inf_leave;

  0157f	eb 07		 jmp	 SHORT $LN952@inflate
$LN505@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  01581	c7 45 d0 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
$LN952@inflate:

; 1201 :             goto inf_leave;
; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;
; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;
; 1207 :         }
; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  01588	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
$inf_leave$1003:
  0158b	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0158e	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01591	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  01594	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  01597	8b 4d e0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  0159a	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0159d	8b 4d ec	 mov	 ecx, DWORD PTR _next$1$[ebp]
  015a0	89 47 04	 mov	 DWORD PTR [edi+4], eax
  015a3	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
  015a6	89 0f		 mov	 DWORD PTR [edi], ecx

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  015a8	83 7b 28 00	 cmp	 DWORD PTR [ebx+40], 0
  015ac	89 73 3c	 mov	 DWORD PTR [ebx+60], esi
  015af	8b 75 d8	 mov	 esi, DWORD PTR _out$1$[ebp]
  015b2	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  015b5	75 0a		 jne	 SHORT $LN771@inflate
  015b7	83 3b 1a	 cmp	 DWORD PTR [ebx], 26	; 0000001aH
  015ba	7d 26		 jge	 SHORT $LN510@inflate
  015bc	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  015bf	74 21		 je	 SHORT $LN510@inflate
$LN771@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  015c1	8b d6		 mov	 edx, esi
  015c3	8b cf		 mov	 ecx, edi
  015c5	e8 00 00 00 00	 call	 _updatewindow
  015ca	85 c0		 test	 eax, eax
  015cc	74 14		 je	 SHORT $LN510@inflate

; 1219 :             state->mode = MEM;

  015ce	c7 03 1e 00 00
	00		 mov	 DWORD PTR [ebx], 30	; 0000001eH
$LN506@inflate:
  015d4	5f		 pop	 edi

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  015d5	5e		 pop	 esi
  015d6	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  015db	5b		 pop	 ebx
  015dc	8b e5		 mov	 esp, ebp
  015de	5d		 pop	 ebp
  015df	c2 08 00	 ret	 8
$LN510@inflate:

; 1220 :             return Z_MEM_ERROR;
; 1221 :         }
; 1222 :     in -= strm->avail_in;

  015e2	8b 45 c8	 mov	 eax, DWORD PTR _in$1$[ebp]
  015e5	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1223 :     out -= strm->avail_out;

  015e8	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1224 :     strm->total_in += in;

  015eb	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1225 :     strm->total_out += out;

  015ee	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1226 :     state->total += out;

  015f1	01 73 1c	 add	 DWORD PTR [ebx+28], esi

; 1227 :     if (state->wrap && out)

  015f4	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  015f8	89 45 c8	 mov	 DWORD PTR _in$1$[ebp], eax
  015fb	89 75 d8	 mov	 DWORD PTR _out$1$[ebp], esi
  015fe	74 27		 je	 SHORT $LN511@inflate
  01600	85 f6		 test	 esi, esi
  01602	74 23		 je	 SHORT $LN511@inflate

; 1228 :         strm->adler = state->check =

  01604	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01607	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  0160a	2b c6		 sub	 eax, esi
  0160c	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  01610	56		 push	 esi
  01611	50		 push	 eax
  01612	51		 push	 ecx
  01613	74 07		 je	 SHORT $LN522@inflate
  01615	e8 00 00 00 00	 call	 _crc32@12
  0161a	eb 05		 jmp	 SHORT $LN523@inflate
$LN522@inflate:
  0161c	e8 00 00 00 00	 call	 _adler32@12
$LN523@inflate:
  01621	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  01624	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN511@inflate:

; 1229 :             UPDATE(state->check, strm->next_out - out, out);
; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +

  01627	8b 13		 mov	 edx, DWORD PTR [ebx]
  01629	83 fa 13	 cmp	 edx, 19			; 00000013H
  0162c	74 09		 je	 SHORT $LN524@inflate
  0162e	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  01631	74 04		 je	 SHORT $LN524@inflate
  01633	33 f6		 xor	 esi, esi
  01635	eb 05		 jmp	 SHORT $LN525@inflate
$LN524@inflate:
  01637	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN525@inflate:
  0163c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0163f	f7 d9		 neg	 ecx
  01641	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv5410[ebp], 128 ; 00000080H
  01648	1b c9		 sbb	 ecx, ecx
  0164a	33 c0		 xor	 eax, eax
  0164c	83 e1 40	 and	 ecx, 64			; 00000040H
  0164f	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  01652	0f 44 45 08	 cmove	 eax, DWORD PTR tv5410[ebp]
  01656	03 c8		 add	 ecx, eax
  01658	03 4b 3c	 add	 ecx, DWORD PTR [ebx+60]
  0165b	03 ce		 add	 ecx, esi

; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0165d	83 7d c8 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01661	89 4f 2c	 mov	 DWORD PTR [edi+44], ecx
  01664	75 06		 jne	 SHORT $LN514@inflate
  01666	83 7d d8 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  0166a	74 06		 je	 SHORT $LN513@inflate
$LN514@inflate:
  0166c	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01670	75 16		 jne	 SHORT $LN963@inflate
$LN513@inflate:
  01672	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01675	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  0167a	5f		 pop	 edi
  0167b	85 c0		 test	 eax, eax

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  0167d	5e		 pop	 esi
  0167e	0f 44 c1	 cmove	 eax, ecx
  01681	5b		 pop	 ebx
  01682	8b e5		 mov	 esp, ebp
  01684	5d		 pop	 ebp
  01685	c2 08 00	 ret	 8
$LN963@inflate:

; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01688	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  0168b	5f		 pop	 edi

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;
; 1236 : }

  0168c	5e		 pop	 esi
  0168d	5b		 pop	 ebx
  0168e	8b e5		 mov	 esp, ebp
  01690	5d		 pop	 ebp
  01691	c2 08 00	 ret	 8
$LN1001@inflate:
  01694	00 00 00 00	 DD	 $LN343@inflate
  01698	00 00 00 00	 DD	 $LN32@inflate
  0169c	00 00 00 00	 DD	 $LN46@inflate
  016a0	00 00 00 00	 DD	 $LN60@inflate
  016a4	00 00 00 00	 DD	 $LN368@inflate
  016a8	00 00 00 00	 DD	 $LN375@inflate
  016ac	00 00 00 00	 DD	 $LN382@inflate
  016b0	00 00 00 00	 DD	 $LN391@inflate
  016b4	00 00 00 00	 DD	 $LN400@inflate
  016b8	00 00 00 00	 DD	 $LN105@inflate
  016bc	00 00 00 00	 DD	 $LN407@inflate
  016c0	00 00 00 00	 DD	 $LN409@inflate
  016c4	00 00 00 00	 DD	 $LN410@inflate
  016c8	00 00 00 00	 DD	 $LN141@inflate
  016cc	00 00 00 00	 DD	 $LN423@inflate
  016d0	00 00 00 00	 DD	 $LN425@inflate
  016d4	00 00 00 00	 DD	 $LN155@inflate
  016d8	00 00 00 00	 DD	 $LN539@inflate
  016dc	00 00 00 00	 DD	 $LN542@inflate
  016e0	00 00 00 00	 DD	 $LN456@inflate
  016e4	00 00 00 00	 DD	 $LN458@inflate
  016e8	00 00 00 00	 DD	 $LN469@inflate
  016ec	00 00 00 00	 DD	 $LN472@inflate
  016f0	00 00 00 00	 DD	 $LN479@inflate
  016f4	00 00 00 00	 DD	 $LN482@inflate
  016f8	00 00 00 00	 DD	 $LN493@inflate
  016fc	00 00 00 00	 DD	 $LN495@inflate
  01700	00 00 00 00	 DD	 $LN500@inflate
  01704	00 00 00 00	 DD	 $LN504@inflate
  01708	00 00 00 00	 DD	 $LN505@inflate
  0170c	00 00 00 00	 DD	 $LN506@inflate
$LN1002@inflate:
  01710	00 00 00 00	 DD	 $LN415@inflate
  01714	00 00 00 00	 DD	 $LN416@inflate
  01718	00 00 00 00	 DD	 $LN418@inflate
  0171c	00 00 00 00	 DD	 $LN419@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 3b		 je	 SHORT $LN3@inflateEnd
  0000b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0000e	85 c0		 test	 eax, eax
  00010	74 34		 je	 SHORT $LN3@inflateEnd
  00012	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2d		 je	 SHORT $LN3@inflateEnd

; 1244 :     state = (struct inflate_state FAR *)strm->state;
; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00019	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0001c	85 d2		 test	 edx, edx
  0001e	74 0f		 je	 SHORT $LN4@inflateEnd
  00020	52		 push	 edx
  00021	ff 76 28	 push	 DWORD PTR [esi+40]
  00024	ff d1		 call	 ecx
  00026	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00029	83 c4 08	 add	 esp, 8
  0002c	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
$LN4@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  0002f	50		 push	 eax
  00030	ff 76 28	 push	 DWORD PTR [esi+40]
  00033	ff d1		 call	 ecx
  00035	83 c4 08	 add	 esp, 8

; 1247 :     strm->state = Z_NULL;

  00038	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  0003f	33 c0		 xor	 eax, eax
  00041	5e		 pop	 esi

; 1250 : }

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
$LN3@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  00046	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004b	5e		 pop	 esi

; 1250 : }

  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	85 c0		 test	 eax, eax
  0000b	74 65		 je	 SHORT $LN3@inflateRes
  0000d	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  00010	85 ff		 test	 edi, edi
  00012	74 5e		 je	 SHORT $LN3@inflateRes

; 139  :     state = (struct inflate_state FAR *)strm->state;
; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00014	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	79 06		 jns	 SHORT $LN4@inflateRes

; 143  :         wrap = 0;

  0001b	33 db		 xor	 ebx, ebx

; 144  :         windowBits = -windowBits;

  0001d	f7 de		 neg	 esi

; 145  :     }

  0001f	eb 0e		 jmp	 SHORT $LN6@inflateRes
$LN4@inflateRes:

; 146  :     else {
; 147  :         wrap = (windowBits >> 4) + 1;

  00021	8b de		 mov	 ebx, esi
  00023	c1 fb 04	 sar	 ebx, 4
  00026	43		 inc	 ebx

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  00027	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002a	7d 03		 jge	 SHORT $LN6@inflateRes

; 150  :             windowBits &= 15;

  0002c	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN6@inflateRes:

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0002f	85 f6		 test	 esi, esi
  00031	74 0a		 je	 SHORT $LN7@inflateRes
  00033	83 fe 08	 cmp	 esi, 8
  00036	7c 3a		 jl	 SHORT $LN3@inflateRes
  00038	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003b	7f 35		 jg	 SHORT $LN3@inflateRes
$LN7@inflateRes:

; 156  :         return Z_STREAM_ERROR;
; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0003d	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00040	85 c9		 test	 ecx, ecx
  00042	74 1b		 je	 SHORT $LN9@inflateRes
  00044	39 77 24	 cmp	 DWORD PTR [edi+36], esi
  00047	74 16		 je	 SHORT $LN9@inflateRes

; 158  :         ZFREE(strm, state->window);

  00049	51		 push	 ecx
  0004a	ff 70 28	 push	 DWORD PTR [eax+40]
  0004d	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00050	ff d0		 call	 eax
  00052	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00055	83 c4 08	 add	 esp, 8

; 159  :         state->window = Z_NULL;

  00058	c7 47 34 00 00
	00 00		 mov	 DWORD PTR [edi+52], 0
$LN9@inflateRes:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;
; 164  :     state->wbits = (unsigned)windowBits;
; 165  :     return inflateReset(strm);

  0005f	50		 push	 eax
  00060	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00063	89 77 24	 mov	 DWORD PTR [edi+36], esi
  00066	e8 00 00 00 00	 call	 _inflateReset@4
  0006b	5f		 pop	 edi

; 166  : }

  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
$LN3@inflateRes:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 207  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	85 d2		 test	 edx, edx
  0000a	74 51		 je	 SHORT $LN3@inflatePri
  0000c	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  0000f	85 d2		 test	 edx, edx
  00011	74 4a		 je	 SHORT $LN3@inflatePri

; 217  :     state = (struct inflate_state FAR *)strm->state;
; 218  :     if (bits < 0) {

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00016	85 c9		 test	 ecx, ecx
  00018	79 16		 jns	 SHORT $LN4@inflatePri

; 219  :         state->hold = 0;

  0001a	5f		 pop	 edi
  0001b	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 220  :         state->bits = 0;
; 221  :         return Z_OK;

  00022	33 c0		 xor	 eax, eax
  00024	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 228  : }

  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN4@inflatePri:

; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  00030	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00033	7f 28		 jg	 SHORT $LN3@inflatePri
  00035	8b 72 3c	 mov	 esi, DWORD PTR [edx+60]
  00038	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  0003b	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003e	77 1d		 ja	 SHORT $LN3@inflatePri

; 224  :     value &= (1L << bits) - 1;

  00040	b8 01 00 00 00	 mov	 eax, 1

; 225  :     state->hold += value << state->bits;
; 226  :     state->bits += bits;

  00045	89 7a 3c	 mov	 DWORD PTR [edx+60], edi
  00048	d3 e0		 shl	 eax, cl
  0004a	8b ce		 mov	 ecx, esi
  0004c	48		 dec	 eax
  0004d	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00050	d3 e0		 shl	 eax, cl
  00052	01 42 38	 add	 DWORD PTR [edx+56], eax

; 227  :     return Z_OK;

  00055	33 c0		 xor	 eax, eax
  00057	5f		 pop	 edi

; 228  : }

  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:
  0005d	5f		 pop	 edi

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0005e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 228  : }

  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00000	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 278  :     state->lenbits = 9;

  00007	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 279  :     state->distcode = distfix;

  0000e	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 280  :     state->distbits = 5;

  00015	c7 41 58 05 00
	00 00		 mov	 DWORD PTR [ecx+88], 5

; 281  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
tv473 = -8						; size = 4
$T1 = -4						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _out$ = edx

; 361  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b fa		 mov	 edi, edx

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  0000d	8b 73 1c	 mov	 esi, DWORD PTR [ebx+28]

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  00010	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00013	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00016	85 c0		 test	 eax, eax
  00018	75 2e		 jne	 SHORT $LN15@updatewind

; 369  :         state->window = (unsigned char FAR *)

  0001a	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	d3 e0		 shl	 eax, cl
  00024	6a 01		 push	 1
  00026	50		 push	 eax
  00027	ff 73 28	 push	 DWORD PTR [ebx+40]
  0002a	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  0002d	ff d0		 call	 eax
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00035	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));
; 372  :         if (state->window == Z_NULL) return 1;

  00038	85 c0		 test	 eax, eax
  0003a	75 0c		 jne	 SHORT $LN15@updatewind

; 406  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN15@updatewind:

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  00048	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0004b	85 d2		 test	 edx, edx
  0004d	75 1b		 jne	 SHORT $LN14@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  0004f	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00052	ba 01 00 00 00	 mov	 edx, 1
  00057	d3 e2		 shl	 edx, cl
  00059	89 56 28	 mov	 DWORD PTR [esi+40], edx

; 378  :         state->wnext = 0;

  0005c	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 379  :         state->whave = 0;

  00063	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
$LN14@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;

  0006a	2b 7b 10	 sub	 edi, DWORD PTR [ebx+16]

; 384  :     if (copy >= state->wsize) {

  0006d	3b fa		 cmp	 edi, edx
  0006f	72 29		 jb	 SHORT $LN5@updatewind

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  00071	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00074	52		 push	 edx
  00075	2b c2		 sub	 eax, edx
  00077	50		 push	 eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _memcpy

; 386  :         state->wnext = 0;
; 387  :         state->whave = state->wsize;

  00081	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 403  :         }
; 404  :     }
; 405  :     return 0;

  00087	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0008a	33 c0		 xor	 eax, eax
  0008c	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  00093	5f		 pop	 edi

; 406  : }

  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
$LN5@updatewind:

; 388  :     }
; 389  :     else {
; 390  :         dist = state->wsize - state->wnext;

  0009a	2b 56 30	 sub	 edx, DWORD PTR [esi+48]

; 391  :         if (dist > copy) dist = copy;
; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  0009d	8b c7		 mov	 eax, edi
  0009f	3b d7		 cmp	 edx, edi
  000a1	0f 46 c2	 cmovbe	 eax, edx
  000a4	50		 push	 eax
  000a5	89 45 f8	 mov	 DWORD PTR tv473[ebp], eax
  000a8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000ab	2b c7		 sub	 eax, edi
  000ad	50		 push	 eax
  000ae	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000b1	03 46 30	 add	 eax, DWORD PTR [esi+48]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _memcpy

; 393  :         copy -= dist;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR tv473[ebp]
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	2b f8		 sub	 edi, eax

; 394  :         if (copy) {

  000c2	74 24		 je	 SHORT $LN8@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  000c4	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000c7	57		 push	 edi
  000c8	2b c7		 sub	 eax, edi
  000ca	50		 push	 eax
  000cb	ff 76 34	 push	 DWORD PTR [esi+52]
  000ce	e8 00 00 00 00	 call	 _memcpy

; 396  :             state->wnext = copy;
; 397  :             state->whave = state->wsize;

  000d3	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	89 7e 30	 mov	 DWORD PTR [esi+48], edi

; 403  :         }
; 404  :     }
; 405  :     return 0;

  000dc	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000df	33 c0		 xor	 eax, eax
  000e1	5f		 pop	 edi

; 406  : }

  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
$LN8@updatewind:

; 398  :         }
; 399  :         else {
; 400  :             state->wnext += dist;

  000e8	01 46 30	 add	 DWORD PTR [esi+48], eax

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  000eb	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000ee	39 56 30	 cmp	 DWORD PTR [esi+48], edx
  000f1	75 07		 jne	 SHORT $LN10@updatewind
  000f3	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN10@updatewind:

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  000fa	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000fd	3b ca		 cmp	 ecx, edx
  000ff	73 05		 jae	 SHORT $LN11@updatewind
  00101	03 c1		 add	 eax, ecx

; 403  :         }
; 404  :     }
; 405  :     return 0;

  00103	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN11@updatewind:

; 406  : }

  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	33 c0		 xor	 eax, eax
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	74 17		 je	 SHORT $LN3@inflateSet
  0000d	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00010	85 f6		 test	 esi, esi
  00012	74 10		 je	 SHORT $LN3@inflateSet

; 1262 :     state = (struct inflate_state FAR *)strm->state;
; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  00014	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  0001d	74 11		 je	 SHORT $LN11@inflateSet
  0001f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00022	74 11		 je	 SHORT $LN12@inflateSet
$LN3@inflateSet:
  00024	5f		 pop	 edi

; 1292 : }

  00025	5e		 pop	 esi
  00026	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002b	5b		 pop	 ebx
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN11@inflateSet:

; 1264 :         return Z_STREAM_ERROR;
; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  00030	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00033	75 26		 jne	 SHORT $LN6@inflateSet
$LN12@inflateSet:

; 1268 :         id = adler32(0L, Z_NULL, 0);

  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	e8 00 00 00 00	 call	 _adler32@12

; 1269 :         id = adler32(id, dictionary, dictLength);

  00040	53		 push	 ebx
  00041	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _adler32@12

; 1270 :         if (id != state->check)

  0004a	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  0004d	74 0c		 je	 SHORT $LN6@inflateSet

; 1292 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00056	5b		 pop	 ebx
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:

; 1271 :             return Z_DATA_ERROR;
; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  0005b	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0005e	8b cf		 mov	 ecx, edi
  00060	e8 00 00 00 00	 call	 _updatewindow
  00065	85 c0		 test	 eax, eax
  00067	74 12		 je	 SHORT $LN7@inflateSet

; 1276 :         state->mode = MEM;

  00069	5f		 pop	 edi
  0006a	c7 06 1e 00 00
	00		 mov	 DWORD PTR [esi], 30	; 0000001eH

; 1277 :         return Z_MEM_ERROR;

  00070	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 1292 : }

  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
$LN7@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  0007b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0007e	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00081	3b da		 cmp	 ebx, edx
  00083	76 28		 jbe	 SHORT $LN8@inflateSet

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,

  00085	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  00088	2b c2		 sub	 eax, edx
  0008a	52		 push	 edx
  0008b	03 c3		 add	 eax, ebx
  0008d	50		 push	 eax
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _memcpy

; 1281 :                 state->wsize);
; 1282 :         state->whave = state->wsize;

  00094	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]

; 1286 :                 dictLength);
; 1287 :         state->whave = dictLength;
; 1288 :     }
; 1289 :     state->havedict = 1;

  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  0009d	33 c0		 xor	 eax, eax
  0009f	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1
  000a6	5f		 pop	 edi

; 1292 : }

  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
$LN8@inflateSet:

; 1283 :     }
; 1284 :     else {
; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,

  000ad	53		 push	 ebx
  000ae	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  000b1	2b cb		 sub	 ecx, ebx
  000b3	03 ca		 add	 ecx, edx
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 _memcpy

; 1286 :                 dictLength);
; 1287 :         state->whave = dictLength;
; 1288 :     }
; 1289 :     state->havedict = 1;

  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000be	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  000c1	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000c8	33 c0		 xor	 eax, eax
  000ca	5f		 pop	 edi

; 1292 : }

  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 20		 je	 SHORT $LN3@inflateGet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 19		 je	 SHORT $LN3@inflateGet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 41 08 02	 test	 BYTE PTR [ecx+8], 2
  00015	74 13		 je	 SHORT $LN3@inflateGet

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1307 :     head->done = 0;

  0001d	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1308 :     return Z_OK;

  00024	33 c0		 xor	 eax, eax

; 1309 : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN3@inflateGet:

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1309 : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1331 :     next = 0;
; 1332 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])
; 1336 :             got = 0;
; 1337 :         else
; 1338 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1339 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1340 :     }
; 1341 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1342 :     return next;

  00062	8b c6		 mov	 eax, esi

; 1343 : }

  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1340 :     }
; 1341 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1342 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi

; 1343 : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
tv394 = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1347 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 db		 test	 ebx, ebx
  0000a	0f 84 d5 00 00
	00		 je	 $LN5@inflateSyn
  00010	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 ca 00 00
	00		 je	 $LN5@inflateSyn

; 1355 :     state = (struct inflate_state FAR *)strm->state;
; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001e	85 c0		 test	 eax, eax
  00020	75 11		 jne	 SHORT $LN16@inflateSyn
  00022	83 7f 3c 08	 cmp	 DWORD PTR [edi+60], 8
  00026	73 0b		 jae	 SHORT $LN16@inflateSyn
  00028	5f		 pop	 edi
  00029	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH

; 1386 : }

  0002e	5b		 pop	 ebx
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN16@inflateSyn:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  00033	83 3f 1f	 cmp	 DWORD PTR [edi], 31	; 0000001fH
  00036	56		 push	 esi
  00037	74 5c		 je	 SHORT $LN14@inflateSyn

; 1360 :         state->mode = SYNC;
; 1361 :         state->hold <<= state->bits & 7;

  00039	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]
  0003c	8b ca		 mov	 ecx, edx
  0003e	8b 77 38	 mov	 esi, DWORD PTR [edi+56]
  00041	83 e1 07	 and	 ecx, 7
  00044	d3 e6		 shl	 esi, cl

; 1362 :         state->bits -= state->bits & 7;

  00046	2b d1		 sub	 edx, ecx

; 1363 :         len = 0;

  00048	33 c9		 xor	 ecx, ecx
  0004a	c7 07 1f 00 00
	00		 mov	 DWORD PTR [edi], 31	; 0000001fH
  00050	89 77 38	 mov	 DWORD PTR [edi+56], esi
  00053	89 57 3c	 mov	 DWORD PTR [edi+60], edx

; 1364 :         while (state->bits >= 8) {

  00056	83 fa 08	 cmp	 edx, 8
  00059	72 1e		 jb	 SHORT $LN3@inflateSyn
  0005b	0f 1f 44 00 00	 npad	 5
$LL2@inflateSyn:

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  00060	8a 47 38	 mov	 al, BYTE PTR [edi+56]

; 1366 :             state->hold >>= 8;
; 1367 :             state->bits -= 8;

  00063	83 ea 08	 sub	 edx, 8
  00066	88 44 0d 08	 mov	 BYTE PTR _buf$[ebp+ecx], al
  0006a	41		 inc	 ecx
  0006b	c1 ee 08	 shr	 esi, 8
  0006e	89 77 38	 mov	 DWORD PTR [edi+56], esi
  00071	83 fa 08	 cmp	 edx, 8
  00074	73 ea		 jae	 SHORT $LL2@inflateSyn
  00076	89 57 3c	 mov	 DWORD PTR [edi+60], edx
$LN3@inflateSyn:

; 1368 :         }
; 1369 :         state->have = 0;

  00079	8d 77 68	 lea	 esi, DWORD PTR [edi+104]

; 1370 :         syncsearch(&(state->have), buf, len);

  0007c	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  0007f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00085	51		 push	 ecx
  00086	8b ce		 mov	 ecx, esi
  00088	e8 00 00 00 00	 call	 _syncsearch
  0008d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00090	83 c4 04	 add	 esp, 4
  00093	eb 03		 jmp	 SHORT $LN7@inflateSyn
$LN14@inflateSyn:
  00095	8d 77 68	 lea	 esi, DWORD PTR [edi+104]
$LN7@inflateSyn:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00098	8b 13		 mov	 edx, DWORD PTR [ebx]
  0009a	8b ce		 mov	 ecx, esi
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _syncsearch

; 1375 :     strm->avail_in -= len;

  000a2	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000a5	83 c4 04	 add	 esp, 4

; 1376 :     strm->next_in += len;

  000a8	01 03		 add	 DWORD PTR [ebx], eax

; 1377 :     strm->total_in += len;

  000aa	03 43 08	 add	 eax, DWORD PTR [ebx+8]
  000ad	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  000b0	83 3e 04	 cmp	 DWORD PTR [esi], 4
  000b3	89 45 08	 mov	 DWORD PTR tv394[ebp], eax
  000b6	74 0c		 je	 SHORT $LN8@inflateSyn
  000b8	5e		 pop	 esi
  000b9	5f		 pop	 edi
  000ba	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1386 : }

  000bf	5b		 pop	 ebx
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
$LN8@inflateSyn:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  000c4	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1382 :     inflateReset(strm);

  000c7	53		 push	 ebx
  000c8	e8 00 00 00 00	 call	 _inflateReset@4

; 1383 :     strm->total_in = in;  strm->total_out = out;

  000cd	8b 45 08	 mov	 eax, DWORD PTR tv394[ebp]
  000d0	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000d3	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1384 :     state->mode = TYPE;
; 1385 :     return Z_OK;

  000d6	33 c0		 xor	 eax, eax
  000d8	5e		 pop	 esi
  000d9	c7 07 0b 00 00
	00		 mov	 DWORD PTR [edi], 11	; 0000000bH
  000df	5f		 pop	 edi

; 1386 : }

  000e0	5b		 pop	 ebx
  000e1	5d		 pop	 ebp
  000e2	c2 04 00	 ret	 4
$LN5@inflateSyn:
  000e5	5f		 pop	 edi

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000e6	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1386 : }

  000eb	5b		 pop	 ebx
  000ec	5d		 pop	 ebp
  000ed	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 21		 je	 SHORT $LN3@inflateSyn
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 1a		 je	 SHORT $LN3@inflateSyn

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  00011	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  00014	75 0f		 jne	 SHORT $LN5@inflateSyn
  00016	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0001a	75 09		 jne	 SHORT $LN5@inflateSyn
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1404 : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  00025	33 c0		 xor	 eax, eax

; 1404 : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN3@inflateSyn:

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1404 : }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1409 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00003	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	0f 84 44 01 00
	00		 je	 $LN3@inflateCop
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _source$[ebp]
  00012	85 f6		 test	 esi, esi
  00014	0f 84 39 01 00
	00		 je	 $LN3@inflateCop
  0001a	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  0001d	85 ff		 test	 edi, edi
  0001f	0f 84 2e 01 00
	00		 je	 $LN3@inflateCop
  00025	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 23 01 00
	00		 je	 $LN3@inflateCop
  00030	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00034	0f 84 19 01 00
	00		 je	 $LN3@inflateCop

; 1419 :     state = (struct inflate_state FAR *)source->state;
; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)

  0003a	53		 push	 ebx
  0003b	68 cc 1b 00 00	 push	 7116			; 00001bccH
  00040	6a 01		 push	 1
  00042	ff 76 28	 push	 DWORD PTR [esi+40]
  00045	ff d0		 call	 eax
  00047	8b d8		 mov	 ebx, eax
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0004c	85 db		 test	 ebx, ebx
  0004e	74 38		 je	 SHORT $LN13@inflateCop

; 1425 :     window = Z_NULL;
; 1426 :     if (state->window != Z_NULL) {

  00050	83 7f 34 00	 cmp	 DWORD PTR [edi+52], 0
  00054	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  0005b	74 37		 je	 SHORT $LN11@inflateCop

; 1427 :         window = (unsigned char FAR *)

  0005d	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	d3 e0		 shl	 eax, cl
  00067	6a 01		 push	 1
  00069	50		 push	 eax
  0006a	ff 76 28	 push	 DWORD PTR [esi+40]
  0006d	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00070	ff d0		 call	 eax
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1429 :         if (window == Z_NULL) {

  00078	85 c0		 test	 eax, eax
  0007a	75 18		 jne	 SHORT $LN11@inflateCop

; 1430 :             ZFREE(source, copy);

  0007c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0007f	53		 push	 ebx
  00080	ff 76 28	 push	 DWORD PTR [esi+40]
  00083	ff d0		 call	 eax
  00085	83 c4 08	 add	 esp, 8
$LN13@inflateCop:

; 1431 :             return Z_MEM_ERROR;

  00088	5b		 pop	 ebx
  00089	5f		 pop	 edi
  0008a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 1451 : }

  0008f	5e		 pop	 esi
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
$LN11@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  00094	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00097	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  0009a	68 cc 1b 00 00	 push	 7116			; 00001bccH
  0009f	57		 push	 edi
  000a0	53		 push	 ebx
  000a1	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  000a4	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
  000a8	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000ac	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [esi+32]
  000b0	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000b4	f3 0f 7e 46 30	 movq	 xmm0, QWORD PTR [esi+48]
  000b9	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000be	e8 00 00 00 00	 call	 _memcpy

; 1438 :     if (state->lencode >= state->codes &&

  000c3	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  000c6	8d 87 30 05 00
	00		 lea	 eax, DWORD PTR [edi+1328]
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	3b c8		 cmp	 ecx, eax
  000d1	72 38		 jb	 SHORT $LN7@inflateCop
  000d3	8d 87 bc 1b 00
	00		 lea	 eax, DWORD PTR [edi+7100]
  000d9	3b c8		 cmp	 ecx, eax
  000db	77 2e		 ja	 SHORT $LN7@inflateCop

; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000dd	2b cf		 sub	 ecx, edi
  000df	8d 81 d0 fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1328]
  000e5	c1 f8 02	 sar	 eax, 2
  000e8	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  000ed	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000f0	89 43 4c	 mov	 DWORD PTR [ebx+76], eax

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000f3	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  000f6	2b c7		 sub	 eax, edi
  000f8	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  000fd	c1 f8 02	 sar	 eax, 2
  00100	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00105	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00108	89 43 50	 mov	 DWORD PTR [ebx+80], eax
$LN7@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  0010b	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]

; 1444 :     if (window != Z_NULL) {

  0010e	8b 75 0c	 mov	 esi, DWORD PTR _window$1$[ebp]
  00111	2b c7		 sub	 eax, edi
  00113	2d 30 05 00 00	 sub	 eax, 1328		; 00000530H
  00118	c1 f8 02	 sar	 eax, 2
  0011b	05 4c 01 00 00	 add	 eax, 332		; 0000014cH
  00120	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00123	89 43 6c	 mov	 DWORD PTR [ebx+108], eax
  00126	85 f6		 test	 esi, esi
  00128	74 17		 je	 SHORT $LN8@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  0012a	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	d3 e0		 shl	 eax, cl

; 1446 :         zmemcpy(window, state->window, wsize);

  00134	50		 push	 eax
  00135	ff 77 34	 push	 DWORD PTR [edi+52]
  00138	56		 push	 esi
  00139	e8 00 00 00 00	 call	 _memcpy
  0013e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;
; 1449 :     dest->state = (struct internal_state FAR *)copy;

  00141	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00144	89 73 34	 mov	 DWORD PTR [ebx+52], esi
  00147	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 1450 :     return Z_OK;

  0014a	33 c0		 xor	 eax, eax
  0014c	5b		 pop	 ebx
  0014d	5f		 pop	 edi

; 1451 : }

  0014e	5e		 pop	 esi
  0014f	5d		 pop	 ebp
  00150	c2 08 00	 ret	 8
$LN3@inflateCop:
  00153	5f		 pop	 edi

; 1418 :         return Z_STREAM_ERROR;

  00154	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1451 : }

  00159	5e		 pop	 esi
  0015a	5d		 pop	 ebp
  0015b	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1456 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1a		 je	 SHORT $LN3@inflateUnd
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 13		 je	 SHORT $LN3@inflateUnd

; 1460 :     state = (struct inflate_state FAR *)strm->state;
; 1461 :     state->sane = !subvert;
; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  00011	c7 80 c0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7104], 1

; 1466 :     return Z_DATA_ERROR;

  0001b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1467 : #endif
; 1468 : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN3@inflateUnd:

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1467 : #endif
; 1468 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 4e		 je	 SHORT $LN3@inflateMar
  0000a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000d	85 c0		 test	 eax, eax
  0000f	74 47		 je	 SHORT $LN3@inflateMar

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +

  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00016	75 12		 jne	 SHORT $LN7@inflateMar
  00018	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0001b	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  00021	c1 e0 10	 shl	 eax, 16			; 00000010H
  00024	03 c1		 add	 eax, ecx

; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1480 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN7@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +

  0002a	83 f9 18	 cmp	 ecx, 24			; 00000018H
  0002d	75 18		 jne	 SHORT $LN5@inflateMar
  0002f	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  00035	2b 48 40	 sub	 ecx, DWORD PTR [eax+64]
  00038	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0003e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00041	03 c1		 add	 eax, ecx

; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1480 : }

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +

  00047	8b 80 c4 1b 00
	00		 mov	 eax, DWORD PTR [eax+7108]
  0004d	33 c9		 xor	 ecx, ecx
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1480 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN3@inflateMar:

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00058	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1480 : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
END
