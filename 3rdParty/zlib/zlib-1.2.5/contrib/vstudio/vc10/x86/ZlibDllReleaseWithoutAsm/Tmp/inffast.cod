; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inffast.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_fast
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\inffast.c
;	COMDAT _inflate_fast
_TEXT	SEGMENT
_whave$1$ = -72						; size = 4
_op$7$ = -68						; size = 4
_beg$1$ = -64						; size = 4
_end$1$ = -60						; size = 4
_last$1$ = -56						; size = 4
_window$1$ = -52					; size = 4
_wsize$1$ = -48						; size = 4
_dcode$1$ = -44						; size = 4
_lcode$1$ = -40						; size = 4
_op$6$ = -36						; size = 4
_op$3$ = -36						; size = 4
_bits$1$ = -36						; size = 4
_wnext$1$ = -32						; size = 4
_dmask$1$ = -28						; size = 4
_lmask$1$ = -24						; size = 4
_state$1$ = -20						; size = 4
_strm$1$ = -16						; size = 4
$T1 = -12						; size = 4
_dist$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
_in$1$ = -4						; size = 4
_inflate_fast PROC					; COMDAT
; _strm$ = ecx
; _start$ = edx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 7d f0	 mov	 DWORD PTR _strm$1$[ebp], edi

; 71   :     struct inflate_state FAR *state;
; 72   :     unsigned char FAR *in;      /* local strm->next_in */
; 73   :     unsigned char FAR *last;    /* while in < last, enough input available */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  0000e	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 99   :     in = strm->next_in - OFF;

  00011	8b 1f		 mov	 ebx, DWORD PTR [edi]

; 100  :     last = in + (strm->avail_in - 5);

  00013	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00016	4b		 dec	 ebx

; 101  :     out = strm->next_out - OFF;

  00017	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  0001a	83 c0 fb	 add	 eax, -5			; fffffffbH
  0001d	03 c3		 add	 eax, ebx
  0001f	89 4d ec	 mov	 DWORD PTR _state$1$[ebp], ecx
  00022	89 45 c8	 mov	 DWORD PTR _last$1$[ebp], eax
  00025	4e		 dec	 esi

; 102  :     beg = out - (start - strm->avail_out);

  00026	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00029	8b f8		 mov	 edi, eax

; 103  :     end = out + (strm->avail_out - 257);

  0002b	05 ff fe ff ff	 add	 eax, -257		; fffffeffH
  00030	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  00033	03 c6		 add	 eax, esi
  00035	2b fa		 sub	 edi, edx

; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;
; 108  :     whave = state->whave;
; 109  :     wnext = state->wnext;
; 110  :     window = state->window;
; 111  :     hold = state->hold;

  00037	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0003a	03 fe		 add	 edi, esi
  0003c	89 45 c4	 mov	 DWORD PTR _end$1$[ebp], eax
  0003f	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00042	89 45 d0	 mov	 DWORD PTR _wsize$1$[ebp], eax
  00045	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00048	89 45 b8	 mov	 DWORD PTR _whave$1$[ebp], eax
  0004b	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0004e	89 45 e0	 mov	 DWORD PTR _wnext$1$[ebp], eax
  00051	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00054	89 45 cc	 mov	 DWORD PTR _window$1$[ebp], eax

; 112  :     bits = state->bits;
; 113  :     lcode = state->lencode;

  00057	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0005a	89 45 d8	 mov	 DWORD PTR _lcode$1$[ebp], eax

; 114  :     dcode = state->distcode;

  0005d	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00060	89 45 d4	 mov	 DWORD PTR _dcode$1$[ebp], eax

; 115  :     lmask = (1U << state->lenbits) - 1;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	89 45 e8	 mov	 DWORD PTR _lmask$1$[ebp], eax

; 116  :     dmask = (1U << state->distbits) - 1;

  0006b	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  00071	89 7d c0	 mov	 DWORD PTR _beg$1$[ebp], edi
  00074	8b 79 3c	 mov	 edi, DWORD PTR [ecx+60]
  00077	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  0007a	d3 65 e8	 shl	 DWORD PTR _lmask$1$[ebp], cl
  0007d	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  00080	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00083	ff 4d e8	 dec	 DWORD PTR _lmask$1$[ebp]
  00086	d3 e0		 shl	 eax, cl
  00088	48		 dec	 eax
  00089	89 45 e4	 mov	 DWORD PTR _dmask$1$[ebp], eax
  0008c	0f 1f 40 00	 npad	 4
$LL4@inflate_fa:

; 117  : 
; 118  :     /* decode literals and length/distances until end-of-block or not enough
; 119  :        input data or output space */
; 120  :     do {
; 121  :         if (bits < 15) {

  00090	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00093	73 1d		 jae	 SHORT $LN22@inflate_fa

; 122  :             hold += (unsigned long)(PUP(in)) << bits;

  00095	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  00099	8b cf		 mov	 ecx, edi
  0009b	d3 e0		 shl	 eax, cl

; 123  :             bits += 8;
; 124  :             hold += (unsigned long)(PUP(in)) << bits;

  0009d	83 c3 02	 add	 ebx, 2
  000a0	03 d0		 add	 edx, eax
  000a2	89 5d fc	 mov	 DWORD PTR _in$1$[ebp], ebx
  000a5	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  000a8	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  000ab	d3 e0		 shl	 eax, cl
  000ad	03 d0		 add	 edx, eax

; 125  :             bits += 8;

  000af	83 c7 10	 add	 edi, 16			; 00000010H
$LN22@inflate_fa:

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _lmask$1$[ebp]
  000b5	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000b8	23 c2		 and	 eax, edx
  000ba	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000bd	8b c8		 mov	 ecx, eax
  000bf	c1 e9 08	 shr	 ecx, 8
  000c2	0f b6 c9	 movzx	 ecx, cl

; 128  :       dolen:
; 129  :         op = (unsigned)(here.bits);
; 130  :         hold >>= op;

  000c5	d3 ea		 shr	 edx, cl

; 131  :         bits -= op;

  000c7	2b f9		 sub	 edi, ecx
  000c9	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000cc	0f b6 c8	 movzx	 ecx, al

; 132  :         op = (unsigned)(here.op);
; 133  :         if (op == 0) {                          /* literal */

  000cf	84 c0		 test	 al, al
  000d1	74 4a		 je	 SHORT $LN72@inflate_fa

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  000d3	8b d8		 mov	 ebx, eax
  000d5	c1 eb 10	 shr	 ebx, 16			; 00000010H
$dolen$106:

; 138  :         }
; 139  :         else if (op & 16) {                     /* length base */

  000d8	f6 c1 10	 test	 cl, 16			; 00000010H
  000db	75 4b		 jne	 SHORT $LN73@inflate_fa

; 291  :             }
; 292  :         }
; 293  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000dd	f6 c1 40	 test	 cl, 64			; 00000040H
  000e0	0f 85 0c 03 00
	00		 jne	 $LN52@inflate_fa

; 294  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  000e6	ba 01 00 00 00	 mov	 edx, 1
  000eb	c1 e8 10	 shr	 eax, 16			; 00000010H
  000ee	d3 e2		 shl	 edx, cl
  000f0	8b 4d d8	 mov	 ecx, DWORD PTR _lcode$1$[ebp]
  000f3	4a		 dec	 edx
  000f4	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  000f7	03 d0		 add	 edx, eax
  000f9	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  000fc	8b d8		 mov	 ebx, eax
  000fe	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00101	8b cb		 mov	 ecx, ebx
  00103	c1 e9 08	 shr	 ecx, 8
  00106	0f b6 c9	 movzx	 ecx, cl
  00109	d3 ea		 shr	 edx, cl
  0010b	2b f9		 sub	 edi, ecx
  0010d	0f b6 cb	 movzx	 ecx, bl
  00110	c1 eb 10	 shr	 ebx, 16			; 00000010H
  00113	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00116	85 c9		 test	 ecx, ecx
  00118	75 be		 jne	 SHORT $dolen$106

; 132  :         op = (unsigned)(here.op);
; 133  :         if (op == 0) {                          /* literal */

  0011a	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN72@inflate_fa:

; 134  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 135  :                     "inflate:         literal '%c'\n" :
; 136  :                     "inflate:         literal 0x%02x\n", here.val));
; 137  :             PUP(out) = (unsigned char)(here.val);

  0011d	46		 inc	 esi
  0011e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00121	88 06		 mov	 BYTE PTR [esi], al

; 261  :                     }
; 262  :                     if (len) {

  00123	e9 6e 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 140  :             len = (unsigned)(here.val);
; 141  :             op &= 15;                           /* number of extra bits */

  00128	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0012b	89 4d dc	 mov	 DWORD PTR _op$3$[ebp], ecx

; 142  :             if (op) {

  0012e	74 2a		 je	 SHORT $LN27@inflate_fa

; 143  :                 if (bits < op) {

  00130	3b f9		 cmp	 edi, ecx
  00132	73 16		 jae	 SHORT $LN28@inflate_fa

; 144  :                     hold += (unsigned long)(PUP(in)) << bits;

  00134	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00137	8b cf		 mov	 ecx, edi
  00139	40		 inc	 eax
  0013a	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  0013d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00140	d3 e0		 shl	 eax, cl
  00142	8b 4d dc	 mov	 ecx, DWORD PTR _op$3$[ebp]
  00145	03 d0		 add	 edx, eax

; 145  :                     bits += 8;

  00147	83 c7 08	 add	 edi, 8
$LN28@inflate_fa:

; 146  :                 }
; 147  :                 len += (unsigned)hold & ((1U << op) - 1);

  0014a	b8 01 00 00 00	 mov	 eax, 1
  0014f	d3 e0		 shl	 eax, cl
  00151	48		 dec	 eax
  00152	23 c2		 and	 eax, edx

; 148  :                 hold >>= op;

  00154	d3 ea		 shr	 edx, cl
  00156	03 d8		 add	 ebx, eax

; 149  :                 bits -= op;

  00158	2b f9		 sub	 edi, ecx
$LN27@inflate_fa:

; 150  :             }
; 151  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 152  :             if (bits < 15) {

  0015a	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  0015d	73 24		 jae	 SHORT $LN29@inflate_fa

; 153  :                 hold += (unsigned long)(PUP(in)) << bits;

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00162	8b cf		 mov	 ecx, edi
  00164	40		 inc	 eax
  00165	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00168	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0016b	d3 e0		 shl	 eax, cl

; 154  :                 bits += 8;
; 155  :                 hold += (unsigned long)(PUP(in)) << bits;

  0016d	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00170	03 d0		 add	 edx, eax
  00172	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00175	40		 inc	 eax
  00176	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00179	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0017c	d3 e0		 shl	 eax, cl
  0017e	03 d0		 add	 edx, eax

; 156  :                 bits += 8;

  00180	83 c7 10	 add	 edi, 16			; 00000010H
$LN29@inflate_fa:

; 157  :             }
; 158  :             here = dcode[hold & dmask];

  00183	8b 45 e4	 mov	 eax, DWORD PTR _dmask$1$[ebp]
  00186	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  00189	23 c2		 and	 eax, edx
  0018b	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0018e	8b c8		 mov	 ecx, eax
  00190	c1 e9 08	 shr	 ecx, 8
  00193	0f b6 c9	 movzx	 ecx, cl

; 159  :           dodist:
; 160  :             op = (unsigned)(here.bits);
; 161  :             hold >>= op;

  00196	d3 ea		 shr	 edx, cl

; 162  :             bits -= op;

  00198	2b f9		 sub	 edi, ecx
  0019a	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0019d	c1 6d f4 10	 shr	 DWORD PTR $T1[ebp], 16	; 00000010H
  001a1	0f b6 c8	 movzx	 ecx, al
  001a4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 163  :             op = (unsigned)(here.op);
; 164  :             if (op & 16) {                      /* distance base */

  001a7	f6 c1 10	 test	 cl, 16			; 00000010H
  001aa	75 46		 jne	 SHORT $LN74@inflate_fa
  001ac	0f 1f 40 00	 npad	 4
$dodist$107:

; 280  :                     }
; 281  :                 }
; 282  :             }
; 283  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001b0	f6 c1 40	 test	 cl, 64			; 00000040H
  001b3	0f 85 5e 02 00
	00		 jne	 $LN50@inflate_fa

; 284  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001b9	ba 01 00 00 00	 mov	 edx, 1
  001be	c1 e8 10	 shr	 eax, 16			; 00000010H
  001c1	d3 e2		 shl	 edx, cl
  001c3	8b 4d d4	 mov	 ecx, DWORD PTR _dcode$1$[ebp]
  001c6	4a		 dec	 edx
  001c7	23 55 f8	 and	 edx, DWORD PTR _hold$1$[ebp]
  001ca	03 d0		 add	 edx, eax
  001cc	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  001cf	8b c8		 mov	 ecx, eax
  001d1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001d4	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  001d7	c1 6d f4 10	 shr	 DWORD PTR $T1[ebp], 16	; 00000010H
  001db	c1 e9 08	 shr	 ecx, 8
  001de	0f b6 c9	 movzx	 ecx, cl
  001e1	d3 ea		 shr	 edx, cl
  001e3	2b f9		 sub	 edi, ecx
  001e5	8b c8		 mov	 ecx, eax
  001e7	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001ea	0f b6 c9	 movzx	 ecx, cl
  001ed	f6 c1 10	 test	 cl, 16			; 00000010H
  001f0	74 be		 je	 SHORT $dodist$107
$LN74@inflate_fa:

; 165  :                 dist = (unsigned)(here.val);
; 166  :                 op &= 15;                       /* number of extra bits */

  001f2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001f5	89 4d dc	 mov	 DWORD PTR _op$6$[ebp], ecx

; 167  :                 if (bits < op) {

  001f8	3b f9		 cmp	 edi, ecx
  001fa	73 30		 jae	 SHORT $LN33@inflate_fa

; 168  :                     hold += (unsigned long)(PUP(in)) << bits;

  001fc	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  001ff	8b cf		 mov	 ecx, edi
  00201	40		 inc	 eax

; 169  :                     bits += 8;

  00202	83 c7 08	 add	 edi, 8
  00205	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  00208	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0020b	d3 e0		 shl	 eax, cl

; 170  :                     if (bits < op) {

  0020d	8b 4d dc	 mov	 ecx, DWORD PTR _op$6$[ebp]
  00210	03 d0		 add	 edx, eax
  00212	3b f9		 cmp	 edi, ecx
  00214	73 16		 jae	 SHORT $LN33@inflate_fa

; 171  :                         hold += (unsigned long)(PUP(in)) << bits;

  00216	8b 45 fc	 mov	 eax, DWORD PTR _in$1$[ebp]
  00219	8b cf		 mov	 ecx, edi
  0021b	40		 inc	 eax
  0021c	89 45 fc	 mov	 DWORD PTR _in$1$[ebp], eax
  0021f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00222	d3 e0		 shl	 eax, cl
  00224	8b 4d dc	 mov	 ecx, DWORD PTR _op$6$[ebp]
  00227	03 d0		 add	 edx, eax

; 172  :                         bits += 8;

  00229	83 c7 08	 add	 edi, 8
$LN33@inflate_fa:

; 173  :                     }
; 174  :                 }
; 175  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0022c	b8 01 00 00 00	 mov	 eax, 1

; 176  : #ifdef INFLATE_STRICT
; 177  :                 if (dist > dmax) {
; 178  :                     strm->msg = (char *)"invalid distance too far back";
; 179  :                     state->mode = BAD;
; 180  :                     break;
; 181  :                 }
; 182  : #endif
; 183  :                 hold >>= op;
; 184  :                 bits -= op;

  00231	2b f9		 sub	 edi, ecx
  00233	d3 e0		 shl	 eax, cl
  00235	48		 dec	 eax
  00236	89 7d dc	 mov	 DWORD PTR _bits$1$[ebp], edi
  00239	23 c2		 and	 eax, edx
  0023b	d3 ea		 shr	 edx, cl
  0023d	03 45 f4	 add	 eax, DWORD PTR $T1[ebp]

; 185  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 186  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00240	8b ce		 mov	 ecx, esi
  00242	2b 4d c0	 sub	 ecx, DWORD PTR _beg$1$[ebp]
  00245	89 45 f4	 mov	 DWORD PTR _dist$1$[ebp], eax
  00248	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0024b	89 4d bc	 mov	 DWORD PTR _op$7$[ebp], ecx

; 187  :                 if (dist > op) {                /* see if copy from window */

  0024e	3b c1		 cmp	 eax, ecx
  00250	0f 86 fb 00 00
	00		 jbe	 $LN34@inflate_fa

; 188  :                     op = dist - op;             /* distance back in window */

  00256	8b c8		 mov	 ecx, eax
  00258	2b 4d bc	 sub	 ecx, DWORD PTR _op$7$[ebp]

; 189  :                     if (op > whave) {

  0025b	3b 4d b8	 cmp	 ecx, DWORD PTR _whave$1$[ebp]
  0025e	76 10		 jbe	 SHORT $LN37@inflate_fa

; 190  :                         if (state->sane) {

  00260	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  00263	83 b8 c0 1b 00
	00 00		 cmp	 DWORD PTR [eax+7104], 0
  0026a	0f 85 c2 01 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 194  :                             break;
; 195  :                         }
; 196  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 197  :                         if (len <= op - whave) {
; 198  :                             do {
; 199  :                                 PUP(out) = 0;
; 200  :                             } while (--len);
; 201  :                             continue;
; 202  :                         }
; 203  :                         len -= op - whave;
; 204  :                         do {
; 205  :                             PUP(out) = 0;
; 206  :                         } while (--op > whave);
; 207  :                         if (op == 0) {
; 208  :                             from = out - dist;
; 209  :                             do {
; 210  :                                 PUP(out) = PUP(from);
; 211  :                             } while (--len);
; 212  :                             continue;
; 213  :                         }
; 214  : #endif
; 215  :                     }
; 216  :                     from = window - OFF;

  00270	8b 45 cc	 mov	 eax, DWORD PTR _window$1$[ebp]

; 217  :                     if (wnext == 0) {           /* very common case */

  00273	8b 7d e0	 mov	 edi, DWORD PTR _wnext$1$[ebp]
  00276	48		 dec	 eax
  00277	2b c1		 sub	 eax, ecx
  00279	85 ff		 test	 edi, edi
  0027b	75 1b		 jne	 SHORT $LN38@inflate_fa

; 218  :                         from += wsize - op;

  0027d	8b 7d d0	 mov	 edi, DWORD PTR _wsize$1$[ebp]
  00280	03 f8		 add	 edi, eax

; 219  :                         if (op < len) {         /* some from window */

  00282	3b cb		 cmp	 ecx, ebx
  00284	73 73		 jae	 SHORT $LN69@inflate_fa

; 220  :                             len -= op;

  00286	2b d9		 sub	 ebx, ecx
$LL7@inflate_fa:

; 221  :                             do {
; 222  :                                 PUP(out) = PUP(from);

  00288	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0028b	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  0028e	46		 inc	 esi
  0028f	88 06		 mov	 BYTE PTR [esi], al

; 223  :                             } while (--op);

  00291	83 e9 01	 sub	 ecx, 1
  00294	75 f2		 jne	 SHORT $LL7@inflate_fa

; 224  :                             from = out - dist;  /* rest from output */
; 225  :                         }
; 226  :                     }

  00296	eb 5c		 jmp	 SHORT $LN104@inflate_fa
$LN38@inflate_fa:

; 227  :                     else if (wnext < op) {      /* wrap around window */

  00298	03 f8		 add	 edi, eax
  0029a	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  0029d	3b c1		 cmp	 eax, ecx
  0029f	73 3f		 jae	 SHORT $LN41@inflate_fa

; 228  :                         from += wsize + wnext - op;

  002a1	03 7d d0	 add	 edi, DWORD PTR _wsize$1$[ebp]

; 229  :                         op -= wnext;

  002a4	2b c8		 sub	 ecx, eax

; 230  :                         if (op < len) {         /* some from end of window */

  002a6	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  002a9	3b cb		 cmp	 ecx, ebx
  002ab	73 4c		 jae	 SHORT $LN69@inflate_fa

; 231  :                             len -= op;

  002ad	2b d9		 sub	 ebx, ecx
  002af	2b fe		 sub	 edi, esi
$LL10@inflate_fa:

; 232  :                             do {
; 233  :                                 PUP(out) = PUP(from);

  002b1	8a 44 37 01	 mov	 al, BYTE PTR [edi+esi+1]
  002b5	46		 inc	 esi
  002b6	88 06		 mov	 BYTE PTR [esi], al

; 234  :                             } while (--op);

  002b8	83 e9 01	 sub	 ecx, 1
  002bb	75 f4		 jne	 SHORT $LL10@inflate_fa

; 235  :                             from = window - OFF;

  002bd	8b 7d cc	 mov	 edi, DWORD PTR _window$1$[ebp]

; 236  :                             if (wnext < len) {  /* some from start of window */

  002c0	8b 45 e0	 mov	 eax, DWORD PTR _wnext$1$[ebp]
  002c3	4f		 dec	 edi
  002c4	3b c3		 cmp	 eax, ebx
  002c6	73 31		 jae	 SHORT $LN69@inflate_fa

; 237  :                                 op = wnext;

  002c8	8b c8		 mov	 ecx, eax

; 238  :                                 len -= op;

  002ca	2b d8		 sub	 ebx, eax
  002cc	0f 1f 40 00	 npad	 4
$LL13@inflate_fa:

; 239  :                                 do {
; 240  :                                     PUP(out) = PUP(from);

  002d0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002d3	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002d6	46		 inc	 esi
  002d7	88 06		 mov	 BYTE PTR [esi], al

; 241  :                                 } while (--op);

  002d9	83 e9 01	 sub	 ecx, 1
  002dc	75 f2		 jne	 SHORT $LL13@inflate_fa

; 242  :                                 from = out - dist;      /* rest from output */
; 243  :                             }
; 244  :                         }
; 245  :                     }

  002de	eb 14		 jmp	 SHORT $LN104@inflate_fa
$LN41@inflate_fa:

; 246  :                     else {                      /* contiguous in window */
; 247  :                         from += wnext - op;
; 248  :                         if (op < len) {         /* some from window */

  002e0	3b cb		 cmp	 ecx, ebx
  002e2	73 15		 jae	 SHORT $LN69@inflate_fa

; 249  :                             len -= op;

  002e4	2b d9		 sub	 ebx, ecx
$LL16@inflate_fa:

; 250  :                             do {
; 251  :                                 PUP(out) = PUP(from);

  002e6	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002e9	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  002ec	46		 inc	 esi
  002ed	88 06		 mov	 BYTE PTR [esi], al

; 252  :                             } while (--op);

  002ef	83 e9 01	 sub	 ecx, 1
  002f2	75 f2		 jne	 SHORT $LL16@inflate_fa
$LN104@inflate_fa:

; 253  :                             from = out - dist;  /* rest from output */
; 254  :                         }
; 255  :                     }
; 256  :                     while (len > 2) {

  002f4	8b fe		 mov	 edi, esi
  002f6	2b 7d f4	 sub	 edi, DWORD PTR _dist$1$[ebp]
$LN69@inflate_fa:
  002f9	83 fb 02	 cmp	 ebx, 2
  002fc	76 36		 jbe	 SHORT $LN18@inflate_fa
  002fe	8d 4b fd	 lea	 ecx, DWORD PTR [ebx-3]
  00301	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00306	f7 e1		 mul	 ecx
  00308	d1 ea		 shr	 edx, 1
  0030a	42		 inc	 edx
  0030b	0f 1f 44 00 00	 npad	 5
$LL17@inflate_fa:

; 257  :                         PUP(out) = PUP(from);

  00310	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]

; 258  :                         PUP(out) = PUP(from);
; 259  :                         PUP(out) = PUP(from);
; 260  :                         len -= 3;

  00314	83 eb 03	 sub	 ebx, 3
  00317	88 46 01	 mov	 BYTE PTR [esi+1], al
  0031a	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  0031e	83 c7 03	 add	 edi, 3
  00321	88 46 02	 mov	 BYTE PTR [esi+2], al
  00324	83 c6 03	 add	 esi, 3
  00327	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0032a	88 06		 mov	 BYTE PTR [esi], al
  0032c	83 ea 01	 sub	 edx, 1
  0032f	75 df		 jne	 SHORT $LL17@inflate_fa
  00331	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN18@inflate_fa:

; 261  :                     }
; 262  :                     if (len) {

  00334	85 db		 test	 ebx, ebx
  00336	74 58		 je	 SHORT $LN98@inflate_fa

; 263  :                         PUP(out) = PUP(from);

  00338	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0033b	46		 inc	 esi

; 264  :                         if (len > 1)

  0033c	83 fb 01	 cmp	 ebx, 1
  0033f	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00342	88 06		 mov	 BYTE PTR [esi], al
  00344	76 06		 jbe	 SHORT $LN99@inflate_fa

; 265  :                             PUP(out) = PUP(from);

  00346	8a 47 02	 mov	 al, BYTE PTR [edi+2]
  00349	46		 inc	 esi
  0034a	88 06		 mov	 BYTE PTR [esi], al
$LN99@inflate_fa:

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  0034c	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
  0034f	eb 45		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 266  :                     }
; 267  :                 }
; 268  :                 else {
; 269  :                     from = out - dist;          /* copy direct from output */

  00351	8b ce		 mov	 ecx, esi
  00353	2b c8		 sub	 ecx, eax
$LL21@inflate_fa:

; 270  :                     do {                        /* minimum length is three */
; 271  :                         PUP(out) = PUP(from);

  00355	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]

; 272  :                         PUP(out) = PUP(from);
; 273  :                         PUP(out) = PUP(from);

  00359	8d 49 03	 lea	 ecx, DWORD PTR [ecx+3]
  0035c	88 46 01	 mov	 BYTE PTR [esi+1], al

; 274  :                         len -= 3;

  0035f	83 eb 03	 sub	 ebx, 3
  00362	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  00366	88 46 02	 mov	 BYTE PTR [esi+2], al
  00369	83 c6 03	 add	 esi, 3
  0036c	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0036f	88 06		 mov	 BYTE PTR [esi], al

; 275  :                     } while (len > 2);

  00371	83 fb 02	 cmp	 ebx, 2
  00374	77 df		 ja	 SHORT $LL21@inflate_fa

; 276  :                     if (len) {

  00376	85 db		 test	 ebx, ebx
  00378	74 19		 je	 SHORT $LN101@inflate_fa

; 277  :                         PUP(out) = PUP(from);

  0037a	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  0037d	46		 inc	 esi

; 278  :                         if (len > 1)

  0037e	83 fb 01	 cmp	 ebx, 1
  00381	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00384	88 06		 mov	 BYTE PTR [esi], al
  00386	76 0e		 jbe	 SHORT $LN2@inflate_fa

; 279  :                             PUP(out) = PUP(from);

  00388	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0038b	46		 inc	 esi
  0038c	88 06		 mov	 BYTE PTR [esi], al
  0038e	eb 06		 jmp	 SHORT $LN2@inflate_fa
$LN98@inflate_fa:

; 261  :                     }
; 262  :                     if (len) {

  00390	8b 7d dc	 mov	 edi, DWORD PTR _bits$1$[ebp]
$LN101@inflate_fa:

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  00393	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
$LN2@inflate_fa:
  00396	3b 5d c8	 cmp	 ebx, DWORD PTR _last$1$[ebp]
  00399	73 09		 jae	 SHORT $LN103@inflate_fa
  0039b	3b 75 c4	 cmp	 esi, DWORD PTR _end$1$[ebp]
  0039e	0f 82 ec fc ff
	ff		 jb	 $LL4@inflate_fa
$LN103@inflate_fa:

; 308  : 
; 309  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 310  :     len = bits >> 3;

  003a4	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
$LN3@inflate_fa:
  003a7	8b c7		 mov	 eax, edi
  003a9	c1 e8 03	 shr	 eax, 3

; 311  :     in -= len;

  003ac	2b d8		 sub	 ebx, eax

; 312  :     bits -= len << 3;

  003ae	c1 e0 03	 shl	 eax, 3
  003b1	2b f8		 sub	 edi, eax

; 313  :     hold &= (1U << bits) - 1;
; 314  : 
; 315  :     /* update state and return */
; 316  :     strm->next_in = in + OFF;

  003b3	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  003b6	89 01		 mov	 DWORD PTR [ecx], eax

; 317  :     strm->next_out = out + OFF;

  003b8	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  003bb	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 318  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  003be	8b 45 c8	 mov	 eax, DWORD PTR _last$1$[ebp]
  003c1	2b c3		 sub	 eax, ebx
  003c3	83 c0 05	 add	 eax, 5
  003c6	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 319  :     strm->avail_out = (unsigned)(out < end ?

  003c9	8b 45 c4	 mov	 eax, DWORD PTR _end$1$[ebp]
  003cc	2b c6		 sub	 eax, esi
  003ce	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003d3	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  003d6	8b cf		 mov	 ecx, edi
  003d8	b8 01 00 00 00	 mov	 eax, 1
  003dd	d3 e0		 shl	 eax, cl

; 320  :                                  257 + (end - out) : 257 - (out - end));
; 321  :     state->hold = hold;

  003df	8b 4d ec	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003e2	48		 dec	 eax
  003e3	23 c2		 and	 eax, edx

; 322  :     state->bits = bits;

  003e5	89 79 3c	 mov	 DWORD PTR [ecx+60], edi
  003e8	5f		 pop	 edi
  003e9	5e		 pop	 esi
  003ea	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  003ed	5b		 pop	 ebx

; 323  :     return;
; 324  : }

  003ee	8b e5		 mov	 esp, ebp
  003f0	5d		 pop	 ebp
  003f1	c3		 ret	 0
$LN52@inflate_fa:

; 295  :             goto dolen;
; 296  :         }
; 297  :         else if (op & 32) {                     /* end-of-block */

  003f2	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]
  003f5	f6 c1 20	 test	 cl, 32			; 00000020H
  003f8	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  003fb	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  003fe	74 08		 je	 SHORT $LN54@inflate_fa

; 298  :             Tracevv((stderr, "inflate:         end of block\n"));
; 299  :             state->mode = TYPE;

  00400	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 300  :             break;

  00406	eb 9f		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 301  :         }
; 302  :         else {
; 303  :             strm->msg = (char *)"invalid literal/length code";

  00408	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 304  :             state->mode = BAD;

  0040f	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH
  00415	eb 90		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 285  :                 goto dodist;
; 286  :             }
; 287  :             else {
; 288  :                 strm->msg = (char *)"invalid distance code";

  00417	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]

; 289  :                 state->mode = BAD;

  0041a	8b 45 ec	 mov	 eax, DWORD PTR _state$1$[ebp]

; 290  :                 break;

  0041d	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00420	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00427	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH
  0042d	e9 75 ff ff ff	 jmp	 $LN3@inflate_fa
$LN75@inflate_fa:

; 191  :                             strm->msg =

  00432	8b 4d f0	 mov	 ecx, DWORD PTR _strm$1$[ebp]
  00435	8b 5d fc	 mov	 ebx, DWORD PTR _in$1$[ebp]
  00438	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 192  :                                 (char *)"invalid distance too far back";
; 193  :                             state->mode = BAD;

  0043f	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  00445	e9 5d ff ff ff	 jmp	 $LN3@inflate_fa
_inflate_fast ENDP
_TEXT	ENDS
END
