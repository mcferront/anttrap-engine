; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26730.0 

	TITLE	e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

?my_version@?1??deflateInit2_@@9@9 DB '1.2.5', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+2
_configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DD	FLAT:_deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DD	FLAT:_deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DD	FLAT:_deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DD	FLAT:_deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DD	FLAT:_deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DD	FLAT:_deflate_slow
PUBLIC	_deflateCopy@8
PUBLIC	_deflateBound@8
PUBLIC	_deflateTune@20
PUBLIC	_deflateParams@12
PUBLIC	_deflatePrime@12
PUBLIC	_deflateSetHeader@8
PUBLIC	_deflateReset@4
PUBLIC	_deflateSetDictionary@12
PUBLIC	_deflateInit2_@32
PUBLIC	_deflateInit_@16
PUBLIC	_deflateEnd@4
PUBLIC	_deflate@8
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflate@8
_TEXT	SEGMENT
_old_flush$1$ = -8					; size = 4
_val$1$ = -4						; size = 4
_val$1$ = -4						; size = 4
_beg$1$ = 8						; size = 4
_beg$1$ = 8						; size = 4
_beg$1$ = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_deflate@8 PROC						; COMDAT

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 586  :     int old_flush; /* value of flush param for previous deflate call */
; 587  :     deflate_state *s;
; 588  : 
; 589  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 590  :         flush > Z_BLOCK || flush < 0) {

  0000b	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0000e	85 ff		 test	 edi, edi
  00010	0f 84 27 08 00
	00		 je	 $LN11@deflate
  00016	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]
  00019	85 f6		 test	 esi, esi
  0001b	0f 84 1c 08 00
	00		 je	 $LN11@deflate
  00021	83 f8 05	 cmp	 eax, 5
  00024	0f 87 13 08 00
	00		 ja	 $LN11@deflate

; 591  :         return Z_STREAM_ERROR;
; 592  :     }
; 593  :     s = strm->state;
; 594  : 
; 595  :     if (strm->next_out == Z_NULL ||
; 596  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||

  0002a	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  0002e	0f 84 01 08 00
	00		 je	 $LN13@deflate
  00034	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00037	75 0a		 jne	 SHORT $LN14@deflate
  00039	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0003d	0f 85 f2 07 00
	00		 jne	 $LN13@deflate
$LN14@deflate:
  00043	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00046	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  0004c	75 09		 jne	 SHORT $LN12@deflate
  0004e	83 f8 04	 cmp	 eax, 4
  00051	0f 85 de 07 00
	00		 jne	 $LN13@deflate
$LN12@deflate:

; 599  :     }
; 600  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  00057	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  0005b	53		 push	 ebx
  0005c	0f 84 06 06 00
	00		 je	 $LN128@deflate

; 601  : 
; 602  :     s->strm = strm; /* just in case */
; 603  :     old_flush = s->last_flush;

  00062	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00065	89 3e		 mov	 DWORD PTR [esi], edi
  00067	89 55 f8	 mov	 DWORD PTR _old_flush$1$[ebp], edx

; 604  :     s->last_flush = flush;

  0006a	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 605  : 
; 606  :     /* Write the header */
; 607  :     if (s->status == INIT_STATE) {

  0006d	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00070	0f 85 9b 02 00
	00		 jne	 $LN18@deflate

; 608  : #ifdef GZIP
; 609  :         if (s->wrap == 2) {

  00076	83 7e 18 02	 cmp	 DWORD PTR [esi+24], 2
  0007a	0f 85 ed 01 00
	00		 jne	 $LN17@deflate

; 610  :             strm->adler = crc32(0L, Z_NULL, 0);

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 _crc32@12
  0008b	89 47 30	 mov	 DWORD PTR [edi+48], eax

; 611  :             put_byte(s, 31);

  0008e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00091	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00094	c6 04 01 1f	 mov	 BYTE PTR [ecx+eax], 31	; 0000001fH
  00098	ff 46 14	 inc	 DWORD PTR [esi+20]
  0009b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 612  :             put_byte(s, 139);

  0009e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000a1	c6 04 01 8b	 mov	 BYTE PTR [ecx+eax], 139	; 0000008bH
  000a5	ff 46 14	 inc	 DWORD PTR [esi+20]
  000a8	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 613  :             put_byte(s, 8);

  000ab	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ae	c6 04 01 08	 mov	 BYTE PTR [ecx+eax], 8
  000b2	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 614  :             if (s->gzhead == Z_NULL) {

  000b5	8b 5e 1c	 mov	 ebx, DWORD PTR [esi+28]
  000b8	42		 inc	 edx
  000b9	89 56 14	 mov	 DWORD PTR [esi+20], edx
  000bc	85 db		 test	 ebx, ebx
  000be	0f 85 83 00 00
	00		 jne	 $LN19@deflate

; 615  :                 put_byte(s, 0);

  000c4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000c7	88 1c 02	 mov	 BYTE PTR [edx+eax], bl
  000ca	ff 46 14	 inc	 DWORD PTR [esi+20]
  000cd	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 616  :                 put_byte(s, 0);

  000d0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d3	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000d6	ff 46 14	 inc	 DWORD PTR [esi+20]
  000d9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 617  :                 put_byte(s, 0);

  000dc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000df	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000e2	ff 46 14	 inc	 DWORD PTR [esi+20]
  000e5	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 618  :                 put_byte(s, 0);

  000e8	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000eb	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000ee	ff 46 14	 inc	 DWORD PTR [esi+20]
  000f1	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 619  :                 put_byte(s, 0);

  000f4	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f7	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000fa	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 620  :                 put_byte(s, s->level == 9 ? 2 :

  000fd	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00103	42		 inc	 edx
  00104	89 56 14	 mov	 DWORD PTR [esi+20], edx
  00107	83 f8 09	 cmp	 eax, 9
  0010a	75 04		 jne	 SHORT $LN88@deflate
  0010c	b1 02		 mov	 cl, 2
  0010e	eb 14		 jmp	 SHORT $LN87@deflate
$LN88@deflate:
  00110	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  00117	7d 09		 jge	 SHORT $LN86@deflate
  00119	83 f8 02	 cmp	 eax, 2
  0011c	7c 04		 jl	 SHORT $LN86@deflate
  0011e	32 c9		 xor	 cl, cl
  00120	eb 02		 jmp	 SHORT $LN87@deflate
$LN86@deflate:
  00122	b1 04		 mov	 cl, 4
$LN87@deflate:
  00124	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00127	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0012a	ff 46 14	 inc	 DWORD PTR [esi+20]
  0012d	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 621  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 622  :                              4 : 0));
; 623  :                 put_byte(s, OS_CODE);

  00130	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00133	c6 04 01 0b	 mov	 BYTE PTR [ecx+eax], 11	; 0000000bH

; 624  :                 s->status = BUSY_STATE;

  00137	b8 71 00 00 00	 mov	 eax, 113		; 00000071H
  0013c	ff 46 14	 inc	 DWORD PTR [esi+20]

; 650  :             }
; 651  :         }

  0013f	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00142	e9 ca 01 00 00	 jmp	 $LN18@deflate
$LN19@deflate:

; 625  :             }
; 626  :             else {
; 627  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +

  00147	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  0014a	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  0014d	f7 d9		 neg	 ecx
  0014f	1a c9		 sbb	 cl, cl
  00151	80 e1 10	 and	 cl, 16			; 00000010H
  00154	f7 d8		 neg	 eax
  00156	1a c0		 sbb	 al, al
  00158	24 02		 and	 al, 2
  0015a	02 c8		 add	 cl, al
  0015c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0015f	f7 d8		 neg	 eax
  00161	1a c0		 sbb	 al, al
  00163	24 08		 and	 al, 8
  00165	02 c8		 add	 cl, al
  00167	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0016a	f7 d8		 neg	 eax
  0016c	1a c0		 sbb	 al, al
  0016e	24 04		 and	 al, 4
  00170	02 c8		 add	 cl, al
  00172	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00175	0f 95 c0	 setne	 al
  00178	02 c8		 add	 cl, al
  0017a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0017d	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00180	ff 46 14	 inc	 DWORD PTR [esi+20]
  00183	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 628  :                             (s->gzhead->hcrc ? 2 : 0) +
; 629  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 630  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 631  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 632  :                         );
; 633  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  00186	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00189	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0018c	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  00190	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00193	ff 46 14	 inc	 DWORD PTR [esi+20]
  00196	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 634  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  00199	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0019c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0019f	0f b6 40 05	 movzx	 eax, BYTE PTR [eax+5]
  001a3	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001a6	ff 46 14	 inc	 DWORD PTR [esi+20]
  001a9	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 635  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  001ac	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001af	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001b2	0f b6 40 06	 movzx	 eax, BYTE PTR [eax+6]
  001b6	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001b9	ff 46 14	 inc	 DWORD PTR [esi+20]

; 636  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  001bc	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  001bf	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  001c2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c5	0f b6 40 07	 movzx	 eax, BYTE PTR [eax+7]
  001c9	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  001cc	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 637  :                 put_byte(s, s->level == 9 ? 2 :

  001cf	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  001d5	42		 inc	 edx
  001d6	89 56 14	 mov	 DWORD PTR [esi+20], edx
  001d9	83 f8 09	 cmp	 eax, 9
  001dc	75 04		 jne	 SHORT $LN92@deflate
  001de	b1 02		 mov	 cl, 2
  001e0	eb 14		 jmp	 SHORT $LN91@deflate
$LN92@deflate:
  001e2	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  001e9	7d 09		 jge	 SHORT $LN90@deflate
  001eb	83 f8 02	 cmp	 eax, 2
  001ee	7c 04		 jl	 SHORT $LN90@deflate
  001f0	32 c9		 xor	 cl, cl
  001f2	eb 02		 jmp	 SHORT $LN91@deflate
$LN90@deflate:
  001f4	b1 04		 mov	 cl, 4
$LN91@deflate:
  001f6	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  001f9	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  001fc	ff 46 14	 inc	 DWORD PTR [esi+20]

; 638  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 639  :                              4 : 0));
; 640  :                 put_byte(s, s->gzhead->os & 0xff);

  001ff	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00202	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00205	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00208	8a 40 0c	 mov	 al, BYTE PTR [eax+12]
  0020b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0020e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 641  :                 if (s->gzhead->extra != Z_NULL) {

  00211	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00214	42		 inc	 edx
  00215	89 56 14	 mov	 DWORD PTR [esi+20], edx
  00218	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0021c	74 26		 je	 SHORT $LN21@deflate

; 642  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  0021e	0f b6 40 14	 movzx	 eax, BYTE PTR [eax+20]
  00222	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00225	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00228	ff 46 14	 inc	 DWORD PTR [esi+20]

; 643  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  0022b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0022e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00231	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00234	0f b6 40 15	 movzx	 eax, BYTE PTR [eax+21]
  00238	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0023b	ff 46 14	 inc	 DWORD PTR [esi+20]
  0023e	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00241	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
$LN21@deflate:

; 644  :                 }
; 645  :                 if (s->gzhead->hcrc)

  00244	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00248	74 0f		 je	 SHORT $LN123@deflate

; 646  :                     strm->adler = crc32(strm->adler, s->pending_buf,

  0024a	52		 push	 edx
  0024b	ff 76 08	 push	 DWORD PTR [esi+8]
  0024e	ff 77 30	 push	 DWORD PTR [edi+48]
  00251	e8 00 00 00 00	 call	 _crc32@12
  00256	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN123@deflate:

; 647  :                                         s->pending);
; 648  :                 s->gzindex = 0;
; 649  :                 s->status = EXTRA_STATE;

  00259	b8 45 00 00 00	 mov	 eax, 69			; 00000045H
  0025e	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 650  :             }
; 651  :         }

  00265	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00268	e9 a4 00 00 00	 jmp	 $LN18@deflate
$LN17@deflate:

; 652  :         else
; 653  : #endif
; 654  :         {
; 655  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  0026d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00270	c1 e0 0c	 shl	 eax, 12			; 0000000cH
  00273	2d 00 78 00 00	 sub	 eax, 30720		; 00007800H

; 656  :             uInt level_flags;
; 657  : 
; 658  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  00278	83 be 88 00 00
	00 02		 cmp	 DWORD PTR [esi+136], 2
  0027f	7d 30		 jge	 SHORT $LN25@deflate
  00281	8b 8e 84 00 00
	00		 mov	 ecx, DWORD PTR [esi+132]
  00287	83 f9 02	 cmp	 ecx, 2
  0028a	7c 25		 jl	 SHORT $LN25@deflate

; 660  :             else if (s->level < 6)

  0028c	83 f9 06	 cmp	 ecx, 6
  0028f	7d 0a		 jge	 SHORT $LN26@deflate

; 661  :                 level_flags = 1;

  00291	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00296	8d 4a 20	 lea	 ecx, DWORD PTR [edx+32]
  00299	eb 1d		 jmp	 SHORT $LN29@deflate
$LN26@deflate:

; 662  :             else if (s->level == 6)

  0029b	75 0a		 jne	 SHORT $LN28@deflate

; 663  :                 level_flags = 2;

  0029d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002a2	8d 4a 20	 lea	 ecx, DWORD PTR [edx+32]
  002a5	eb 11		 jmp	 SHORT $LN29@deflate
$LN28@deflate:

; 664  :             else
; 665  :                 level_flags = 3;

  002a7	ba c0 00 00 00	 mov	 edx, 192		; 000000c0H
  002ac	8d 4a 20	 lea	 ecx, DWORD PTR [edx+32]
  002af	eb 07		 jmp	 SHORT $LN29@deflate
$LN25@deflate:

; 659  :                 level_flags = 0;

  002b1	33 d2		 xor	 edx, edx
  002b3	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
$LN29@deflate:

; 666  :             header |= (level_flags << 6);
; 667  :             if (s->strstart != 0) header |= PRESET_DICT;
; 668  :             header += 31 - (header % 31);
; 669  : 
; 670  :             s->status = BUSY_STATE;

  002b8	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  002bc	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
  002c3	0f 44 ca	 cmove	 ecx, edx
  002c6	0b c8		 or	 ecx, eax
  002c8	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  002cd	f7 e1		 mul	 ecx
  002cf	2b ca		 sub	 ecx, edx
  002d1	d1 e9		 shr	 ecx, 1
  002d3	03 ca		 add	 ecx, edx
  002d5	c1 e9 04	 shr	 ecx, 4
  002d8	41		 inc	 ecx
  002d9	8b d1		 mov	 edx, ecx
  002db	c1 e2 05	 shl	 edx, 5
  002de	2b d1		 sub	 edx, ecx

; 671  :             putShortMSB(s, header);

  002e0	8b ce		 mov	 ecx, esi
  002e2	e8 00 00 00 00	 call	 _putShortMSB

; 672  : 
; 673  :             /* Save the adler32 of the preset dictionary: */
; 674  :             if (s->strstart != 0) {

  002e7	83 7e 6c 00	 cmp	 DWORD PTR [esi+108], 0
  002eb	74 16		 je	 SHORT $LN31@deflate

; 675  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  002ed	0f b7 57 32	 movzx	 edx, WORD PTR [edi+50]
  002f1	8b ce		 mov	 ecx, esi
  002f3	e8 00 00 00 00	 call	 _putShortMSB

; 676  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  002f8	0f b7 57 30	 movzx	 edx, WORD PTR [edi+48]
  002fc	8b ce		 mov	 ecx, esi
  002fe	e8 00 00 00 00	 call	 _putShortMSB
$LN31@deflate:

; 677  :             }
; 678  :             strm->adler = adler32(0L, Z_NULL, 0);

  00303	6a 00		 push	 0
  00305	6a 00		 push	 0
  00307	6a 00		 push	 0
  00309	e8 00 00 00 00	 call	 _adler32@12
  0030e	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN18@deflate:

; 679  :         }
; 680  :     }
; 681  : #ifdef GZIP
; 682  :     if (s->status == EXTRA_STATE) {

  00311	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00314	83 f8 45	 cmp	 eax, 69			; 00000045H
  00317	0f 85 c4 00 00
	00		 jne	 $LN34@deflate

; 683  :         if (s->gzhead->extra != Z_NULL) {

  0031d	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00320	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00324	0f 84 af 00 00
	00		 je	 $LN33@deflate

; 684  :             uInt beg = s->pending;  /* start of bytes to update crc */
; 685  : 
; 686  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  0032a	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  0032e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00331	8b d9		 mov	 ebx, ecx
  00333	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
  00336	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  00339	73 67		 jae	 SHORT $LN130@deflate
  0033b	0f 1f 44 00 00	 npad	 5
$LL2@deflate:

; 687  :                 if (s->pending == s->pending_buf_size) {

  00340	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  00343	75 32		 jne	 SHORT $LN108@deflate

; 688  :                     if (s->gzhead->hcrc && s->pending > beg)

  00345	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  00349	74 18		 je	 SHORT $LN36@deflate
  0034b	3b d9		 cmp	 ebx, ecx
  0034d	76 14		 jbe	 SHORT $LN36@deflate

; 689  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,

  0034f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00352	2b d9		 sub	 ebx, ecx
  00354	53		 push	 ebx
  00355	03 c1		 add	 eax, ecx
  00357	50		 push	 eax
  00358	ff 77 30	 push	 DWORD PTR [edi+48]
  0035b	e8 00 00 00 00	 call	 _crc32@12
  00360	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN36@deflate:

; 690  :                                             s->pending - beg);
; 691  :                     flush_pending(strm);

  00363	8b cf		 mov	 ecx, edi
  00365	e8 00 00 00 00	 call	 _flush_pending

; 692  :                     beg = s->pending;

  0036a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 693  :                     if (s->pending == s->pending_buf_size)

  0036d	8b d9		 mov	 ebx, ecx
  0036f	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
  00372	3b 4e 0c	 cmp	 ecx, DWORD PTR [esi+12]
  00375	74 2b		 je	 SHORT $LN130@deflate
$LN108@deflate:

; 694  :                         break;
; 695  :                 }
; 696  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  00377	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0037a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0037d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00380	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00383	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00386	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al
  00389	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]

; 697  :                 s->gzindex++;

  0038c	ff 46 20	 inc	 DWORD PTR [esi+32]
  0038f	43		 inc	 ebx
  00390	8b 4d 08	 mov	 ecx, DWORD PTR _beg$1$[ebp]
  00393	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00396	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00399	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  0039d	39 46 20	 cmp	 DWORD PTR [esi+32], eax
  003a0	72 9e		 jb	 SHORT $LL2@deflate
$LN130@deflate:

; 698  :             }
; 699  :             if (s->gzhead->hcrc && s->pending > beg)

  003a2	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  003a5	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  003a9	74 1b		 je	 SHORT $LN38@deflate
  003ab	3b d9		 cmp	 ebx, ecx
  003ad	76 17		 jbe	 SHORT $LN38@deflate

; 700  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,

  003af	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  003b2	2b d9		 sub	 ebx, ecx
  003b4	53		 push	 ebx
  003b5	03 c1		 add	 eax, ecx
  003b7	50		 push	 eax
  003b8	ff 77 30	 push	 DWORD PTR [edi+48]
  003bb	e8 00 00 00 00	 call	 _crc32@12
  003c0	89 47 30	 mov	 DWORD PTR [edi+48], eax
  003c3	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
$LN38@deflate:

; 701  :                                     s->pending - beg);
; 702  :             if (s->gzindex == s->gzhead->extra_len) {

  003c6	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  003c9	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  003cc	0f 85 98 00 00
	00		 jne	 $LN110@deflate

; 703  :                 s->gzindex = 0;

  003d2	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN33@deflate:

; 707  :         else
; 708  :             s->status = NAME_STATE;
; 709  :     }
; 710  :     if (s->status == NAME_STATE) {

  003d9	b8 49 00 00 00	 mov	 eax, 73			; 00000049H
  003de	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN34@deflate:
  003e1	83 f8 49	 cmp	 eax, 73			; 00000049H
  003e4	0f 85 c9 00 00
	00		 jne	 $LN42@deflate

; 711  :         if (s->gzhead->name != Z_NULL) {

  003ea	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  003ed	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  003f1	0f 84 b4 00 00
	00		 je	 $LN41@deflate

; 712  :             uInt beg = s->pending;  /* start of bytes to update crc */

  003f7	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  003fa	8b d9		 mov	 ebx, ecx
  003fc	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
  003ff	90		 npad	 1
$LL6@deflate:

; 713  :             int val;
; 714  : 
; 715  :             do {
; 716  :                 if (s->pending == s->pending_buf_size) {

  00400	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  00403	75 35		 jne	 SHORT $LN111@deflate

; 717  :                     if (s->gzhead->hcrc && s->pending > beg)

  00405	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00408	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0040c	74 18		 je	 SHORT $LN44@deflate
  0040e	3b d9		 cmp	 ebx, ecx
  00410	76 14		 jbe	 SHORT $LN44@deflate

; 718  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,

  00412	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00415	2b d9		 sub	 ebx, ecx
  00417	53		 push	 ebx
  00418	03 c1		 add	 eax, ecx
  0041a	50		 push	 eax
  0041b	ff 77 30	 push	 DWORD PTR [edi+48]
  0041e	e8 00 00 00 00	 call	 _crc32@12
  00423	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN44@deflate:

; 719  :                                             s->pending - beg);
; 720  :                     flush_pending(strm);

  00426	8b cf		 mov	 ecx, edi
  00428	e8 00 00 00 00	 call	 _flush_pending

; 721  :                     beg = s->pending;

  0042d	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 722  :                     if (s->pending == s->pending_buf_size) {

  00430	8b d9		 mov	 ebx, ecx
  00432	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
  00435	3b 4e 0c	 cmp	 ecx, DWORD PTR [esi+12]
  00438	74 38		 je	 SHORT $LN102@deflate
$LN111@deflate:

; 724  :                         break;
; 725  :                     }
; 726  :                 }
; 727  :                 val = s->gzhead->name[s->gzindex++];

  0043a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0043d	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00440	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00443	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00446	0f b6 c2	 movzx	 eax, dl
  00449	89 45 fc	 mov	 DWORD PTR _val$1$[ebp], eax
  0044c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 728  :                 put_byte(s, val);
; 729  :             } while (val != 0);

  0044f	8b 4d 08	 mov	 ecx, DWORD PTR _beg$1$[ebp]
  00452	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00455	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00458	88 14 03	 mov	 BYTE PTR [ebx+eax], dl
  0045b	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  0045e	43		 inc	 ebx
  0045f	83 7d fc 00	 cmp	 DWORD PTR _val$1$[ebp], 0
  00463	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00466	74 11		 je	 SHORT $LN5@deflate
  00468	eb 96		 jmp	 SHORT $LL6@deflate
$LN110@deflate:

; 704  :                 s->status = NAME_STATE;

  0046a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 705  :             }
; 706  :         }

  0046d	e9 6f ff ff ff	 jmp	 $LN34@deflate
$LN102@deflate:

; 723  :                         val = 1;

  00472	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _val$1$[ebp], 1
$LN5@deflate:

; 730  :             if (s->gzhead->hcrc && s->pending > beg)

  00479	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0047c	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00480	74 18		 je	 SHORT $LN46@deflate
  00482	3b d9		 cmp	 ebx, ecx
  00484	76 14		 jbe	 SHORT $LN46@deflate

; 731  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,

  00486	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00489	2b d9		 sub	 ebx, ecx
  0048b	53		 push	 ebx
  0048c	03 c1		 add	 eax, ecx
  0048e	50		 push	 eax
  0048f	ff 77 30	 push	 DWORD PTR [edi+48]
  00492	e8 00 00 00 00	 call	 _crc32@12
  00497	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN46@deflate:

; 732  :                                     s->pending - beg);
; 733  :             if (val == 0) {

  0049a	83 7d fc 00	 cmp	 DWORD PTR _val$1$[ebp], 0
  0049e	0f 85 97 00 00
	00		 jne	 $LN112@deflate

; 734  :                 s->gzindex = 0;

  004a4	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
$LN41@deflate:

; 738  :         else
; 739  :             s->status = COMMENT_STATE;
; 740  :     }
; 741  :     if (s->status == COMMENT_STATE) {

  004ab	b8 5b 00 00 00	 mov	 eax, 91			; 0000005bH
  004b0	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN42@deflate:
  004b3	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  004b6	0f 85 c5 00 00
	00		 jne	 $LN50@deflate

; 742  :         if (s->gzhead->comment != Z_NULL) {

  004bc	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  004bf	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  004c3	0f 84 80 01 00
	00		 je	 $LN49@deflate

; 743  :             uInt beg = s->pending;  /* start of bytes to update crc */

  004c9	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  004cc	8b d9		 mov	 ebx, ecx
  004ce	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
$LL9@deflate:

; 744  :             int val;
; 745  : 
; 746  :             do {
; 747  :                 if (s->pending == s->pending_buf_size) {

  004d1	3b 5e 0c	 cmp	 ebx, DWORD PTR [esi+12]
  004d4	75 35		 jne	 SHORT $LN113@deflate

; 748  :                     if (s->gzhead->hcrc && s->pending > beg)

  004d6	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  004d9	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  004dd	74 18		 je	 SHORT $LN52@deflate
  004df	3b d9		 cmp	 ebx, ecx
  004e1	76 14		 jbe	 SHORT $LN52@deflate

; 749  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,

  004e3	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  004e6	2b d9		 sub	 ebx, ecx
  004e8	53		 push	 ebx
  004e9	03 c1		 add	 eax, ecx
  004eb	50		 push	 eax
  004ec	ff 77 30	 push	 DWORD PTR [edi+48]
  004ef	e8 00 00 00 00	 call	 _crc32@12
  004f4	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN52@deflate:

; 750  :                                             s->pending - beg);
; 751  :                     flush_pending(strm);

  004f7	8b cf		 mov	 ecx, edi
  004f9	e8 00 00 00 00	 call	 _flush_pending

; 752  :                     beg = s->pending;

  004fe	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 753  :                     if (s->pending == s->pending_buf_size) {

  00501	8b d9		 mov	 ebx, ecx
  00503	89 4d 08	 mov	 DWORD PTR _beg$1$[ebp], ecx
  00506	3b 4e 0c	 cmp	 ecx, DWORD PTR [esi+12]
  00509	74 38		 je	 SHORT $LN103@deflate
$LN113@deflate:

; 755  :                         break;
; 756  :                     }
; 757  :                 }
; 758  :                 val = s->gzhead->comment[s->gzindex++];

  0050b	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0050e	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00511	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00514	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00517	0f b6 c2	 movzx	 eax, dl
  0051a	89 45 fc	 mov	 DWORD PTR _val$1$[ebp], eax
  0051d	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 759  :                 put_byte(s, val);
; 760  :             } while (val != 0);

  00520	8b 4d 08	 mov	 ecx, DWORD PTR _beg$1$[ebp]
  00523	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00526	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00529	88 14 03	 mov	 BYTE PTR [ebx+eax], dl
  0052c	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  0052f	43		 inc	 ebx
  00530	83 7d fc 00	 cmp	 DWORD PTR _val$1$[ebp], 0
  00534	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00537	74 11		 je	 SHORT $LN8@deflate
  00539	eb 96		 jmp	 SHORT $LL9@deflate
$LN112@deflate:

; 735  :                 s->status = COMMENT_STATE;

  0053b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 736  :             }
; 737  :         }

  0053e	e9 70 ff ff ff	 jmp	 $LN42@deflate
$LN103@deflate:

; 754  :                         val = 1;

  00543	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _val$1$[ebp], 1
$LN8@deflate:

; 761  :             if (s->gzhead->hcrc && s->pending > beg)

  0054a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0054d	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00551	74 18		 je	 SHORT $LN54@deflate
  00553	3b d9		 cmp	 ebx, ecx
  00555	76 14		 jbe	 SHORT $LN54@deflate

; 762  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,

  00557	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0055a	2b d9		 sub	 ebx, ecx
  0055c	53		 push	 ebx
  0055d	03 c1		 add	 eax, ecx
  0055f	50		 push	 eax
  00560	ff 77 30	 push	 DWORD PTR [edi+48]
  00563	e8 00 00 00 00	 call	 _crc32@12
  00568	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN54@deflate:

; 763  :                                     s->pending - beg);
; 764  :             if (val == 0)

  0056b	83 7d fc 00	 cmp	 DWORD PTR _val$1$[ebp], 0
  0056f	0f 85 cc 00 00
	00		 jne	 $LN114@deflate

; 765  :                 s->status = HCRC_STATE;

  00575	c7 46 04 67 00
	00 00		 mov	 DWORD PTR [esi+4], 103	; 00000067H
  0057c	b8 67 00 00 00	 mov	 eax, 103		; 00000067H
$LN50@deflate:

; 769  :     }
; 770  :     if (s->status == HCRC_STATE) {

  00581	83 f8 67	 cmp	 eax, 103		; 00000067H
  00584	75 5c		 jne	 SHORT $LN58@deflate
$LN122@deflate:

; 771  :         if (s->gzhead->hcrc) {

  00586	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00589	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0058d	74 4c		 je	 SHORT $LN57@deflate

; 772  :             if (s->pending + 2 > s->pending_buf_size)

  0058f	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00592	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00595	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00598	3b c1		 cmp	 eax, ecx
  0059a	76 0d		 jbe	 SHORT $LN59@deflate

; 773  :                 flush_pending(strm);

  0059c	8b cf		 mov	 ecx, edi
  0059e	e8 00 00 00 00	 call	 _flush_pending
  005a3	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  005a6	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$LN59@deflate:

; 774  :             if (s->pending + 2 <= s->pending_buf_size) {

  005a9	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  005ac	3b c1		 cmp	 eax, ecx
  005ae	77 32		 ja	 SHORT $LN58@deflate

; 775  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  005b0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  005b3	0f b6 47 30	 movzx	 eax, BYTE PTR [edi+48]

; 776  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
; 777  :                 strm->adler = crc32(0L, Z_NULL, 0);

  005b7	6a 00		 push	 0
  005b9	6a 00		 push	 0
  005bb	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  005be	ff 46 14	 inc	 DWORD PTR [esi+20]
  005c1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  005c4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  005c7	0f b6 47 31	 movzx	 eax, BYTE PTR [edi+49]
  005cb	6a 00		 push	 0
  005cd	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  005d0	ff 46 14	 inc	 DWORD PTR [esi+20]
  005d3	e8 00 00 00 00	 call	 _crc32@12
  005d8	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN57@deflate:

; 778  :                 s->status = BUSY_STATE;
; 779  :             }
; 780  :         }
; 781  :         else
; 782  :             s->status = BUSY_STATE;
; 783  :     }
; 784  : #endif
; 785  : 
; 786  :     /* Flush as much pending output as possible */
; 787  :     if (s->pending != 0) {

  005db	c7 46 04 71 00
	00 00		 mov	 DWORD PTR [esi+4], 113	; 00000071H
$LN58@deflate:
  005e2	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  005e6	74 6d		 je	 SHORT $LN61@deflate

; 788  :         flush_pending(strm);

  005e8	8b cf		 mov	 ecx, edi
  005ea	e8 00 00 00 00	 call	 _flush_pending

; 789  :         if (strm->avail_out == 0) {

  005ef	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  005f3	0f 84 2a 02 00
	00		 je	 $LN129@deflate
  005f9	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
$LN64@deflate:

; 805  :                flush != Z_FINISH) {
; 806  :         ERR_RETURN(strm, Z_BUF_ERROR);
; 807  :     }
; 808  : 
; 809  :     /* User must not provide more input after the first FINISH: */
; 810  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  005fc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  005ff	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00604	75 06		 jne	 SHORT $LN127@deflate
  00606	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  0060a	75 5c		 jne	 SHORT $LN128@deflate
$LN127@deflate:

; 812  :     }
; 813  : 
; 814  :     /* Start a new block or continue the current one.
; 815  :      */
; 816  :     if (strm->avail_in != 0 || s->lookahead != 0 ||

  0060c	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00610	75 19		 jne	 SHORT $LN67@deflate
  00612	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00616	75 13		 jne	 SHORT $LN67@deflate
  00618	85 db		 test	 ebx, ebx
  0061a	0f 84 1c 01 00
	00		 je	 $LN79@deflate
  00620	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00625	0f 84 11 01 00
	00		 je	 $LN79@deflate
$LN67@deflate:

; 817  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
; 818  :         block_state bstate;
; 819  : 
; 820  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :

  0062b	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  00631	83 f8 02	 cmp	 eax, 2
  00634	75 48		 jne	 SHORT $LN96@deflate
  00636	8b d3		 mov	 edx, ebx
  00638	8b ce		 mov	 ecx, esi
  0063a	e8 00 00 00 00	 call	 _deflate_huff
  0063f	eb 64		 jmp	 SHORT $LN95@deflate
$LN114@deflate:

; 765  :                 s->status = HCRC_STATE;

  00641	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 766  :         }

  00644	e9 38 ff ff ff	 jmp	 $LN50@deflate
$LN49@deflate:

; 767  :         else
; 768  :             s->status = HCRC_STATE;

  00649	c7 46 04 67 00
	00 00		 mov	 DWORD PTR [esi+4], 103	; 00000067H

; 769  :     }
; 770  :     if (s->status == HCRC_STATE) {

  00650	e9 31 ff ff ff	 jmp	 $LN122@deflate
$LN61@deflate:

; 790  :             /* Since avail_out is 0, deflate will be called again with
; 791  :              * more output space, but possibly with both pending and
; 792  :              * avail_in equal to zero. There won't be anything to do,
; 793  :              * but this is not an error situation so make sure we
; 794  :              * return OK instead of BUF_ERROR at next call of deflate:
; 795  :              */
; 796  :             s->last_flush = -1;
; 797  :             return Z_OK;
; 798  :         }
; 799  : 
; 800  :     /* Make sure there is something to do and avoid duplicate consecutive
; 801  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 802  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 803  :      */
; 804  :     } else if (strm->avail_in == 0 && flush <= old_flush &&

  00655	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00659	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  0065c	75 9e		 jne	 SHORT $LN64@deflate
  0065e	3b 5d f8	 cmp	 ebx, DWORD PTR _old_flush$1$[ebp]
  00661	7f 99		 jg	 SHORT $LN64@deflate
  00663	83 fb 04	 cmp	 ebx, 4
  00666	74 94		 je	 SHORT $LN64@deflate
$LN128@deflate:

; 811  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00668	a1 1c 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+28
  0066d	5b		 pop	 ebx
  0066e	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00671	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00676	5f		 pop	 edi

; 892  : }

  00677	5e		 pop	 esi
  00678	8b e5		 mov	 esp, ebp
  0067a	5d		 pop	 ebp
  0067b	c2 08 00	 ret	 8
$LN96@deflate:

; 817  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
; 818  :         block_state bstate;
; 819  : 
; 820  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :

  0067e	83 f8 03	 cmp	 eax, 3
  00681	75 0b		 jne	 SHORT $LN94@deflate
  00683	8b d3		 mov	 edx, ebx
  00685	8b ce		 mov	 ecx, esi
  00687	e8 00 00 00 00	 call	 _deflate_rle
  0068c	eb 17		 jmp	 SHORT $LN95@deflate
$LN94@deflate:
  0068e	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00694	53		 push	 ebx
  00695	56		 push	 esi
  00696	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00699	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR _configuration_table[eax*4+8]
  006a0	ff d0		 call	 eax
  006a2	83 c4 08	 add	 esp, 8
$LN95@deflate:

; 821  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 822  :                         (*(configuration_table[s->level].func))(s, flush));
; 823  : 
; 824  :         if (bstate == finish_started || bstate == finish_done) {

  006a5	83 f8 02	 cmp	 eax, 2
  006a8	74 05		 je	 SHORT $LN69@deflate
  006aa	83 f8 03	 cmp	 eax, 3
  006ad	75 07		 jne	 SHORT $LN68@deflate
$LN69@deflate:

; 825  :             s->status = FINISH_STATE;

  006af	c7 46 04 9a 02
	00 00		 mov	 DWORD PTR [esi+4], 666	; 0000029aH
$LN68@deflate:

; 826  :         }
; 827  :         if (bstate == need_more || bstate == finish_started) {

  006b6	85 c0		 test	 eax, eax
  006b8	0f 84 5f 01 00
	00		 je	 $LN71@deflate
  006be	83 f8 02	 cmp	 eax, 2
  006c1	0f 84 56 01 00
	00		 je	 $LN71@deflate

; 832  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 833  :              * of deflate should use the same flush parameter to make sure
; 834  :              * that the flush is complete. So we don't have to output an
; 835  :              * empty block here, this will be done at next call. This also
; 836  :              * ensures that for a very small output buffer, we emit at most
; 837  :              * one empty block.
; 838  :              */
; 839  :         }
; 840  :         if (bstate == block_done) {

  006c7	83 f8 01	 cmp	 eax, 1
  006ca	75 70		 jne	 SHORT $LN79@deflate

; 841  :             if (flush == Z_PARTIAL_FLUSH) {

  006cc	3b d8		 cmp	 ebx, eax
  006ce	75 09		 jne	 SHORT $LN74@deflate

; 842  :                 _tr_align(s);

  006d0	8b ce		 mov	 ecx, esi
  006d2	e8 00 00 00 00	 call	 __tr_align
  006d7	eb 52		 jmp	 SHORT $LN78@deflate
$LN74@deflate:

; 843  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  006d9	83 fb 05	 cmp	 ebx, 5
  006dc	74 4d		 je	 SHORT $LN78@deflate

; 844  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  006de	6a 00		 push	 0
  006e0	6a 00		 push	 0
  006e2	33 d2		 xor	 edx, edx
  006e4	8b ce		 mov	 ecx, esi
  006e6	e8 00 00 00 00	 call	 __tr_stored_block
  006eb	83 c4 08	 add	 esp, 8

; 845  :                 /* For a full flush, this empty block will be recognized
; 846  :                  * as a special marker by inflate_sync().
; 847  :                  */
; 848  :                 if (flush == Z_FULL_FLUSH) {

  006ee	83 fb 03	 cmp	 ebx, 3
  006f1	75 38		 jne	 SHORT $LN78@deflate

; 849  :                     CLEAR_HASH(s);             /* forget history */

  006f3	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  006f6	33 d2		 xor	 edx, edx
  006f8	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  006fb	66 89 54 48 fe	 mov	 WORD PTR [eax+ecx*2-2], dx
  00700	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00703	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR [eax*2-2]
  0070a	50		 push	 eax
  0070b	52		 push	 edx
  0070c	ff 76 44	 push	 DWORD PTR [esi+68]
  0070f	e8 00 00 00 00	 call	 _memset
  00714	83 c4 0c	 add	 esp, 12			; 0000000cH

; 850  :                     if (s->lookahead == 0) {

  00717	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  0071b	75 0e		 jne	 SHORT $LN78@deflate

; 851  :                         s->strstart = 0;

  0071d	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 852  :                         s->block_start = 0L;

  00724	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
$LN78@deflate:

; 853  :                     }
; 854  :                 }
; 855  :             }
; 856  :             flush_pending(strm);

  0072b	8b cf		 mov	 ecx, edi
  0072d	e8 00 00 00 00	 call	 _flush_pending

; 857  :             if (strm->avail_out == 0) {

  00732	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00736	0f 84 e7 00 00
	00		 je	 $LN129@deflate
$LN79@deflate:

; 858  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 859  :               return Z_OK;
; 860  :             }
; 861  :         }
; 862  :     }
; 863  :     Assert(strm->avail_out > 0, "bug2");
; 864  : 
; 865  :     if (flush != Z_FINISH) return Z_OK;

  0073c	83 fb 04	 cmp	 ebx, 4
  0073f	0f 85 e5 00 00
	00		 jne	 $LN72@deflate

; 866  :     if (s->wrap <= 0) return Z_STREAM_END;

  00745	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00748	85 c0		 test	 eax, eax
  0074a	7f 0c		 jg	 SHORT $LN81@deflate
  0074c	8d 43 fd	 lea	 eax, DWORD PTR [ebx-3]
  0074f	5b		 pop	 ebx
  00750	5f		 pop	 edi

; 892  : }

  00751	5e		 pop	 esi
  00752	8b e5		 mov	 esp, ebp
  00754	5d		 pop	 ebp
  00755	c2 08 00	 ret	 8
$LN81@deflate:

; 867  : 
; 868  :     /* Write the trailer */
; 869  : #ifdef GZIP
; 870  :     if (s->wrap == 2) {

  00758	83 f8 02	 cmp	 eax, 2
  0075b	0f 85 82 00 00
	00		 jne	 $LN82@deflate

; 871  :         put_byte(s, (Byte)(strm->adler & 0xff));

  00761	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00764	0f b6 47 30	 movzx	 eax, BYTE PTR [edi+48]
  00768	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0076b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0076e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00771	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 872  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00774	0f b6 47 31	 movzx	 eax, BYTE PTR [edi+49]
  00778	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0077b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0077e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00781	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 873  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  00784	0f b6 47 32	 movzx	 eax, BYTE PTR [edi+50]
  00788	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0078b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0078e	ff 46 14	 inc	 DWORD PTR [esi+20]
  00791	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 874  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  00794	0f b6 47 33	 movzx	 eax, BYTE PTR [edi+51]
  00798	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0079b	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0079e	ff 46 14	 inc	 DWORD PTR [esi+20]
  007a1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 875  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  007a4	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  007a8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007ab	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007ae	ff 46 14	 inc	 DWORD PTR [esi+20]
  007b1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 876  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  007b4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007b7	0f b6 47 09	 movzx	 eax, BYTE PTR [edi+9]
  007bb	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007be	ff 46 14	 inc	 DWORD PTR [esi+20]
  007c1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 877  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  007c4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007c7	0f b6 47 0a	 movzx	 eax, BYTE PTR [edi+10]
  007cb	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007ce	ff 46 14	 inc	 DWORD PTR [esi+20]
  007d1	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 878  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  007d4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  007d7	0f b6 47 0b	 movzx	 eax, BYTE PTR [edi+11]
  007db	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  007de	ff 46 14	 inc	 DWORD PTR [esi+20]

; 879  :     }

  007e1	eb 16		 jmp	 SHORT $LN83@deflate
$LN82@deflate:

; 880  :     else
; 881  : #endif
; 882  :     {
; 883  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  007e3	0f b7 57 32	 movzx	 edx, WORD PTR [edi+50]
  007e7	8b ce		 mov	 ecx, esi
  007e9	e8 00 00 00 00	 call	 _putShortMSB

; 884  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  007ee	0f b7 57 30	 movzx	 edx, WORD PTR [edi+48]
  007f2	8b ce		 mov	 ecx, esi
  007f4	e8 00 00 00 00	 call	 _putShortMSB
$LN83@deflate:

; 885  :     }
; 886  :     flush_pending(strm);

  007f9	8b cf		 mov	 ecx, edi
  007fb	e8 00 00 00 00	 call	 _flush_pending

; 887  :     /* If avail_out is zero, the application will call deflate again
; 888  :      * to flush the rest.
; 889  :      */
; 890  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  00800	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00803	85 c0		 test	 eax, eax
  00805	7e 05		 jle	 SHORT $LN84@deflate
  00807	f7 d8		 neg	 eax
  00809	89 46 18	 mov	 DWORD PTR [esi+24], eax
$LN84@deflate:

; 891  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0080c	33 c0		 xor	 eax, eax
  0080e	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00811	5b		 pop	 ebx
  00812	5f		 pop	 edi
  00813	0f 94 c0	 sete	 al

; 892  : }

  00816	5e		 pop	 esi
  00817	8b e5		 mov	 esp, ebp
  00819	5d		 pop	 ebp
  0081a	c2 08 00	 ret	 8
$LN71@deflate:

; 828  :             if (strm->avail_out == 0) {

  0081d	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0
  00821	75 07		 jne	 SHORT $LN72@deflate
$LN129@deflate:

; 829  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  00823	c7 46 28 ff ff
	ff ff		 mov	 DWORD PTR [esi+40], -1
$LN72@deflate:
  0082a	5b		 pop	 ebx
  0082b	5f		 pop	 edi

; 830  :             }
; 831  :             return Z_OK;

  0082c	33 c0		 xor	 eax, eax

; 892  : }

  0082e	5e		 pop	 esi
  0082f	8b e5		 mov	 esp, ebp
  00831	5d		 pop	 ebp
  00832	c2 08 00	 ret	 8
$LN13@deflate:

; 597  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {
; 598  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  00835	a1 10 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+16
  0083a	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN11@deflate:

; 892  : }

  0083d	5f		 pop	 edi
  0083e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00843	5e		 pop	 esi
  00844	8b e5		 mov	 esp, ebp
  00846	5d		 pop	 ebp
  00847	c2 08 00	 ret	 8
_deflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateEnd@4 PROC					; COMDAT

; 897  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 b2 00 00
	00		 je	 $LN3@deflateEnd
  00010	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00013	85 c0		 test	 eax, eax
  00015	0f 84 a7 00 00
	00		 je	 $LN3@deflateEnd

; 901  : 
; 902  :     status = strm->state->status;

  0001b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 903  :     if (status != INIT_STATE &&
; 904  :         status != EXTRA_STATE &&
; 905  :         status != NAME_STATE &&
; 906  :         status != COMMENT_STATE &&
; 907  :         status != HCRC_STATE &&
; 908  :         status != BUSY_STATE &&

  0001e	83 ff 2a	 cmp	 edi, 42			; 0000002aH
  00021	74 21		 je	 SHORT $LN4@deflateEnd
  00023	83 ff 45	 cmp	 edi, 69			; 00000045H
  00026	74 1c		 je	 SHORT $LN4@deflateEnd
  00028	83 ff 49	 cmp	 edi, 73			; 00000049H
  0002b	74 17		 je	 SHORT $LN4@deflateEnd
  0002d	83 ff 5b	 cmp	 edi, 91			; 0000005bH
  00030	74 12		 je	 SHORT $LN4@deflateEnd
  00032	83 ff 67	 cmp	 edi, 103		; 00000067H
  00035	74 0d		 je	 SHORT $LN4@deflateEnd
  00037	83 ff 71	 cmp	 edi, 113		; 00000071H
  0003a	74 08		 je	 SHORT $LN4@deflateEnd
  0003c	81 ff 9a 02 00
	00		 cmp	 edi, 666		; 0000029aH
  00042	75 7e		 jne	 SHORT $LN3@deflateEnd
$LN4@deflateEnd:

; 909  :         status != FINISH_STATE) {
; 910  :       return Z_STREAM_ERROR;
; 911  :     }
; 912  : 
; 913  :     /* Deallocate in reverse order of allocations: */
; 914  :     TRY_FREE(strm, strm->state->pending_buf);

  00044	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00047	85 c9		 test	 ecx, ecx
  00049	74 0f		 je	 SHORT $LN5@deflateEnd
  0004b	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0004e	51		 push	 ecx
  0004f	ff 76 28	 push	 DWORD PTR [esi+40]
  00052	ff d0		 call	 eax
  00054	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00057	83 c4 08	 add	 esp, 8
$LN5@deflateEnd:

; 915  :     TRY_FREE(strm, strm->state->head);

  0005a	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0005d	85 c9		 test	 ecx, ecx
  0005f	74 0f		 je	 SHORT $LN6@deflateEnd
  00061	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00064	51		 push	 ecx
  00065	ff 76 28	 push	 DWORD PTR [esi+40]
  00068	ff d0		 call	 eax
  0006a	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0006d	83 c4 08	 add	 esp, 8
$LN6@deflateEnd:

; 916  :     TRY_FREE(strm, strm->state->prev);

  00070	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00073	85 c9		 test	 ecx, ecx
  00075	74 0f		 je	 SHORT $LN7@deflateEnd
  00077	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0007a	51		 push	 ecx
  0007b	ff 76 28	 push	 DWORD PTR [esi+40]
  0007e	ff d0		 call	 eax
  00080	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00083	83 c4 08	 add	 esp, 8
$LN7@deflateEnd:

; 917  :     TRY_FREE(strm, strm->state->window);

  00086	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00089	85 c9		 test	 ecx, ecx
  0008b	74 0f		 je	 SHORT $LN8@deflateEnd
  0008d	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00090	51		 push	 ecx
  00091	ff 76 28	 push	 DWORD PTR [esi+40]
  00094	ff d0		 call	 eax
  00096	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00099	83 c4 08	 add	 esp, 8
$LN8@deflateEnd:

; 918  : 
; 919  :     ZFREE(strm, strm->state);

  0009c	50		 push	 eax
  0009d	ff 76 28	 push	 DWORD PTR [esi+40]
  000a0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000a3	ff d0		 call	 eax
  000a5	83 c4 08	 add	 esp, 8

; 920  :     strm->state = Z_NULL;

  000a8	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 921  : 
; 922  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  000af	33 c0		 xor	 eax, eax
  000b1	b9 fd ff ff ff	 mov	 ecx, -3			; fffffffdH
  000b6	83 ff 71	 cmp	 edi, 113		; 00000071H
  000b9	5f		 pop	 edi
  000ba	0f 44 c1	 cmove	 eax, ecx

; 923  : }

  000bd	5e		 pop	 esi
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
$LN3@deflateEnd:
  000c2	5f		 pop	 edi

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000c3	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 923  : }

  000c8	5e		 pop	 esi
  000c9	5d		 pop	 ebp
  000ca	c2 04 00	 ret	 4
_deflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateInit_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_deflateInit_@16 PROC					; COMDAT

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 204  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,

  00003	ff 75 14	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 10	 push	 DWORD PTR _version$[ebp]
  00009	6a 00		 push	 0
  0000b	6a 08		 push	 8
  0000d	6a 0f		 push	 15			; 0000000fH
  0000f	6a 08		 push	 8
  00011	ff 75 0c	 push	 DWORD PTR _level$[ebp]
  00014	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  00017	e8 00 00 00 00	 call	 _deflateInit2_@32

; 205  :                          Z_DEFAULT_STRATEGY, version, stream_size);
; 206  :     /* To do: ignore strm->next_in if we use it as window */
; 207  : }

  0001c	5d		 pop	 ebp
  0001d	c2 10 00	 ret	 16			; 00000010H
_deflateInit_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateInit2_@32
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_method$ = 16						; size = 4
_windowBits$ = 20					; size = 4
_memLevel$ = 24						; size = 4
_strategy$ = 28						; size = 4
_version$ = 32						; size = 4
tv468 = 36						; size = 4
_stream_size$ = 36					; size = 4
_deflateInit2_@32 PROC					; COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 221  :     deflate_state *s;
; 222  :     int wrap = 1;
; 223  :     static const char my_version[] = ZLIB_VERSION;
; 224  : 
; 225  :     ushf *overlay;
; 226  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 227  :      * output size for (length,distance) codes is <= 24 bits.
; 228  :      */
; 229  : 
; 230  :     if (version == Z_NULL || version[0] != my_version[0] ||

  00003	8b 45 20	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	be 01 00 00 00	 mov	 esi, 1
  0000c	85 c0		 test	 eax, eax
  0000e	0f 84 05 02 00
	00		 je	 $LN3@deflateIni
  00014	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00017	0f 85 fc 01 00
	00		 jne	 $LN3@deflateIni
  0001d	83 7d 24 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00021	0f 85 f2 01 00
	00		 jne	 $LN3@deflateIni

; 233  :     }
; 234  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00027	53		 push	 ebx
  00028	57		 push	 edi
  00029	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  0002c	85 ff		 test	 edi, edi
  0002e	0f 84 d9 01 00
	00		 je	 $LN12@deflateIni

; 235  : 
; 236  :     strm->msg = Z_NULL;
; 237  :     if (strm->zalloc == (alloc_func)0) {

  00034	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00038	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  0003f	75 0e		 jne	 SHORT $LN5@deflateIni

; 238  :         strm->zalloc = zcalloc;

  00041	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], OFFSET _zcalloc

; 239  :         strm->opaque = (voidpf)0;

  00048	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
$LN5@deflateIni:

; 240  :     }
; 241  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  0004f	83 7f 24 00	 cmp	 DWORD PTR [edi+36], 0
  00053	75 07		 jne	 SHORT $LN6@deflateIni
  00055	c7 47 24 00 00
	00 00		 mov	 DWORD PTR [edi+36], OFFSET _zcfree
$LN6@deflateIni:

; 242  : 
; 243  : #ifdef FASTEST
; 244  :     if (level != 0) level = 1;
; 245  : #else
; 246  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 247  : #endif
; 248  : 
; 249  :     if (windowBits < 0) { /* suppress zlib wrapper */

  0005c	83 7d 0c ff	 cmp	 DWORD PTR _level$[ebp], -1
  00060	b9 06 00 00 00	 mov	 ecx, 6
  00065	8b 5d 14	 mov	 ebx, DWORD PTR _windowBits$[ebp]
  00068	0f 45 4d 0c	 cmovne	 ecx, DWORD PTR _level$[ebp]
  0006c	89 4d 24	 mov	 DWORD PTR tv468[ebp], ecx
  0006f	85 db		 test	 ebx, ebx
  00071	79 06		 jns	 SHORT $LN8@deflateIni

; 250  :         wrap = 0;

  00073	33 f6		 xor	 esi, esi

; 251  :         windowBits = -windowBits;

  00075	f7 db		 neg	 ebx

; 252  :     }

  00077	eb 0d		 jmp	 SHORT $LN10@deflateIni
$LN8@deflateIni:

; 253  : #ifdef GZIP
; 254  :     else if (windowBits > 15) {

  00079	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  0007c	7e 08		 jle	 SHORT $LN10@deflateIni

; 255  :         wrap = 2;       /* write gzip wrapper instead */

  0007e	be 02 00 00 00	 mov	 esi, 2

; 256  :         windowBits -= 16;

  00083	83 eb 10	 sub	 ebx, 16			; 00000010H
$LN10@deflateIni:

; 257  :     }
; 258  : #endif
; 259  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 260  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 261  :         strategy < 0 || strategy > Z_FIXED) {

  00086	8b 45 18	 mov	 eax, DWORD PTR _memLevel$[ebp]
  00089	48		 dec	 eax
  0008a	83 f8 08	 cmp	 eax, 8
  0008d	0f 87 7a 01 00
	00		 ja	 $LN12@deflateIni
  00093	83 7d 10 08	 cmp	 DWORD PTR _method$[ebp], 8
  00097	0f 85 70 01 00
	00		 jne	 $LN12@deflateIni
  0009d	8d 43 f8	 lea	 eax, DWORD PTR [ebx-8]
  000a0	83 f8 07	 cmp	 eax, 7
  000a3	0f 87 64 01 00
	00		 ja	 $LN12@deflateIni
  000a9	83 f9 09	 cmp	 ecx, 9
  000ac	0f 87 5b 01 00
	00		 ja	 $LN12@deflateIni
  000b2	83 7d 1c 04	 cmp	 DWORD PTR _strategy$[ebp], 4
  000b6	0f 87 51 01 00
	00		 ja	 $LN12@deflateIni

; 263  :     }
; 264  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
; 265  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000bc	68 c4 16 00 00	 push	 5828			; 000016c4H
  000c1	b8 09 00 00 00	 mov	 eax, 9
  000c6	83 fb 08	 cmp	 ebx, 8
  000c9	6a 01		 push	 1
  000cb	ff 77 28	 push	 DWORD PTR [edi+40]
  000ce	0f 44 d8	 cmove	 ebx, eax
  000d1	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  000d4	ff d0		 call	 eax
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 266  :     if (s == Z_NULL) return Z_MEM_ERROR;

  000d9	85 c0		 test	 eax, eax
  000db	0f 84 20 01 00
	00		 je	 $LN20@deflateIni

; 267  :     strm->state = (struct internal_state FAR *)s;

  000e1	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 268  :     s->strm = strm;
; 269  : 
; 270  :     s->wrap = wrap;
; 271  :     s->gzhead = Z_NULL;
; 272  :     s->w_bits = windowBits;
; 273  :     s->w_size = 1 << s->w_bits;

  000e4	8b cb		 mov	 ecx, ebx
  000e6	89 70 18	 mov	 DWORD PTR [eax+24], esi
  000e9	be 01 00 00 00	 mov	 esi, 1
  000ee	89 58 30	 mov	 DWORD PTR [eax+48], ebx
  000f1	8b d8		 mov	 ebx, eax
  000f3	d3 e6		 shl	 esi, cl

; 274  :     s->w_mask = s->w_size - 1;
; 275  : 
; 276  :     s->hash_bits = memLevel + 7;

  000f5	8b 4d 18	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  000f8	89 38		 mov	 DWORD PTR [eax], edi
  000fa	83 c1 07	 add	 ecx, 7
  000fd	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00104	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00107	89 4b 50	 mov	 DWORD PTR [ebx+80], ecx
  0010a	89 43 34	 mov	 DWORD PTR [ebx+52], eax

; 277  :     s->hash_size = 1 << s->hash_bits;

  0010d	b8 01 00 00 00	 mov	 eax, 1
  00112	d3 e0		 shl	 eax, cl

; 278  :     s->hash_mask = s->hash_size - 1;
; 279  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  00114	83 c1 02	 add	 ecx, 2
  00117	89 43 4c	 mov	 DWORD PTR [ebx+76], eax
  0011a	48		 dec	 eax
  0011b	89 43 54	 mov	 DWORD PTR [ebx+84], eax
  0011e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00123	f7 e1		 mul	 ecx

; 280  : 
; 281  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00125	6a 02		 push	 2
  00127	d1 ea		 shr	 edx, 1
  00129	89 73 2c	 mov	 DWORD PTR [ebx+44], esi
  0012c	89 53 58	 mov	 DWORD PTR [ebx+88], edx
  0012f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00132	56		 push	 esi
  00133	ff 77 28	 push	 DWORD PTR [edi+40]
  00136	ff d0		 call	 eax

; 282  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  00138	6a 02		 push	 2
  0013a	ff 73 2c	 push	 DWORD PTR [ebx+44]
  0013d	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00140	ff 77 28	 push	 DWORD PTR [edi+40]
  00143	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00146	ff d0		 call	 eax

; 283  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  00148	6a 02		 push	 2
  0014a	ff 73 4c	 push	 DWORD PTR [ebx+76]
  0014d	89 43 40	 mov	 DWORD PTR [ebx+64], eax
  00150	ff 77 28	 push	 DWORD PTR [edi+40]
  00153	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00156	ff d0		 call	 eax

; 284  : 
; 285  :     s->high_water = 0;      /* nothing written to s->window yet */
; 286  : 
; 287  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  00158	8b 4d 18	 mov	 ecx, DWORD PTR _memLevel$[ebp]
  0015b	89 43 44	 mov	 DWORD PTR [ebx+68], eax
  0015e	b8 01 00 00 00	 mov	 eax, 1

; 288  : 
; 289  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  00163	6a 04		 push	 4
  00165	c7 83 c0 16 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+5824], 0
  0016f	8d 49 06	 lea	 ecx, DWORD PTR [ecx+6]
  00172	d3 e0		 shl	 eax, cl
  00174	50		 push	 eax
  00175	89 83 9c 16 00
	00		 mov	 DWORD PTR [ebx+5788], eax
  0017b	ff 77 28	 push	 DWORD PTR [edi+40]
  0017e	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00181	ff d0		 call	 eax

; 290  :     s->pending_buf = (uchf *) overlay;
; 291  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00183	8b b3 9c 16 00
	00		 mov	 esi, DWORD PTR [ebx+5788]
  00189	83 c4 30	 add	 esp, 48			; 00000030H

; 292  : 
; 293  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||

  0018c	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00190	8b d0		 mov	 edx, eax
  00192	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  00195	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  0019c	89 4b 0c	 mov	 DWORD PTR [ebx+12], ecx
  0019f	74 4b		 je	 SHORT $LN16@deflateIni
  001a1	83 7b 40 00	 cmp	 DWORD PTR [ebx+64], 0
  001a5	74 45		 je	 SHORT $LN16@deflateIni
  001a7	83 7b 44 00	 cmp	 DWORD PTR [ebx+68], 0
  001ab	74 3f		 je	 SHORT $LN16@deflateIni
  001ad	85 d2		 test	 edx, edx
  001af	74 3b		 je	 SHORT $LN16@deflateIni

; 299  :     }
; 300  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001b1	8b c6		 mov	 eax, esi

; 301  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
; 302  : 
; 303  :     s->level = level;
; 304  :     s->strategy = strategy;
; 305  :     s->method = (Byte)method;

  001b3	c6 43 24 08	 mov	 BYTE PTR [ebx+36], 8
  001b7	d1 e8		 shr	 eax, 1

; 306  : 
; 307  :     return deflateReset(strm);

  001b9	57		 push	 edi
  001ba	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  001bd	89 83 a4 16 00
	00		 mov	 DWORD PTR [ebx+5796], eax
  001c3	8d 04 72	 lea	 eax, DWORD PTR [edx+esi*2]
  001c6	03 c6		 add	 eax, esi
  001c8	89 83 98 16 00
	00		 mov	 DWORD PTR [ebx+5784], eax
  001ce	8b 45 24	 mov	 eax, DWORD PTR tv468[ebp]
  001d1	89 83 84 00 00
	00		 mov	 DWORD PTR [ebx+132], eax
  001d7	8b 45 1c	 mov	 eax, DWORD PTR _strategy$[ebp]
  001da	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  001e0	e8 00 00 00 00	 call	 _deflateReset@4
  001e5	5f		 pop	 edi
  001e6	5b		 pop	 ebx
  001e7	5e		 pop	 esi

; 308  : }

  001e8	5d		 pop	 ebp
  001e9	c2 20 00	 ret	 32			; 00000020H
$LN16@deflateIni:

; 294  :         s->pending_buf == Z_NULL) {
; 295  :         s->status = FINISH_STATE;
; 296  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  001ec	a1 18 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+24
  001f1	c7 43 04 9a 02
	00 00		 mov	 DWORD PTR [ebx+4], 666	; 0000029aH

; 297  :         deflateEnd (strm);

  001f8	57		 push	 edi
  001f9	89 47 18	 mov	 DWORD PTR [edi+24], eax
  001fc	e8 00 00 00 00	 call	 _deflateEnd@4
$LN20@deflateIni:

; 298  :         return Z_MEM_ERROR;

  00201	5f		 pop	 edi
  00202	5b		 pop	 ebx
  00203	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00208	5e		 pop	 esi

; 308  : }

  00209	5d		 pop	 ebp
  0020a	c2 20 00	 ret	 32			; 00000020H
$LN12@deflateIni:
  0020d	5f		 pop	 edi
  0020e	5b		 pop	 ebx

; 262  :         return Z_STREAM_ERROR;

  0020f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00214	5e		 pop	 esi

; 308  : }

  00215	5d		 pop	 ebp
  00216	c2 20 00	 ret	 32			; 00000020H
$LN3@deflateIni:

; 231  :         stream_size != sizeof(z_stream)) {
; 232  :         return Z_VERSION_ERROR;

  00219	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  0021e	5e		 pop	 esi

; 308  : }

  0021f	5d		 pop	 ebp
  00220	c2 20 00	 ret	 32			; 00000020H
_deflateInit2_@32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateSetDictionary@12
_TEXT	SEGMENT
tv456 = 8						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_length$1$ = 16						; size = 4
_dictLength$ = 16					; size = 4
_deflateSetDictionary@12 PROC				; COMDAT

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 316  :     deflate_state *s;
; 317  :     uInt length = dictLength;
; 318  :     uInt n;
; 319  :     IPos hash_head = 0;
; 320  : 
; 321  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 322  :         strm->state->wrap == 2 ||

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 10	 mov	 edi, DWORD PTR _dictLength$[ebp]
  0000c	8b cf		 mov	 ecx, edi
  0000e	89 4d 10	 mov	 DWORD PTR _length$1$[ebp], ecx
  00011	85 c0		 test	 eax, eax
  00013	0f 84 dc 00 00
	00		 je	 $LN6@deflateSet
  00019	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  0001c	85 f6		 test	 esi, esi
  0001e	0f 84 d1 00 00
	00		 je	 $LN6@deflateSet
  00024	8b 5d 0c	 mov	 ebx, DWORD PTR _dictionary$[ebp]
  00027	85 db		 test	 ebx, ebx
  00029	0f 84 c6 00 00
	00		 je	 $LN6@deflateSet
  0002f	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00032	83 fa 02	 cmp	 edx, 2
  00035	0f 84 ba 00 00
	00		 je	 $LN6@deflateSet
  0003b	83 fa 01	 cmp	 edx, 1
  0003e	75 0a		 jne	 SHORT $LN5@deflateSet
  00040	83 7e 04 2a	 cmp	 DWORD PTR [esi+4], 42	; 0000002aH
  00044	0f 85 ab 00 00
	00		 jne	 $LN6@deflateSet
$LN5@deflateSet:

; 323  :         (strm->state->wrap == 1 && strm->state->status != INIT_STATE))
; 324  :         return Z_STREAM_ERROR;
; 325  : 
; 326  :     s = strm->state;
; 327  :     if (s->wrap)

  0004a	85 d2		 test	 edx, edx
  0004c	74 12		 je	 SHORT $LN7@deflateSet

; 328  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0004e	57		 push	 edi
  0004f	53		 push	 ebx
  00050	ff 70 30	 push	 DWORD PTR [eax+48]
  00053	e8 00 00 00 00	 call	 _adler32@12
  00058	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005b	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  0005e	8b cf		 mov	 ecx, edi
$LN7@deflateSet:

; 329  : 
; 330  :     if (length < MIN_MATCH) return Z_OK;

  00060	83 ff 03	 cmp	 edi, 3
  00063	0f 82 83 00 00
	00		 jb	 $LN16@deflateSet

; 331  :     if (length > s->w_size) {

  00069	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0006c	3b f8		 cmp	 edi, eax
  0006e	76 09		 jbe	 SHORT $LN9@deflateSet

; 332  :         length = s->w_size;

  00070	8b c8		 mov	 ecx, eax

; 333  :         dictionary += dictLength - length; /* use the tail of the dictionary */

  00072	2b f9		 sub	 edi, ecx
  00074	89 4d 10	 mov	 DWORD PTR _length$1$[ebp], ecx
  00077	03 df		 add	 ebx, edi
$LN9@deflateSet:

; 334  :     }
; 335  :     zmemcpy(s->window, dictionary, length);

  00079	51		 push	 ecx
  0007a	53		 push	 ebx
  0007b	ff 76 38	 push	 DWORD PTR [esi+56]
  0007e	e8 00 00 00 00	 call	 _memcpy

; 336  :     s->strstart = length;
; 337  :     s->block_start = (long)length;
; 338  : 
; 339  :     /* Insert all strings in the hash table (except for the last two bytes).
; 340  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 341  :      * call of fill_window.
; 342  :      */
; 343  :     s->ins_h = s->window[0];

  00083	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	8b 7d 10	 mov	 edi, DWORD PTR _length$1$[ebp]

; 344  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  0008c	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0008f	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  00092	89 7e 5c	 mov	 DWORD PTR [esi+92], edi
  00095	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00098	89 56 48	 mov	 DWORD PTR [esi+72], edx
  0009b	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  0009f	d3 e2		 shl	 edx, cl
  000a1	33 d0		 xor	 edx, eax

; 345  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  000a3	8d 47 fd	 lea	 eax, DWORD PTR [edi-3]
  000a6	23 56 54	 and	 edx, DWORD PTR [esi+84]
  000a9	33 db		 xor	 ebx, ebx
  000ab	89 56 48	 mov	 DWORD PTR [esi+72], edx
  000ae	89 45 08	 mov	 DWORD PTR tv456[ebp], eax
$LL4@deflateSet:

; 346  :         INSERT_STRING(s, n, hash_head);

  000b1	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000b4	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  000b7	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000ba	23 d3		 and	 edx, ebx
  000bc	0f b6 7c 18 02	 movzx	 edi, BYTE PTR [eax+ebx+2]
  000c1	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  000c4	d3 e0		 shl	 eax, cl
  000c6	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  000c9	33 f8		 xor	 edi, eax
  000cb	23 7e 54	 and	 edi, DWORD PTR [esi+84]
  000ce	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  000d1	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  000d4	66 8b 04 78	 mov	 ax, WORD PTR [eax+edi*2]
  000d8	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  000dc	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  000df	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  000e2	66 89 1c 48	 mov	 WORD PTR [eax+ecx*2], bx
  000e6	43		 inc	 ebx
  000e7	3b 5d 08	 cmp	 ebx, DWORD PTR tv456[ebp]
  000ea	76 c5		 jbe	 SHORT $LL4@deflateSet
$LN16@deflateSet:
  000ec	5f		 pop	 edi

; 347  :     }
; 348  :     if (hash_head) hash_head = 0;  /* to make compiler happy */
; 349  :     return Z_OK;
; 350  : }

  000ed	5e		 pop	 esi
  000ee	33 c0		 xor	 eax, eax
  000f0	5b		 pop	 ebx
  000f1	5d		 pop	 ebp
  000f2	c2 0c 00	 ret	 12			; 0000000cH
$LN6@deflateSet:
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000fc	5b		 pop	 ebx
  000fd	5d		 pop	 ebp
  000fe	c2 0c 00	 ret	 12			; 0000000cH
_deflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_deflateReset@4 PROC					; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 356  :     deflate_state *s;
; 357  : 
; 358  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 359  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	57		 push	 edi
  00008	85 f6		 test	 esi, esi
  0000a	0f 84 97 00 00
	00		 je	 $LN3@deflateRes
  00010	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  00013	85 ff		 test	 edi, edi
  00015	0f 84 8c 00 00
	00		 je	 $LN3@deflateRes
  0001b	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001f	0f 84 82 00 00
	00		 je	 $LN3@deflateRes
  00025	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00029	74 7c		 je	 SHORT $LN3@deflateRes

; 361  :     }
; 362  : 
; 363  :     strm->total_in = strm->total_out = 0;

  0002b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00032	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 364  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  00039	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 365  :     strm->data_type = Z_UNKNOWN;

  00040	c7 46 2c 02 00
	00 00		 mov	 DWORD PTR [esi+44], 2

; 366  : 
; 367  :     s = (deflate_state *)strm->state;
; 368  :     s->pending = 0;
; 369  :     s->pending_out = s->pending_buf;
; 370  : 
; 371  :     if (s->wrap < 0) {

  00047	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0004a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004d	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  00054	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00057	85 c9		 test	 ecx, ecx
  00059	79 05		 jns	 SHORT $LN4@deflateRes

; 372  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  0005b	f7 d9		 neg	 ecx
  0005d	89 4f 18	 mov	 DWORD PTR [edi+24], ecx
$LN4@deflateRes:

; 373  :     }
; 374  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  00060	85 c9		 test	 ecx, ecx
  00062	b8 71 00 00 00	 mov	 eax, 113		; 00000071H

; 375  :     strm->adler =

  00067	6a 00		 push	 0
  00069	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  0006e	0f 45 c2	 cmovne	 eax, edx
  00071	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00074	6a 00		 push	 0
  00076	6a 00		 push	 0
  00078	83 f9 02	 cmp	 ecx, 2
  0007b	75 07		 jne	 SHORT $LN6@deflateRes
  0007d	e8 00 00 00 00	 call	 _crc32@12
  00082	eb 05		 jmp	 SHORT $LN7@deflateRes
$LN6@deflateRes:
  00084	e8 00 00 00 00	 call	 _adler32@12
$LN7@deflateRes:
  00089	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 376  : #ifdef GZIP
; 377  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 378  : #endif
; 379  :         adler32(0L, Z_NULL, 0);
; 380  :     s->last_flush = Z_NO_FLUSH;
; 381  : 
; 382  :     _tr_init(s);

  0008c	8b cf		 mov	 ecx, edi
  0008e	c7 47 28 00 00
	00 00		 mov	 DWORD PTR [edi+40], 0
  00095	e8 00 00 00 00	 call	 __tr_init

; 383  :     lm_init(s);

  0009a	e8 00 00 00 00	 call	 _lm_init
  0009f	5f		 pop	 edi

; 384  : 
; 385  :     return Z_OK;

  000a0	33 c0		 xor	 eax, eax

; 386  : }

  000a2	5e		 pop	 esi
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
$LN3@deflateRes:
  000a7	5f		 pop	 edi

; 360  :         return Z_STREAM_ERROR;

  000a8	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 386  : }

  000ad	5e		 pop	 esi
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
_deflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateSetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_deflateSetHeader@8 PROC				; COMDAT

; 392  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 19		 je	 SHORT $LN3@deflateSet
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 12		 je	 SHORT $LN3@deflateSet

; 394  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  00011	83 79 18 02	 cmp	 DWORD PTR [ecx+24], 2
  00015	75 0c		 jne	 SHORT $LN3@deflateSet

; 395  :     strm->state->gzhead = head;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 396  :     return Z_OK;

  0001d	33 c0		 xor	 eax, eax

; 397  : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
$LN3@deflateSet:

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00023	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 397  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
_deflateSetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_deflatePrime@12 PROC					; COMDAT

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 2e		 je	 SHORT $LN3@deflatePri
  0000a	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0000d	85 d2		 test	 edx, edx
  0000f	74 27		 je	 SHORT $LN3@deflatePri

; 406  :     strm->state->bi_valid = bits;

  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00014	89 8a bc 16 00
	00		 mov	 DWORD PTR [edx+5820], ecx

; 407  :     strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));

  0001a	ba 01 00 00 00	 mov	 edx, 1
  0001f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00022	66 d3 e2	 shl	 dx, cl
  00025	66 4a		 dec	 dx
  00027	66 23 55 10	 and	 dx, WORD PTR _value$[ebp]
  0002b	66 89 90 b8 16
	00 00		 mov	 WORD PTR [eax+5816], dx

; 408  :     return Z_OK;

  00032	33 c0		 xor	 eax, eax

; 409  : }

  00034	5d		 pop	 ebp
  00035	c2 0c 00	 ret	 12			; 0000000cH
$LN3@deflatePri:

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00038	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 409  : }

  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
_deflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateParams@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_deflateParams@12 PROC					; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 417  :     deflate_state *s;
; 418  :     compress_func func;
; 419  :     int err = Z_OK;
; 420  : 
; 421  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 10	 mov	 ebx, DWORD PTR _strategy$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	85 d2		 test	 edx, edx
  0000e	0f 84 b7 00 00
	00		 je	 $LN3@deflatePar
  00014	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00017	85 f6		 test	 esi, esi
  00019	0f 84 ac 00 00
	00		 je	 $LN3@deflatePar

; 422  :     s = strm->state;
; 423  : 
; 424  : #ifdef FASTEST
; 425  :     if (level != 0) level = 1;
; 426  : #else
; 427  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 428  : #endif
; 429  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  0001f	83 7d 0c ff	 cmp	 DWORD PTR _level$[ebp], -1
  00023	bf 06 00 00 00	 mov	 edi, 6
  00028	0f 45 7d 0c	 cmovne	 edi, DWORD PTR _level$[ebp]
  0002c	83 ff 09	 cmp	 edi, 9
  0002f	0f 87 96 00 00
	00		 ja	 $LN3@deflatePar
  00035	83 fb 04	 cmp	 ebx, 4
  00038	0f 87 8d 00 00
	00		 ja	 $LN3@deflatePar

; 430  :         return Z_STREAM_ERROR;
; 431  :     }
; 432  :     func = configuration_table[s->level].func;
; 433  : 
; 434  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&

  0003e	3b 9e 88 00 00
	00		 cmp	 ebx, DWORD PTR [esi+136]
  00044	75 1c		 jne	 SHORT $LN12@deflatePar
  00046	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  0004c	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  0004f	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00052	8b 04 85 08 00
	00 00		 mov	 eax, DWORD PTR _configuration_table[eax*4+8]
  00059	3b 04 8d 08 00
	00 00		 cmp	 eax, DWORD PTR _configuration_table[ecx*4+8]
  00060	74 12		 je	 SHORT $LN14@deflatePar
$LN12@deflatePar:
  00062	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00066	74 0c		 je	 SHORT $LN14@deflatePar

; 435  :         strm->total_in != 0) {
; 436  :         /* Flush the last buffer: */
; 437  :         err = deflate(strm, Z_BLOCK);

  00068	6a 05		 push	 5
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 _deflate@8
  00070	8b d0		 mov	 edx, eax
  00072	eb 02		 jmp	 SHORT $LN7@deflatePar
$LN14@deflatePar:

; 438  :     }
; 439  :     if (s->level != level) {

  00074	33 d2		 xor	 edx, edx
$LN7@deflatePar:
  00076	39 be 84 00 00
	00		 cmp	 DWORD PTR [esi+132], edi
  0007c	74 3e		 je	 SHORT $LN9@deflatePar

; 440  :         s->level = level;
; 441  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  0007e	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  00081	89 be 84 00 00
	00		 mov	 DWORD PTR [esi+132], edi
  00087	0f b7 04 8d 02
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+2]
  0008f	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax

; 442  :         s->good_match       = configuration_table[level].good_length;

  00095	0f b7 04 8d 00
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4]
  0009d	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax

; 443  :         s->nice_match       = configuration_table[level].nice_length;

  000a3	0f b7 04 8d 04
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+4]
  000ab	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 444  :         s->max_chain_length = configuration_table[level].max_chain;

  000b1	0f b7 04 8d 06
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+6]
  000b9	89 46 7c	 mov	 DWORD PTR [esi+124], eax
$LN9@deflatePar:

; 445  :     }
; 446  :     s->strategy = strategy;

  000bc	5f		 pop	 edi
  000bd	89 9e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ebx

; 447  :     return err;

  000c3	8b c2		 mov	 eax, edx

; 448  : }

  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx
  000c7	5d		 pop	 ebp
  000c8	c2 0c 00	 ret	 12			; 0000000cH
$LN3@deflatePar:
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  000d2	5b		 pop	 ebx
  000d3	5d		 pop	 ebp
  000d4	c2 0c 00	 ret	 12			; 0000000cH
_deflateParams@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateTune@20
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_good_length$ = 12					; size = 4
_max_lazy$ = 16						; size = 4
_nice_length$ = 20					; size = 4
_max_chain$ = 24					; size = 4
_deflateTune@20 PROC					; COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 2e		 je	 SHORT $LN3@deflateTun
  0000a	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 27		 je	 SHORT $LN3@deflateTun

; 461  :     s = strm->state;
; 462  :     s->good_match = good_length;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _good_length$[ebp]
  00014	89 81 8c 00 00
	00		 mov	 DWORD PTR [ecx+140], eax

; 463  :     s->max_lazy_match = max_lazy;

  0001a	8b 45 10	 mov	 eax, DWORD PTR _max_lazy$[ebp]
  0001d	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 464  :     s->nice_match = nice_length;

  00023	8b 45 14	 mov	 eax, DWORD PTR _nice_length$[ebp]
  00026	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 465  :     s->max_chain_length = max_chain;

  0002c	8b 45 18	 mov	 eax, DWORD PTR _max_chain$[ebp]
  0002f	89 41 7c	 mov	 DWORD PTR [ecx+124], eax

; 466  :     return Z_OK;

  00032	33 c0		 xor	 eax, eax

; 467  : }

  00034	5d		 pop	 ebp
  00035	c2 14 00	 ret	 20			; 00000014H
$LN3@deflateTun:

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00038	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 467  : }

  0003d	5d		 pop	 ebp
  0003e	c2 14 00	 ret	 20			; 00000014H
_deflateTune@20 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateBound@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_sourceLen$ = 12					; size = 4
_deflateBound@8 PROC					; COMDAT

; 489  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 490  :     deflate_state *s;
; 491  :     uLong complen, wraplen;
; 492  :     Bytef *str;
; 493  : 
; 494  :     /* conservative upper bound for compressed data */
; 495  :     complen = sourceLen +
; 496  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
; 497  : 
; 498  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR _sourceLen$[ebp]
  0000a	57		 push	 edi
  0000b	8d 7e 3f	 lea	 edi, DWORD PTR [esi+63]
  0000e	c1 ef 06	 shr	 edi, 6
  00011	8d 46 07	 lea	 eax, DWORD PTR [esi+7]
  00014	c1 e8 03	 shr	 eax, 3
  00017	03 fe		 add	 edi, esi
  00019	83 c0 05	 add	 eax, 5
  0001c	03 f8		 add	 edi, eax
  0001e	85 d2		 test	 edx, edx
  00020	0f 84 c0 00 00
	00		 je	 $LN11@deflateBou
  00026	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
  00029	85 d2		 test	 edx, edx
  0002b	0f 84 b5 00 00
	00		 je	 $LN11@deflateBou

; 501  : 
; 502  :     /* compute wrapper length */
; 503  :     s = strm->state;
; 504  :     switch (s->wrap) {

  00031	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00034	53		 push	 ebx
  00035	83 e8 00	 sub	 eax, 0
  00038	74 73		 je	 SHORT $LN12@deflateBou
  0003a	83 e8 01	 sub	 eax, 1
  0003d	74 5d		 je	 SHORT $LN13@deflateBou
  0003f	83 e8 01	 sub	 eax, 1
  00042	74 07		 je	 SHORT $LN14@deflateBou

; 530  :     default:                                /* for compiler happiness */
; 531  :         wraplen = 6;

  00044	bb 06 00 00 00	 mov	 ebx, 6
  00049	eb 64		 jmp	 SHORT $LN2@deflateBou
$LN14@deflateBou:

; 511  :     case 2:                                 /* gzip wrapper */
; 512  :         wraplen = 18;
; 513  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  0004b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0004e	bb 12 00 00 00	 mov	 ebx, 18			; 00000012H
  00053	85 c0		 test	 eax, eax
  00055	74 58		 je	 SHORT $LN2@deflateBou

; 514  :             if (s->gzhead->extra != Z_NULL)

  00057	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0005b	74 06		 je	 SHORT $LN16@deflateBou

; 515  :                 wraplen += 2 + s->gzhead->extra_len;

  0005d	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  00060	83 c3 14	 add	 ebx, 20			; 00000014H
$LN16@deflateBou:

; 516  :             str = s->gzhead->name;

  00063	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]

; 517  :             if (str != Z_NULL)

  00066	85 c9		 test	 ecx, ecx
  00068	74 13		 je	 SHORT $LN5@deflateBou
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL6@deflateBou:

; 518  :                 do {
; 519  :                     wraplen++;
; 520  :                 } while (*str++);

  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00075	43		 inc	 ebx
  00076	84 c0		 test	 al, al
  00078	75 f6		 jne	 SHORT $LL6@deflateBou
  0007a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
$LN5@deflateBou:

; 521  :             str = s->gzhead->comment;

  0007d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]

; 522  :             if (str != Z_NULL)

  00080	85 c9		 test	 ecx, ecx
  00082	74 0d		 je	 SHORT $LN8@deflateBou
$LL9@deflateBou:

; 523  :                 do {
; 524  :                     wraplen++;
; 525  :                 } while (*str++);

  00084	8a 01		 mov	 al, BYTE PTR [ecx]
  00086	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  00089	43		 inc	 ebx
  0008a	84 c0		 test	 al, al
  0008c	75 f6		 jne	 SHORT $LL9@deflateBou
  0008e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
$LN8@deflateBou:

; 526  :             if (s->gzhead->hcrc)

  00091	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00095	74 18		 je	 SHORT $LN2@deflateBou

; 527  :                 wraplen += 2;

  00097	83 c3 02	 add	 ebx, 2

; 528  :         }
; 529  :         break;

  0009a	eb 13		 jmp	 SHORT $LN2@deflateBou
$LN13@deflateBou:

; 507  :         break;
; 508  :     case 1:                                 /* zlib wrapper */
; 509  :         wraplen = 6 + (s->strstart ? 4 : 0);

  0009c	33 db		 xor	 ebx, ebx
  0009e	39 5a 6c	 cmp	 DWORD PTR [edx+108], ebx
  000a1	0f 95 c3	 setne	 bl
  000a4	8d 1c 9d 06 00
	00 00		 lea	 ebx, DWORD PTR [ebx*4+6]

; 510  :         break;

  000ab	eb 02		 jmp	 SHORT $LN2@deflateBou
$LN12@deflateBou:

; 505  :     case 0:                                 /* raw deflate */
; 506  :         wraplen = 0;

  000ad	33 db		 xor	 ebx, ebx
$LN2@deflateBou:

; 532  :     }
; 533  : 
; 534  :     /* if not default parameters, return conservative bound */
; 535  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  000af	83 7a 30 0f	 cmp	 DWORD PTR [edx+48], 15	; 0000000fH
  000b3	75 27		 jne	 SHORT $LN22@deflateBou
  000b5	83 7a 50 0f	 cmp	 DWORD PTR [edx+80], 15	; 0000000fH
  000b9	75 21		 jne	 SHORT $LN22@deflateBou

; 537  : 
; 538  :     /* default settings: return tight bound for that case */
; 539  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +

  000bb	8b ce		 mov	 ecx, esi
  000bd	8b d6		 mov	 edx, esi
  000bf	c1 e9 0e	 shr	 ecx, 14			; 0000000eH
  000c2	8b c6		 mov	 eax, esi
  000c4	03 cb		 add	 ecx, ebx
  000c6	c1 e8 0c	 shr	 eax, 12			; 0000000cH
  000c9	c1 ea 19	 shr	 edx, 25			; 00000019H
  000cc	83 c0 07	 add	 eax, 7
  000cf	03 ca		 add	 ecx, edx
  000d1	5b		 pop	 ebx
  000d2	03 c1		 add	 eax, ecx
  000d4	5f		 pop	 edi
  000d5	03 c6		 add	 eax, esi

; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 541  : }

  000d7	5e		 pop	 esi
  000d8	5d		 pop	 ebp
  000d9	c2 08 00	 ret	 8
$LN22@deflateBou:

; 536  :         return complen + wraplen;

  000dc	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  000df	5b		 pop	 ebx
  000e0	5f		 pop	 edi

; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 541  : }

  000e1	5e		 pop	 esi
  000e2	5d		 pop	 ebp
  000e3	c2 08 00	 ret	 8
$LN11@deflateBou:

; 500  :         return complen + 6;

  000e6	8d 47 06	 lea	 eax, DWORD PTR [edi+6]
  000e9	5f		 pop	 edi

; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 541  : }

  000ea	5e		 pop	 esi
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
_deflateBound@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _putShortMSB
_TEXT	SEGMENT
_putShortMSB PROC					; COMDAT
; _s$ = ecx
; _b$ = edx

; 551  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 552  :     put_byte(s, (Byte)(b >> 8));

  00004	8b ca		 mov	 ecx, edx
  00006	c1 e9 08	 shr	 ecx, 8
  00009	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0000c	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000f	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  00012	ff 47 14	 inc	 DWORD PTR [edi+20]
  00015	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]

; 553  :     put_byte(s, (Byte)(b & 0xff));

  00018	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0001b	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0001e	ff 47 14	 inc	 DWORD PTR [edi+20]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 554  : }

  00023	c3		 ret	 0
_putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _flush_pending
_TEXT	SEGMENT
_flush_pending PROC					; COMDAT
; _strm$ = ecx

; 564  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 565  :     unsigned len = strm->state->pending;

  00004	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]

; 566  : 
; 567  :     if (len > strm->avail_out) len = strm->avail_out;

  00007	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 568  :     if (len == 0) return;

  0000a	39 71 14	 cmp	 DWORD PTR [ecx+20], esi
  0000d	0f 46 71 14	 cmovbe	 esi, DWORD PTR [ecx+20]
  00011	85 f6		 test	 esi, esi
  00013	74 33		 je	 SHORT $LN4@flush_pend

; 569  : 
; 570  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  00015	56		 push	 esi
  00016	ff 71 10	 push	 DWORD PTR [ecx+16]
  00019	ff 77 0c	 push	 DWORD PTR [edi+12]
  0001c	e8 00 00 00 00	 call	 _memcpy

; 571  :     strm->next_out  += len;
; 572  :     strm->state->pending_out  += len;

  00021	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	01 77 0c	 add	 DWORD PTR [edi+12], esi
  0002a	01 70 10	 add	 DWORD PTR [eax+16], esi

; 573  :     strm->total_out += len;
; 574  :     strm->avail_out  -= len;
; 575  :     strm->state->pending -= len;

  0002d	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00030	01 77 14	 add	 DWORD PTR [edi+20], esi
  00033	29 77 10	 sub	 DWORD PTR [edi+16], esi
  00036	29 70 14	 sub	 DWORD PTR [eax+20], esi

; 576  :     if (strm->state->pending == 0) {

  00039	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  0003c	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00040	75 06		 jne	 SHORT $LN4@flush_pend

; 577  :         strm->state->pending_out = strm->state->pending_buf;

  00042	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00045	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN4@flush_pend:

; 578  :     }
; 579  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
_flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_overlay$1$ = 12					; size = 4
_source$ = 12						; size = 4
_deflateCopy@8 PROC					; COMDAT

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 934  : #ifdef MAXSEG_64K
; 935  :     return Z_STREAM_ERROR;
; 936  : #else
; 937  :     deflate_state *ds;
; 938  :     deflate_state *ss;
; 939  :     ushf *overlay;
; 940  : 
; 941  : 
; 942  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	85 c0		 test	 eax, eax
  0000a	0f 84 84 01 00
	00		 je	 $LN3@deflateCop
  00010	8b 75 08	 mov	 esi, DWORD PTR _dest$[ebp]
  00013	85 f6		 test	 esi, esi
  00015	0f 84 79 01 00
	00		 je	 $LN3@deflateCop
  0001b	8b 58 1c	 mov	 ebx, DWORD PTR [eax+28]
  0001e	85 db		 test	 ebx, ebx
  00020	0f 84 6e 01 00
	00		 je	 $LN3@deflateCop

; 944  :     }
; 945  : 
; 946  :     ss = source->state;
; 947  : 
; 948  :     zmemcpy(dest, source, sizeof(z_stream));

  00026	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00029	57		 push	 edi

; 949  : 
; 950  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  0002a	68 c4 16 00 00	 push	 5828			; 000016c4H
  0002f	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00032	6a 01		 push	 1
  00034	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00038	0f 11 46 10	 movups	 XMMWORD PTR [esi+16], xmm0
  0003c	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  00040	0f 11 46 20	 movups	 XMMWORD PTR [esi+32], xmm0
  00044	f3 0f 7e 40 30	 movq	 xmm0, QWORD PTR [eax+48]
  00049	66 0f d6 46 30	 movq	 QWORD PTR [esi+48], xmm0
  0004e	ff 76 28	 push	 DWORD PTR [esi+40]
  00051	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00054	ff d0		 call	 eax
  00056	8b f8		 mov	 edi, eax
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 951  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  0005b	85 ff		 test	 edi, edi
  0005d	0f 84 25 01 00
	00		 je	 $LN9@deflateCop

; 952  :     dest->state = (struct internal_state FAR *) ds;
; 953  :     zmemcpy(ds, ss, sizeof(deflate_state));

  00063	68 c4 16 00 00	 push	 5828			; 000016c4H
  00068	53		 push	 ebx
  00069	57		 push	 edi
  0006a	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  0006d	e8 00 00 00 00	 call	 _memcpy

; 954  :     ds->strm = dest;
; 955  : 
; 956  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  00072	6a 02		 push	 2
  00074	ff 77 2c	 push	 DWORD PTR [edi+44]
  00077	89 37		 mov	 DWORD PTR [edi], esi
  00079	ff 76 28	 push	 DWORD PTR [esi+40]
  0007c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0007f	ff d0		 call	 eax

; 957  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00081	6a 02		 push	 2
  00083	ff 77 2c	 push	 DWORD PTR [edi+44]
  00086	89 47 38	 mov	 DWORD PTR [edi+56], eax
  00089	ff 76 28	 push	 DWORD PTR [esi+40]
  0008c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0008f	ff d0		 call	 eax

; 958  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00091	6a 02		 push	 2
  00093	ff 77 4c	 push	 DWORD PTR [edi+76]
  00096	89 47 40	 mov	 DWORD PTR [edi+64], eax
  00099	ff 76 28	 push	 DWORD PTR [esi+40]
  0009c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0009f	ff d0		 call	 eax

; 959  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  000a1	6a 04		 push	 4
  000a3	ff b7 9c 16 00
	00		 push	 DWORD PTR [edi+5788]
  000a9	89 47 44	 mov	 DWORD PTR [edi+68], eax
  000ac	ff 76 28	 push	 DWORD PTR [esi+40]
  000af	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000b2	ff d0		 call	 eax

; 960  :     ds->pending_buf = (uchf *) overlay;
; 961  : 
; 962  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||

  000b4	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  000b7	83 c4 3c	 add	 esp, 60			; 0000003cH
  000ba	89 45 0c	 mov	 DWORD PTR _overlay$1$[ebp], eax
  000bd	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000c0	85 c9		 test	 ecx, ecx
  000c2	0f 84 ba 00 00
	00		 je	 $LN6@deflateCop
  000c8	83 7f 40 00	 cmp	 DWORD PTR [edi+64], 0
  000cc	0f 84 b0 00 00
	00		 je	 $LN6@deflateCop
  000d2	83 7f 44 00	 cmp	 DWORD PTR [edi+68], 0
  000d6	0f 84 a6 00 00
	00		 je	 $LN6@deflateCop
  000dc	85 c0		 test	 eax, eax
  000de	0f 84 9e 00 00
	00		 je	 $LN6@deflateCop

; 966  :     }
; 967  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 968  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  000e4	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000e7	03 c0		 add	 eax, eax
  000e9	50		 push	 eax
  000ea	ff 73 38	 push	 DWORD PTR [ebx+56]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 _memcpy

; 969  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  000f3	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000f6	03 c0		 add	 eax, eax
  000f8	50		 push	 eax
  000f9	ff 73 40	 push	 DWORD PTR [ebx+64]
  000fc	ff 77 40	 push	 DWORD PTR [edi+64]
  000ff	e8 00 00 00 00	 call	 _memcpy

; 970  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  00104	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00107	03 c0		 add	 eax, eax
  00109	50		 push	 eax
  0010a	ff 73 44	 push	 DWORD PTR [ebx+68]
  0010d	ff 77 44	 push	 DWORD PTR [edi+68]
  00110	e8 00 00 00 00	 call	 _memcpy

; 971  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  00115	ff 77 0c	 push	 DWORD PTR [edi+12]
  00118	ff 73 08	 push	 DWORD PTR [ebx+8]
  0011b	ff 77 08	 push	 DWORD PTR [edi+8]
  0011e	e8 00 00 00 00	 call	 _memcpy

; 972  : 
; 973  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  00123	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00126	83 c4 30	 add	 esp, 48			; 00000030H
  00129	2b 43 08	 sub	 eax, DWORD PTR [ebx+8]
  0012c	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  0012f	03 c2		 add	 eax, edx

; 974  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00131	8b 8f 9c 16 00
	00		 mov	 ecx, DWORD PTR [edi+5788]
  00137	8b 75 0c	 mov	 esi, DWORD PTR _overlay$1$[ebp]
  0013a	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0013d	8b c1		 mov	 eax, ecx
  0013f	d1 e8		 shr	 eax, 1
  00141	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  00144	89 87 a4 16 00
	00		 mov	 DWORD PTR [edi+5796], eax

; 975  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  0014a	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0014d	03 c1		 add	 eax, ecx
  0014f	89 87 98 16 00
	00		 mov	 DWORD PTR [edi+5784], eax

; 976  : 
; 977  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  00155	8d 87 94 00 00
	00		 lea	 eax, DWORD PTR [edi+148]
  0015b	89 87 18 0b 00
	00		 mov	 DWORD PTR [edi+2840], eax

; 978  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  00161	8d 87 88 09 00
	00		 lea	 eax, DWORD PTR [edi+2440]
  00167	89 87 24 0b 00
	00		 mov	 DWORD PTR [edi+2852], eax

; 979  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  0016d	8d 87 7c 0a 00
	00		 lea	 eax, DWORD PTR [edi+2684]
  00173	89 87 30 0b 00
	00		 mov	 DWORD PTR [edi+2864], eax

; 980  : 
; 981  :     return Z_OK;

  00179	33 c0		 xor	 eax, eax
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  0017d	5b		 pop	 ebx
  0017e	5d		 pop	 ebp
  0017f	c2 08 00	 ret	 8
$LN6@deflateCop:

; 963  :         ds->pending_buf == Z_NULL) {
; 964  :         deflateEnd (dest);

  00182	56		 push	 esi
  00183	e8 00 00 00 00	 call	 _deflateEnd@4
$LN9@deflateCop:

; 965  :         return Z_MEM_ERROR;

  00188	5f		 pop	 edi
  00189	5e		 pop	 esi
  0018a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  0018f	5b		 pop	 ebx
  00190	5d		 pop	 ebp
  00191	c2 08 00	 ret	 8
$LN3@deflateCop:
  00194	5e		 pop	 esi

; 943  :         return Z_STREAM_ERROR;

  00195	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  0019a	5b		 pop	 ebx
  0019b	5d		 pop	 ebp
  0019c	c2 08 00	 ret	 8
_deflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _read_buf
_TEXT	SEGMENT
_size$ = 8						; size = 4
_read_buf PROC						; COMDAT
; _strm$ = ecx
; _buf$ = edx

; 996  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	8b da		 mov	 ebx, edx
  00009	57		 push	 edi

; 997  :     unsigned len = strm->avail_in;

  0000a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 998  : 
; 999  :     if (len > size) len = size;

  0000d	8b f9		 mov	 edi, ecx
  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR _size$[ebp]
  00012	0f 47 7d 08	 cmova	 edi, DWORD PTR _size$[ebp]

; 1000 :     if (len == 0) return 0;

  00016	85 ff		 test	 edi, edi
  00018	75 07		 jne	 SHORT $LN3@read_buf

; 1017 : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	33 c0		 xor	 eax, eax
  0001e	5b		 pop	 ebx
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN3@read_buf:

; 1001 : 
; 1002 :     strm->avail_in  -= len;
; 1003 : 
; 1004 :     if (strm->state->wrap == 1) {

  00021	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00024	2b cf		 sub	 ecx, edi
  00026	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00029	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	75 0d		 jne	 SHORT $LN4@read_buf

; 1005 :         strm->adler = adler32(strm->adler, strm->next_in, len);

  00031	57		 push	 edi
  00032	ff 36		 push	 DWORD PTR [esi]
  00034	ff 76 30	 push	 DWORD PTR [esi+48]
  00037	e8 00 00 00 00	 call	 _adler32@12

; 1006 :     }

  0003c	eb 10		 jmp	 SHORT $LN8@read_buf
$LN4@read_buf:

; 1007 : #ifdef GZIP
; 1008 :     else if (strm->state->wrap == 2) {

  0003e	83 f8 02	 cmp	 eax, 2
  00041	75 0e		 jne	 SHORT $LN6@read_buf

; 1009 :         strm->adler = crc32(strm->adler, strm->next_in, len);

  00043	57		 push	 edi
  00044	ff 36		 push	 DWORD PTR [esi]
  00046	ff 76 30	 push	 DWORD PTR [esi+48]
  00049	e8 00 00 00 00	 call	 _crc32@12
$LN8@read_buf:

; 1010 :     }
; 1011 : #endif
; 1012 :     zmemcpy(buf, strm->next_in, len);

  0004e	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN6@read_buf:
  00051	57		 push	 edi
  00052	ff 36		 push	 DWORD PTR [esi]
  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 _memcpy

; 1013 :     strm->next_in  += len;

  0005a	01 3e		 add	 DWORD PTR [esi], edi
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1014 :     strm->total_in += len;

  0005f	01 7e 08	 add	 DWORD PTR [esi+8], edi

; 1015 : 
; 1016 :     return (int)len;

  00062	8b c7		 mov	 eax, edi
  00064	5f		 pop	 edi

; 1017 : }

  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _lm_init
_TEXT	SEGMENT
_lm_init PROC						; COMDAT
; _s$ = ecx

; 1024 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1025 :     s->window_size = (ulg)2L*s->w_size;
; 1026 : 
; 1027 :     CLEAR_HASH(s);

  00003	33 c9		 xor	 ecx, ecx
  00005	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00008	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  0000b	03 c0		 add	 eax, eax
  0000d	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00010	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00013	66 89 4c 50 fe	 mov	 WORD PTR [eax+edx*2-2], cx
  00018	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  0001b	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR [eax*2-2]
  00022	50		 push	 eax
  00023	51		 push	 ecx
  00024	ff 76 44	 push	 DWORD PTR [esi+68]
  00027	e8 00 00 00 00	 call	 _memset

; 1028 : 
; 1029 :     /* Set the default configuration parameters:
; 1030 :      */
; 1031 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  0002c	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00038	0f b7 04 8d 02
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+2]
  00040	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax

; 1032 :     s->good_match       = configuration_table[s->level].good_length;

  00046	0f b7 04 8d 00
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4]
  0004e	89 86 8c 00 00
	00		 mov	 DWORD PTR [esi+140], eax

; 1033 :     s->nice_match       = configuration_table[s->level].nice_length;

  00054	0f b7 04 8d 04
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+4]
  0005c	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax

; 1034 :     s->max_chain_length = configuration_table[s->level].max_chain;

  00062	0f b7 04 8d 06
	00 00 00	 movzx	 eax, WORD PTR _configuration_table[ecx*4+6]
  0006a	89 46 7c	 mov	 DWORD PTR [esi+124], eax

; 1035 : 
; 1036 :     s->strstart = 0;

  0006d	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0

; 1037 :     s->block_start = 0L;

  00074	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 1038 :     s->lookahead = 0;

  0007b	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 1039 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00082	c7 46 78 02 00
	00 00		 mov	 DWORD PTR [esi+120], 2
  00089	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2

; 1040 :     s->match_available = 0;

  00090	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 1041 :     s->ins_h = 0;

  00097	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  0009e	5e		 pop	 esi

; 1042 : #ifndef FASTEST
; 1043 : #ifdef ASMV
; 1044 :     match_init(); /* initialize the asm code */
; 1045 : #endif
; 1046 : #endif
; 1047 : }

  0009f	c3		 ret	 0
_lm_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _longest_match
_TEXT	SEGMENT
tv500 = -44						; size = 4
_prev$1$ = -40						; size = 4
_wmask$1$ = -36						; size = 4
tv509 = -32						; size = 4
_best_len$1$ = -28					; size = 4
_limit$1$ = -24						; size = 4
_s$1$ = -20						; size = 4
_scan$3$ = -16						; size = 4
_nice_match$2$ = -12					; size = 4
_chain_length$1$ = -8					; size = 4
_scan_end$1$ = -2					; size = 1
_scan_end1$1$ = -1					; size = 1
_longest_match PROC					; COMDAT
; _s$ = ecx
; _cur_match$ = edx

; 1066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b da		 mov	 ebx, edx
  0000d	89 7d ec	 mov	 DWORD PTR _s$1$[ebp], edi

; 1067 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */
; 1068 :     register Bytef *scan = s->window + s->strstart; /* current string */

  00010	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  00013	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]

; 1069 :     register Bytef *match;                       /* matched string */
; 1070 :     register int len;                           /* length of current match */
; 1071 :     int best_len = s->prev_length;              /* best match length so far */

  00016	8b 57 78	 mov	 edx, DWORD PTR [edi+120]
  00019	03 c1		 add	 eax, ecx
  0001b	8b 77 7c	 mov	 esi, DWORD PTR [edi+124]
  0001e	89 4d e0	 mov	 DWORD PTR tv509[ebp], ecx

; 1072 :     int nice_match = s->nice_match;             /* stop if match long enough */
; 1073 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?

  00021	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00024	89 45 f0	 mov	 DWORD PTR _scan$3$[ebp], eax
  00027	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0002d	89 45 f4	 mov	 DWORD PTR _nice_match$2$[ebp], eax
  00030	8d 81 fa fe ff
	ff		 lea	 eax, DWORD PTR [ecx-262]
  00036	89 55 e4	 mov	 DWORD PTR _best_len$1$[ebp], edx
  00039	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  0003c	76 0f		 jbe	 SHORT $LN18@longest_ma
  0003e	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00041	2b c1		 sub	 eax, ecx
  00043	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00048	89 45 e8	 mov	 DWORD PTR _limit$1$[ebp], eax
  0004b	eb 07		 jmp	 SHORT $LN19@longest_ma
$LN18@longest_ma:
  0004d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _limit$1$[ebp], 0
$LN19@longest_ma:

; 1074 :         s->strstart - (IPos)MAX_DIST(s) : NIL;
; 1075 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1076 :      * we prevent matches with the string of window index 0.
; 1077 :      */
; 1078 :     Posf *prev = s->prev;
; 1079 :     uInt wmask = s->w_mask;
; 1080 : 
; 1081 : #ifdef UNALIGNED_OK
; 1082 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1083 :      * Try with and without -DUNALIGNED_OK to check.
; 1084 :      */
; 1085 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1086 :     register ush scan_start = *(ushf*)scan;
; 1087 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1088 : #else
; 1089 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;

  00054	8b 4d f0	 mov	 ecx, DWORD PTR _scan$3$[ebp]
  00057	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  0005a	89 45 d8	 mov	 DWORD PTR _prev$1$[ebp], eax
  0005d	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00060	89 45 dc	 mov	 DWORD PTR _wmask$1$[ebp], eax
  00063	8d b9 02 01 00
	00		 lea	 edi, DWORD PTR [ecx+258]

; 1090 :     register Byte scan_end1  = scan[best_len-1];

  00069	8a 44 0a ff	 mov	 al, BYTE PTR [edx+ecx-1]
  0006d	88 45 ff	 mov	 BYTE PTR _scan_end1$1$[ebp], al

; 1091 :     register Byte scan_end   = scan[best_len];

  00070	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  00073	88 45 fe	 mov	 BYTE PTR _scan_end$1$[ebp], al

; 1092 : #endif
; 1093 : 
; 1094 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1095 :      * It is easy to get rid of this optimization if necessary.
; 1096 :      */
; 1097 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1098 : 
; 1099 :     /* Do not waste too much time if we already have a good match: */
; 1100 :     if (s->prev_length >= s->good_match) {
; 1101 :         chain_length >>= 2;
; 1102 :     }
; 1103 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1104 :      * to make deflate deterministic.
; 1105 :      */
; 1106 :     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

  00076	8b c6		 mov	 eax, esi
  00078	c1 e8 02	 shr	 eax, 2
  0007b	89 45 f8	 mov	 DWORD PTR _chain_length$1$[ebp], eax
  0007e	8b 45 ec	 mov	 eax, DWORD PTR _s$1$[ebp]
  00081	3b 90 8c 00 00
	00		 cmp	 edx, DWORD PTR [eax+140]
  00087	8b 55 f8	 mov	 edx, DWORD PTR _chain_length$1$[ebp]
  0008a	8b 40 74	 mov	 eax, DWORD PTR [eax+116]
  0008d	0f 42 d6	 cmovb	 edx, esi
  00090	8b 75 e4	 mov	 esi, DWORD PTR _best_len$1$[ebp]
  00093	89 55 f8	 mov	 DWORD PTR _chain_length$1$[ebp], edx
  00096	8b 55 f4	 mov	 edx, DWORD PTR _nice_match$2$[ebp]
  00099	3b d0		 cmp	 edx, eax
  0009b	89 45 d4	 mov	 DWORD PTR tv500[ebp], eax
  0009e	0f 47 d0	 cmova	 edx, eax
  000a1	89 55 f4	 mov	 DWORD PTR _nice_match$2$[ebp], edx
$LL4@longest_ma:

; 1107 : 
; 1108 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1109 : 
; 1110 :     do {
; 1111 :         Assert(cur_match < s->strstart, "no future");
; 1112 :         match = s->window + cur_match;

  000a4	8b 55 e0	 mov	 edx, DWORD PTR tv509[ebp]

; 1113 : 
; 1114 :         /* Skip to next match if the match length cannot increase
; 1115 :          * or if the match length is less than 2.  Note that the checks below
; 1116 :          * for insufficient lookahead only occur occasionally for performance
; 1117 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1118 :          * conditional jumps will be made that depend on those values.
; 1119 :          * However the length of the match is limited to the lookahead, so
; 1120 :          * the output of deflate is not affected by the uninitialized values.
; 1121 :          */
; 1122 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1123 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1124 :          * UNALIGNED_OK if your compiler uses a different size.
; 1125 :          */
; 1126 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1127 :             *(ushf*)match != scan_start) continue;
; 1128 : 
; 1129 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1130 :          * always equal when the other bytes match, given that the hash keys
; 1131 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1132 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1133 :          * lookahead only every 4th comparison; the 128th check will be made
; 1134 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1135 :          * necessary to put more guard bytes at the end of the window, or
; 1136 :          * to check more often for insufficient lookahead.
; 1137 :          */
; 1138 :         Assert(scan[2] == match[2], "scan[2]?");
; 1139 :         scan++, match++;
; 1140 :         do {
; 1141 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1142 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1143 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1144 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1145 :                  scan < strend);
; 1146 :         /* The funny "do {}" generates better code on most compilers */
; 1147 : 
; 1148 :         /* Here, scan <= window+strstart+257 */
; 1149 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1150 :         if (*scan == *match) scan++;
; 1151 : 
; 1152 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1153 :         scan = strend - (MAX_MATCH-1);
; 1154 : 
; 1155 : #else /* UNALIGNED_OK */
; 1156 : 
; 1157 :         if (match[best_len]   != scan_end  ||
; 1158 :             match[best_len-1] != scan_end1 ||
; 1159 :             *match            != *scan     ||

  000a7	8a 45 fe	 mov	 al, BYTE PTR _scan_end$1$[ebp]
  000aa	03 d3		 add	 edx, ebx
  000ac	38 04 32	 cmp	 BYTE PTR [edx+esi], al
  000af	0f 85 a6 00 00
	00		 jne	 $LN2@longest_ma
  000b5	8a 45 ff	 mov	 al, BYTE PTR _scan_end1$1$[ebp]
  000b8	38 44 32 ff	 cmp	 BYTE PTR [edx+esi-1], al
  000bc	0f 85 99 00 00
	00		 jne	 $LN2@longest_ma
  000c2	8a 02		 mov	 al, BYTE PTR [edx]
  000c4	3a 01		 cmp	 al, BYTE PTR [ecx]
  000c6	0f 85 8f 00 00
	00		 jne	 $LN2@longest_ma
  000cc	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  000cf	3a 41 01	 cmp	 al, BYTE PTR [ecx+1]
  000d2	0f 85 83 00 00
	00		 jne	 $LN2@longest_ma

; 1160 :             *++match          != scan[1])      continue;
; 1161 : 
; 1162 :         /* The check at best_len-1 can be removed because it will be made
; 1163 :          * again later. (This heuristic is not always a win.)
; 1164 :          * It is not necessary to compare scan[2] and match[2] since they
; 1165 :          * are always equal when the other bytes match, given that
; 1166 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1167 :          */
; 1168 :         scan += 2, match++;

  000d8	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  000db	83 c2 02	 add	 edx, 2
  000de	66 90		 npad	 2
$LL7@longest_ma:

; 1169 :         Assert(*scan == *match, "match[2]?");
; 1170 : 
; 1171 :         /* We check for insufficient lookahead only every 8th comparison;
; 1172 :          * the 256th check will be made at strstart+258.
; 1173 :          */
; 1174 :         do {
; 1175 :         } while (*++scan == *++match && *++scan == *++match &&
; 1176 :                  *++scan == *++match && *++scan == *++match &&
; 1177 :                  *++scan == *++match && *++scan == *++match &&
; 1178 :                  *++scan == *++match && *++scan == *++match &&

  000e0	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000e3	40		 inc	 eax
  000e4	3a 4a 01	 cmp	 cl, BYTE PTR [edx+1]
  000e7	75 45		 jne	 SHORT $LN12@longest_ma
  000e9	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000ec	40		 inc	 eax
  000ed	3a 4a 02	 cmp	 cl, BYTE PTR [edx+2]
  000f0	75 3c		 jne	 SHORT $LN12@longest_ma
  000f2	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000f5	40		 inc	 eax
  000f6	3a 4a 03	 cmp	 cl, BYTE PTR [edx+3]
  000f9	75 33		 jne	 SHORT $LN12@longest_ma
  000fb	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  000fe	40		 inc	 eax
  000ff	3a 4a 04	 cmp	 cl, BYTE PTR [edx+4]
  00102	75 2a		 jne	 SHORT $LN12@longest_ma
  00104	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00107	40		 inc	 eax
  00108	3a 4a 05	 cmp	 cl, BYTE PTR [edx+5]
  0010b	75 21		 jne	 SHORT $LN12@longest_ma
  0010d	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00110	40		 inc	 eax
  00111	3a 4a 06	 cmp	 cl, BYTE PTR [edx+6]
  00114	75 18		 jne	 SHORT $LN12@longest_ma
  00116	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00119	40		 inc	 eax
  0011a	3a 4a 07	 cmp	 cl, BYTE PTR [edx+7]
  0011d	75 0f		 jne	 SHORT $LN12@longest_ma
  0011f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00122	40		 inc	 eax
  00123	83 c2 08	 add	 edx, 8
  00126	3a 0a		 cmp	 cl, BYTE PTR [edx]
  00128	75 04		 jne	 SHORT $LN12@longest_ma
  0012a	3b c7		 cmp	 eax, edi
  0012c	72 b2		 jb	 SHORT $LL7@longest_ma
$LN12@longest_ma:

; 1179 :                  scan < strend);
; 1180 : 
; 1181 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1182 : 
; 1183 :         len = MAX_MATCH - (int)(strend - scan);

  0012e	2b c7		 sub	 eax, edi
  00130	05 02 01 00 00	 add	 eax, 258		; 00000102H

; 1184 :         scan = strend - MAX_MATCH;
; 1185 : 
; 1186 : #endif /* UNALIGNED_OK */
; 1187 : 
; 1188 :         if (len > best_len) {

  00135	3b c6		 cmp	 eax, esi
  00137	7e 1f		 jle	 SHORT $LN29@longest_ma

; 1189 :             s->match_start = cur_match;
; 1190 :             best_len = len;

  00139	8b f0		 mov	 esi, eax
  0013b	8b 4d ec	 mov	 ecx, DWORD PTR _s$1$[ebp]
  0013e	89 59 70	 mov	 DWORD PTR [ecx+112], ebx

; 1191 :             if (len >= nice_match) break;

  00141	3b 45 f4	 cmp	 eax, DWORD PTR _nice_match$2$[ebp]
  00144	7d 30		 jge	 SHORT $LN3@longest_ma

; 1192 : #ifdef UNALIGNED_OK
; 1193 :             scan_end = *(ushf*)(scan+best_len-1);
; 1194 : #else
; 1195 :             scan_end1  = scan[best_len-1];

  00146	8b 4d f0	 mov	 ecx, DWORD PTR _scan$3$[ebp]
  00149	8a 54 08 ff	 mov	 dl, BYTE PTR [eax+ecx-1]

; 1196 :             scan_end   = scan[best_len];

  0014d	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00150	88 55 ff	 mov	 BYTE PTR _scan_end1$1$[ebp], dl
  00153	88 45 fe	 mov	 BYTE PTR _scan_end$1$[ebp], al
  00156	eb 03		 jmp	 SHORT $LN2@longest_ma
$LN29@longest_ma:

; 1184 :         scan = strend - MAX_MATCH;
; 1185 : 
; 1186 : #endif /* UNALIGNED_OK */
; 1187 : 
; 1188 :         if (len > best_len) {

  00158	8b 4d f0	 mov	 ecx, DWORD PTR _scan$3$[ebp]
$LN2@longest_ma:

; 1197 : #endif
; 1198 :         }
; 1199 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1200 :              && --chain_length != 0);

  0015b	8b 45 dc	 mov	 eax, DWORD PTR _wmask$1$[ebp]
  0015e	8b 55 d8	 mov	 edx, DWORD PTR _prev$1$[ebp]
  00161	23 c3		 and	 eax, ebx
  00163	0f b7 1c 42	 movzx	 ebx, WORD PTR [edx+eax*2]
  00167	3b 5d e8	 cmp	 ebx, DWORD PTR _limit$1$[ebp]
  0016a	76 0a		 jbe	 SHORT $LN3@longest_ma
  0016c	83 6d f8 01	 sub	 DWORD PTR _chain_length$1$[ebp], 1
  00170	0f 85 2e ff ff
	ff		 jne	 $LL4@longest_ma
$LN3@longest_ma:

; 1201 : 
; 1202 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;

  00176	8b 45 d4	 mov	 eax, DWORD PTR tv500[ebp]
  00179	3b f0		 cmp	 esi, eax
  0017b	5f		 pop	 edi
  0017c	0f 46 c6	 cmovbe	 eax, esi
  0017f	5e		 pop	 esi
  00180	5b		 pop	 ebx

; 1203 :     return s->lookahead;
; 1204 : }

  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
_longest_match ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _fill_window
_TEXT	SEGMENT
_curr$1$ = -8						; size = 4
_more$1$ = -8						; size = 4
tv611 = -4						; size = 4
tv604 = -4						; size = 4
_fill_window PROC					; COMDAT
; _s$ = ecx

; 1307 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 1308 :     register unsigned n, m;
; 1309 :     register Posf *p;
; 1310 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1311 :     uInt wsize = s->w_size;

  0000b	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0000e	8b 5f 74	 mov	 ebx, DWORD PTR [edi+116]
$LL4@fill_windo:

; 1312 : 
; 1313 :     do {
; 1314 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
; 1315 : 
; 1316 :         /* Deal with !@#$% 64K limit: */
; 1317 :         if (sizeof(int) <= 2) {
; 1318 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1319 :                 more = wsize;
; 1320 : 
; 1321 :             } else if (more == (unsigned)(-1)) {
; 1322 :                 /* Very unlikely, but possible on 16 bit machine if
; 1323 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1324 :                  */
; 1325 :                 more--;
; 1326 :             }
; 1327 :         }
; 1328 : 
; 1329 :         /* If the window is almost full and there is insufficient lookahead,
; 1330 :          * move the upper half to the lower one to make room in the upper half.
; 1331 :          */
; 1332 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  00011	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00014	8b 57 3c	 mov	 edx, DWORD PTR [edi+60]
  00017	05 fa fe ff ff	 add	 eax, -262		; fffffefaH
  0001c	2b 57 6c	 sub	 edx, DWORD PTR [edi+108]
  0001f	03 c6		 add	 eax, esi
  00021	2b d3		 sub	 edx, ebx
  00023	89 55 f8	 mov	 DWORD PTR _more$1$[ebp], edx
  00026	39 47 6c	 cmp	 DWORD PTR [edi+108], eax
  00029	72 7d		 jb	 SHORT $LN15@fill_windo

; 1333 : 
; 1334 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  0002b	8b 4f 38	 mov	 ecx, DWORD PTR [edi+56]
  0002e	56		 push	 esi
  0002f	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 _memcpy

; 1335 :             s->match_start -= wsize;
; 1336 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1337 :             s->block_start -= (long) wsize;
; 1338 : 
; 1339 :             /* Slide the hash table (could be avoided with 32 bit values
; 1340 :                at the expense of memory usage). We slide even when level == 0
; 1341 :                to keep the hash table consistent if we switch back to level > 0
; 1342 :                later. (Using level 0 permanently is not an optimal usage of
; 1343 :                zlib, so we don't care about this pathological case.)
; 1344 :              */
; 1345 :             n = s->hash_size;

  00039	8b 5f 4c	 mov	 ebx, DWORD PTR [edi+76]
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1346 :             p = &s->head[n];

  0003f	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00042	29 77 70	 sub	 DWORD PTR [edi+112], esi
  00045	29 77 6c	 sub	 DWORD PTR [edi+108], esi
  00048	29 77 5c	 sub	 DWORD PTR [edi+92], esi
  0004b	8d 14 58	 lea	 edx, DWORD PTR [eax+ebx*2]
  0004e	66 90		 npad	 2
$LL7@fill_windo:

; 1347 :             do {
; 1348 :                 m = *--p;

  00050	0f b7 4a fe	 movzx	 ecx, WORD PTR [edx-2]
  00054	8d 52 fe	 lea	 edx, DWORD PTR [edx-2]

; 1349 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00057	8b c1		 mov	 eax, ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv604[ebp], 0
  00060	2b c6		 sub	 eax, esi
  00062	3b ce		 cmp	 ecx, esi
  00064	0f b7 c0	 movzx	 eax, ax
  00067	0f 42 45 fc	 cmovb	 eax, DWORD PTR tv604[ebp]
  0006b	66 89 02	 mov	 WORD PTR [edx], ax

; 1350 :             } while (--n);

  0006e	83 eb 01	 sub	 ebx, 1
  00071	75 dd		 jne	 SHORT $LL7@fill_windo

; 1351 : 
; 1352 :             n = wsize;
; 1353 : #ifndef FASTEST
; 1354 :             p = &s->prev[n];

  00073	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00076	8b de		 mov	 ebx, esi
  00078	8d 14 70	 lea	 edx, DWORD PTR [eax+esi*2]
  0007b	0f 1f 44 00 00	 npad	 5
$LL10@fill_windo:

; 1355 :             do {
; 1356 :                 m = *--p;

  00080	0f b7 4a fe	 movzx	 ecx, WORD PTR [edx-2]
  00084	8d 52 fe	 lea	 edx, DWORD PTR [edx-2]

; 1357 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00087	8b c1		 mov	 eax, ecx
  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv611[ebp], 0
  00090	2b c6		 sub	 eax, esi
  00092	3b ce		 cmp	 ecx, esi
  00094	0f b7 c0	 movzx	 eax, ax
  00097	0f 42 45 fc	 cmovb	 eax, DWORD PTR tv611[ebp]
  0009b	66 89 02	 mov	 WORD PTR [edx], ax

; 1358 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1359 :                  * its value will never be used.
; 1360 :                  */
; 1361 :             } while (--n);

  0009e	83 eb 01	 sub	 ebx, 1
  000a1	75 dd		 jne	 SHORT $LL10@fill_windo

; 1362 : #endif
; 1363 :             more += wsize;

  000a3	8b 55 f8	 mov	 edx, DWORD PTR _more$1$[ebp]
  000a6	03 d6		 add	 edx, esi
$LN15@fill_windo:

; 1364 :         }
; 1365 :         if (s->strm->avail_in == 0) return;

  000a8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000aa	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000ae	0f 84 c6 00 00
	00		 je	 $LN23@fill_windo

; 1366 : 
; 1367 :         /* If there was no sliding:
; 1368 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1369 :          *    more == window_size - lookahead - strstart
; 1370 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1371 :          * => more >= window_size - 2*WSIZE + 2
; 1372 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1373 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1374 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1375 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1376 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1377 :          */
; 1378 :         Assert(more >= 2, "more < 2");
; 1379 : 
; 1380 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  000b4	52		 push	 edx
  000b5	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  000b8	03 57 38	 add	 edx, DWORD PTR [edi+56]
  000bb	03 57 6c	 add	 edx, DWORD PTR [edi+108]
  000be	e8 00 00 00 00	 call	 _read_buf

; 1381 :         s->lookahead += n;

  000c3	01 47 74	 add	 DWORD PTR [edi+116], eax
  000c6	83 c4 04	 add	 esp, 4
  000c9	8b 5f 74	 mov	 ebx, DWORD PTR [edi+116]

; 1382 : 
; 1383 :         /* Initialize the hash value now that we have some input: */
; 1384 :         if (s->lookahead >= MIN_MATCH) {

  000cc	83 fb 03	 cmp	 ebx, 3
  000cf	72 1d		 jb	 SHORT $LN2@fill_windo

; 1385 :             s->ins_h = s->window[s->strstart];

  000d1	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  000d4	03 47 38	 add	 eax, DWORD PTR [edi+56]

; 1386 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  000d7	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  000da	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  000dd	89 57 48	 mov	 DWORD PTR [edi+72], edx
  000e0	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  000e4	d3 e2		 shl	 edx, cl
  000e6	33 d0		 xor	 edx, eax
  000e8	23 57 54	 and	 edx, DWORD PTR [edi+84]
  000eb	89 57 48	 mov	 DWORD PTR [edi+72], edx
$LN2@fill_windo:

; 1387 : #if MIN_MATCH != 3
; 1388 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1389 : #endif
; 1390 :         }
; 1391 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1392 :          * but this is not important since only literal bytes will be emitted.
; 1393 :          */
; 1394 : 
; 1395 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  000ee	81 fb 06 01 00
	00		 cmp	 ebx, 262		; 00000106H
  000f4	73 0c		 jae	 SHORT $LN18@fill_windo
  000f6	8b 07		 mov	 eax, DWORD PTR [edi]
  000f8	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000fc	0f 85 0f ff ff
	ff		 jne	 $LL4@fill_windo
$LN18@fill_windo:

; 1396 : 
; 1397 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1398 :      * written, then zero those bytes in order to avoid memory check reports of
; 1399 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1400 :      * the longest match routines.  Update the high water mark for the next
; 1401 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1402 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1403 :      */
; 1404 :     if (s->high_water < s->window_size) {

  00102	8b 97 c0 16 00
	00		 mov	 edx, DWORD PTR [edi+5824]
  00108	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  0010b	3b d6		 cmp	 edx, esi
  0010d	73 6b		 jae	 SHORT $LN23@fill_windo

; 1405 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  0010f	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  00112	03 cb		 add	 ecx, ebx
  00114	89 4d f8	 mov	 DWORD PTR _curr$1$[ebp], ecx

; 1406 :         ulg init;
; 1407 : 
; 1408 :         if (s->high_water < curr) {

  00117	3b d1		 cmp	 edx, ecx
  00119	73 2f		 jae	 SHORT $LN20@fill_windo

; 1409 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1410 :              * bytes or up to end of window, whichever is less.
; 1411 :              */
; 1412 :             init = s->window_size - curr;

  0011b	2b f1		 sub	 esi, ecx

; 1413 :             if (init > WIN_INIT)

  0011d	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00122	3b f0		 cmp	 esi, eax
  00124	0f 47 f0	 cmova	 esi, eax

; 1414 :                 init = WIN_INIT;
; 1415 :             zmemzero(s->window + curr, (unsigned)init);

  00127	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  0012a	56		 push	 esi
  0012b	03 c1		 add	 eax, ecx
  0012d	6a 00		 push	 0
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 _memset

; 1416 :             s->high_water = curr + init;

  00135	8b 45 f8	 mov	 eax, DWORD PTR _curr$1$[ebp]
  00138	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013b	03 c6		 add	 eax, esi
  0013d	89 87 c0 16 00
	00		 mov	 DWORD PTR [edi+5824], eax
  00143	5f		 pop	 edi

; 1428 :         }
; 1429 :     }
; 1430 : }

  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
$LN20@fill_windo:

; 1417 :         }
; 1418 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  0014a	8d 81 02 01 00
	00		 lea	 eax, DWORD PTR [ecx+258]
  00150	3b d0		 cmp	 edx, eax
  00152	73 26		 jae	 SHORT $LN23@fill_windo

; 1419 :             /* High water mark at or above current data, but below current data
; 1420 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1421 :              * to end of window, whichever is less.
; 1422 :              */
; 1423 :             init = (ulg)curr + WIN_INIT - s->high_water;

  00154	2b ca		 sub	 ecx, edx

; 1424 :             if (init > s->window_size - s->high_water)

  00156	2b f2		 sub	 esi, edx
  00158	8d 81 02 01 00
	00		 lea	 eax, DWORD PTR [ecx+258]

; 1425 :                 init = s->window_size - s->high_water;
; 1426 :             zmemzero(s->window + s->high_water, (unsigned)init);

  0015e	3b c6		 cmp	 eax, esi
  00160	0f 46 f0	 cmovbe	 esi, eax
  00163	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00166	56		 push	 esi
  00167	03 c2		 add	 eax, edx
  00169	6a 00		 push	 0
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _memset
  00171	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1427 :             s->high_water += init;

  00174	01 b7 c0 16 00
	00		 add	 DWORD PTR [edi+5824], esi
$LN23@fill_windo:

; 1428 :         }
; 1429 :     }
; 1430 : }

  0017a	5f		 pop	 edi
  0017b	5e		 pop	 esi
  0017c	5b		 pop	 ebx
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c3		 ret	 0
_fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflate_stored
_TEXT	SEGMENT
_max_block_size$2$ = 8					; size = 4
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_stored PROC					; COMDAT

; 1465 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1506 :             FLUSH_BLOCK(s, 0);

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00007	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00010	57		 push	 edi
  00011	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00014	83 c0 fb	 add	 eax, -5			; fffffffbH
  00017	3b c1		 cmp	 eax, ecx
  00019	0f 42 c8	 cmovb	 ecx, eax
  0001c	89 4d 08	 mov	 DWORD PTR _max_block_size$2$[ebp], ecx
  0001f	90		 npad	 1
$LL2@deflate_st:

; 1466 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1467 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1468 :      */
; 1469 :     ulg max_block_size = 0xffff;
; 1470 :     ulg max_start;
; 1471 : 
; 1472 :     if (max_block_size > s->pending_buf_size - 5) {
; 1473 :         max_block_size = s->pending_buf_size - 5;
; 1474 :     }
; 1475 : 
; 1476 :     /* Copy as much as possible from input to output: */
; 1477 :     for (;;) {
; 1478 :         /* Fill the window as much as possible: */
; 1479 :         if (s->lookahead <= 1) {

  00020	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00023	83 f8 01	 cmp	 eax, 1
  00026	77 1e		 ja	 SHORT $LN8@deflate_st

; 1480 : 
; 1481 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1482 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1483 : 
; 1484 :             fill_window(s);

  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 _fill_window

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  0002f	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00032	85 c0		 test	 eax, eax
  00034	75 10		 jne	 SHORT $LN8@deflate_st
  00036	85 db		 test	 ebx, ebx
  00038	0f 84 a8 00 00
	00		 je	 $LN27@deflate_st

; 1486 : 
; 1487 :             if (s->lookahead == 0) break; /* flush the current block */

  0003e	85 c0		 test	 eax, eax
  00040	0f 84 a7 00 00
	00		 je	 $LN25@deflate_st
$LN8@deflate_st:

; 1488 :         }
; 1489 :         Assert(s->block_start >= 0L, "block gone");
; 1490 : 
; 1491 :         s->strstart += s->lookahead;
; 1492 :         s->lookahead = 0;
; 1493 : 
; 1494 :         /* Emit a stored block if pending_buf will be full: */
; 1495 :         max_start = s->block_start + max_block_size;

  00046	8b 7e 5c	 mov	 edi, DWORD PTR [esi+92]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _max_block_size$2$[ebp]
  0004c	01 46 6c	 add	 DWORD PTR [esi+108], eax
  0004f	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00052	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0
  00059	8d 0c 0f	 lea	 ecx, DWORD PTR [edi+ecx]

; 1496 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  0005c	74 04		 je	 SHORT $LN31@deflate_st
  0005e	3b c1		 cmp	 eax, ecx
  00060	72 39		 jb	 SHORT $LN36@deflate_st
$LN31@deflate_st:

; 1497 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1498 :             s->lookahead = (uInt)(s->strstart - max_start);

  00062	2b c1		 sub	 eax, ecx

; 1499 :             s->strstart = (uInt)max_start;

  00064	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  00067	89 46 74	 mov	 DWORD PTR [esi+116], eax

; 1500 :             FLUSH_BLOCK(s, 0);

  0006a	85 ff		 test	 edi, edi
  0006c	78 07		 js	 SHORT $LN16@deflate_st
  0006e	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00071	03 d7		 add	 edx, edi
  00073	eb 02		 jmp	 SHORT $LN17@deflate_st
$LN16@deflate_st:
  00075	33 d2		 xor	 edx, edx
$LN17@deflate_st:
  00077	6a 00		 push	 0
  00079	ff 75 08	 push	 DWORD PTR _max_block_size$2$[ebp]
  0007c	8b ce		 mov	 ecx, esi
  0007e	e8 00 00 00 00	 call	 __tr_flush_block
  00083	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00086	83 c4 08	 add	 esp, 8
  00089	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008b	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0008e	e8 00 00 00 00	 call	 _flush_pending
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00099	74 4b		 je	 SHORT $LN27@deflate_st
$LN36@deflate_st:

; 1501 :         }
; 1502 :         /* Flush if we may have to slide, otherwise block_start may become
; 1503 :          * negative and the data will be gone:
; 1504 :          */
; 1505 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  0009b	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0009e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a1	8b 7e 5c	 mov	 edi, DWORD PTR [esi+92]
  000a4	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000a9	2b cf		 sub	 ecx, edi
  000ab	3b c8		 cmp	 ecx, eax
  000ad	0f 82 6d ff ff
	ff		 jb	 $LL2@deflate_st

; 1506 :             FLUSH_BLOCK(s, 0);

  000b3	85 ff		 test	 edi, edi
  000b5	78 07		 js	 SHORT $LN18@deflate_st
  000b7	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  000ba	03 d7		 add	 edx, edi
  000bc	eb 02		 jmp	 SHORT $LN19@deflate_st
$LN18@deflate_st:
  000be	33 d2		 xor	 edx, edx
$LN19@deflate_st:
  000c0	6a 00		 push	 0
  000c2	51		 push	 ecx
  000c3	8b ce		 mov	 ecx, esi
  000c5	e8 00 00 00 00	 call	 __tr_flush_block
  000ca	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000cd	83 c4 08	 add	 esp, 8
  000d0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d2	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000d5	e8 00 00 00 00	 call	 _flush_pending
  000da	8b 06		 mov	 eax, DWORD PTR [esi]
  000dc	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000e0	0f 85 3a ff ff
	ff		 jne	 $LL2@deflate_st
$LN27@deflate_st:
  000e6	5f		 pop	 edi

; 1511 : }

  000e7	5e		 pop	 esi
  000e8	33 c0		 xor	 eax, eax
  000ea	5b		 pop	 ebx
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
$LN25@deflate_st:

; 1507 :         }
; 1508 :     }
; 1509 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  000ed	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  000f0	85 c9		 test	 ecx, ecx
  000f2	78 07		 js	 SHORT $LN20@deflate_st
  000f4	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  000f7	03 d1		 add	 edx, ecx
  000f9	eb 02		 jmp	 SHORT $LN21@deflate_st
$LN20@deflate_st:
  000fb	33 d2		 xor	 edx, edx
$LN21@deflate_st:
  000fd	33 c0		 xor	 eax, eax
  000ff	83 fb 04	 cmp	 ebx, 4
  00102	0f 94 c0	 sete	 al
  00105	50		 push	 eax
  00106	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00109	2b c1		 sub	 eax, ecx
  0010b	8b ce		 mov	 ecx, esi
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 __tr_flush_block
  00113	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00116	83 c4 08	 add	 esp, 8
  00119	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0011b	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0011e	e8 00 00 00 00	 call	 _flush_pending
  00123	8b 06		 mov	 eax, DWORD PTR [esi]
  00125	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00129	75 12		 jne	 SHORT $LN14@deflate_st
  0012b	33 c0		 xor	 eax, eax
  0012d	b9 02 00 00 00	 mov	 ecx, 2
  00132	5f		 pop	 edi
  00133	83 fb 04	 cmp	 ebx, 4

; 1511 : }

  00136	5e		 pop	 esi
  00137	0f 44 c1	 cmove	 eax, ecx
  0013a	5b		 pop	 ebx
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
$LN14@deflate_st:

; 1510 :     return flush == Z_FINISH ? finish_done : block_done;

  0013d	33 c0		 xor	 eax, eax
  0013f	83 fb 04	 cmp	 ebx, 4
  00142	5f		 pop	 edi
  00143	0f 94 c0	 sete	 al

; 1511 : }

  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
_deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflate_fast
_TEXT	SEGMENT
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_fast PROC					; COMDAT

; 1523 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000b	57		 push	 edi
  0000c	0f 1f 40 00	 npad	 4
$LL2@deflate_fa:

; 1524 :     IPos hash_head;       /* head of the hash chain */
; 1525 :     int bflush;           /* set if current block must be flushed */
; 1526 : 
; 1527 :     for (;;) {
; 1528 :         /* Make sure that we always have enough lookahead, except
; 1529 :          * at the end of the input file. We need MAX_MATCH bytes
; 1530 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1531 :          * string following the next match.
; 1532 :          */
; 1533 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00013	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00018	73 21		 jae	 SHORT $LN10@deflate_fa

; 1534 :             fill_window(s);

  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 _fill_window

; 1535 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00021	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00024	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00029	73 08		 jae	 SHORT $LN9@deflate_fa
  0002b	85 db		 test	 ebx, ebx
  0002d	0f 84 31 02 00
	00		 je	 $LN32@deflate_fa
$LN9@deflate_fa:

; 1536 :                 return need_more;
; 1537 :             }
; 1538 :             if (s->lookahead == 0) break; /* flush the current block */

  00033	85 c0		 test	 eax, eax
  00035	0f 84 30 02 00
	00		 je	 $LN31@deflate_fa
$LN10@deflate_fa:

; 1539 :         }
; 1540 : 
; 1541 :         /* Insert the string window[strstart .. strstart+2] in the
; 1542 :          * dictionary, and set hash_head to the head of the hash chain:
; 1543 :          */
; 1544 :         hash_head = NIL;
; 1545 :         if (s->lookahead >= MIN_MATCH) {

  0003b	83 f8 03	 cmp	 eax, 3
  0003e	72 66		 jb	 SHORT $LN12@deflate_fa

; 1546 :             INSERT_STRING(s, s->strstart, hash_head);

  00040	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]
  00043	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00046	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00049	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0004c	d3 e2		 shl	 edx, cl
  0004e	0f b6 44 38 02	 movzx	 eax, BYTE PTR [eax+edi+2]
  00053	23 7e 34	 and	 edi, DWORD PTR [esi+52]
  00056	33 d0		 xor	 edx, eax
  00058	23 56 54	 and	 edx, DWORD PTR [esi+84]
  0005b	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0005e	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00061	89 56 48	 mov	 DWORD PTR [esi+72], edx
  00064	66 8b 04 50	 mov	 ax, WORD PTR [eax+edx*2]
  00068	66 89 04 79	 mov	 WORD PTR [ecx+edi*2], ax
  0006c	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  0006f	8b ca		 mov	 ecx, edx
  00071	23 4e 34	 and	 ecx, DWORD PTR [esi+52]
  00074	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00077	0f b7 3c 48	 movzx	 edi, WORD PTR [eax+ecx*2]
  0007b	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  0007e	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00081	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 1547 :         }
; 1548 : 
; 1549 :         /* Find the longest match, discarding those <= prev_length.
; 1550 :          * At this point we have always match_length < MIN_MATCH
; 1551 :          */
; 1552 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  00085	85 ff		 test	 edi, edi
  00087	74 1d		 je	 SHORT $LN12@deflate_fa
  00089	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0008c	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0008f	2b cf		 sub	 ecx, edi
  00091	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00096	3b c8		 cmp	 ecx, eax
  00098	77 0c		 ja	 SHORT $LN12@deflate_fa

; 1553 :             /* To simplify the code, we prevent matches with the string
; 1554 :              * of window index 0 (in particular we have to avoid a match
; 1555 :              * of the string with itself at the start of the input file).
; 1556 :              */
; 1557 :             s->match_length = longest_match (s, hash_head);

  0009a	8b d7		 mov	 edx, edi
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 _longest_match
  000a3	89 46 60	 mov	 DWORD PTR [esi+96], eax
$LN12@deflate_fa:

; 1558 :             /* longest_match() sets match_start */
; 1559 :         }
; 1560 :         if (s->match_length >= MIN_MATCH) {

  000a6	8b 5e 60	 mov	 ebx, DWORD PTR [esi+96]
  000a9	83 fb 03	 cmp	 ebx, 3
  000ac	0f 82 19 01 00
	00		 jb	 $LN13@deflate_fa

; 1561 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1562 : 
; 1563 :             _tr_tally_dist(s, s->strstart - s->match_start,

  000b2	66 8b 46 6c	 mov	 ax, WORD PTR [esi+108]
  000b6	80 eb 03	 sub	 bl, 3
  000b9	66 2b 46 70	 sub	 ax, WORD PTR [esi+112]
  000bd	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  000c3	0f b7 d0	 movzx	 edx, ax
  000c6	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  000cc	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  000d0	81 c2 ff ff 00
	00		 add	 edx, 65535		; 0000ffffH
  000d6	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  000dc	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  000e2	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  000e5	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000ea	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  000f0	0f b6 c3	 movzx	 eax, bl
  000f3	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  000fa	66 ff 84 86 98
	04 00 00	 inc	 WORD PTR [esi+eax*4+1176]
  00102	0f b7 c2	 movzx	 eax, dx
  00105	66 3b d1	 cmp	 dx, cx
  00108	73 08		 jae	 SHORT $LN21@deflate_fa
  0010a	8a 80 00 00 00
	00		 mov	 al, BYTE PTR __dist_code[eax]
  00110	eb 09		 jmp	 SHORT $LN22@deflate_fa
$LN21@deflate_fa:
  00112	c1 e8 07	 shr	 eax, 7
  00115	8a 80 00 01 00
	00		 mov	 al, BYTE PTR __dist_code[eax+256]
$LN22@deflate_fa:
  0011b	0f b6 c0	 movzx	 eax, al
  0011e	33 db		 xor	 ebx, ebx
  00120	66 ff 84 86 88
	09 00 00	 inc	 WORD PTR [esi+eax*4+2440]
  00128	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]

; 1564 :                            s->match_length - MIN_MATCH, bflush);
; 1565 : 
; 1566 :             s->lookahead -= s->match_length;

  0012e	8b 4e 60	 mov	 ecx, DWORD PTR [esi+96]
  00131	48		 dec	 eax
  00132	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax
  00138	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  0013b	0f 94 c3	 sete	 bl
  0013e	2b c1		 sub	 eax, ecx
  00140	89 46 74	 mov	 DWORD PTR [esi+116], eax

; 1567 : 
; 1568 :             /* Insert new strings in the hash table only if the match length
; 1569 :              * is not too large. This saves time but degrades compression.
; 1570 :              */
; 1571 : #ifndef FASTEST
; 1572 :             if (s->match_length <= s->max_insert_length &&

  00143	3b 8e 80 00 00
	00		 cmp	 ecx, DWORD PTR [esi+128]
  00149	77 53		 ja	 SHORT $LN39@deflate_fa
  0014b	83 f8 03	 cmp	 eax, 3
  0014e	72 4e		 jb	 SHORT $LN39@deflate_fa

; 1573 :                 s->lookahead >= MIN_MATCH) {
; 1574 :                 s->match_length--; /* string at strstart already in table */

  00150	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00153	89 46 60	 mov	 DWORD PTR [esi+96], eax
$LL7@deflate_fa:

; 1575 :                 do {
; 1576 :                     s->strstart++;

  00156	ff 46 6c	 inc	 DWORD PTR [esi+108]
  00159	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]

; 1577 :                     INSERT_STRING(s, s->strstart, hash_head);

  0015c	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0015f	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00162	0f b6 54 07 02	 movzx	 edx, BYTE PTR [edi+eax+2]
  00167	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  0016a	23 7e 34	 and	 edi, DWORD PTR [esi+52]
  0016d	d3 e0		 shl	 eax, cl
  0016f	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00172	33 d0		 xor	 edx, eax
  00174	23 56 54	 and	 edx, DWORD PTR [esi+84]
  00177	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0017a	89 56 48	 mov	 DWORD PTR [esi+72], edx
  0017d	0f b7 04 50	 movzx	 eax, WORD PTR [eax+edx*2]
  00181	66 89 04 79	 mov	 WORD PTR [ecx+edi*2], ax
  00185	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  00188	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0018b	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  0018f	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax

; 1578 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1579 :                      * always MIN_MATCH bytes ahead.
; 1580 :                      */
; 1581 :                 } while (--s->match_length != 0);

  00193	83 46 60 ff	 add	 DWORD PTR [esi+96], -1
  00197	75 bd		 jne	 SHORT $LL7@deflate_fa

; 1582 :                 s->strstart++;
; 1583 :             } else

  00199	e9 7d 00 00 00	 jmp	 $LN41@deflate_fa
$LN39@deflate_fa:

; 1584 : #endif
; 1585 :             {
; 1586 :                 s->strstart += s->match_length;

  0019e	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]

; 1587 :                 s->match_length = 0;
; 1588 :                 s->ins_h = s->window[s->strstart];

  001a1	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001a4	03 f9		 add	 edi, ecx

; 1589 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  001a6	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  001a9	89 7e 6c	 mov	 DWORD PTR [esi+108], edi
  001ac	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  001b3	0f b6 14 38	 movzx	 edx, BYTE PTR [eax+edi]
  001b7	89 56 48	 mov	 DWORD PTR [esi+72], edx
  001ba	0f b6 44 38 01	 movzx	 eax, BYTE PTR [eax+edi+1]
  001bf	d3 e2		 shl	 edx, cl
  001c1	33 d0		 xor	 edx, eax
  001c3	23 56 54	 and	 edx, DWORD PTR [esi+84]
  001c6	89 56 48	 mov	 DWORD PTR [esi+72], edx

; 1590 : #if MIN_MATCH != 3
; 1591 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1592 : #endif
; 1593 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1594 :                  * matter since it will be recomputed at next deflate call.
; 1595 :                  */
; 1596 :             }
; 1597 :         } else {

  001c9	eb 56		 jmp	 SHORT $LN14@deflate_fa
$LN13@deflate_fa:

; 1598 :             /* No match, output a literal byte */
; 1599 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1600 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001cb	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  001ce	33 ff		 xor	 edi, edi
  001d0	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  001d3	33 db		 xor	 ebx, ebx
  001d5	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001d8	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  001de	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  001e4	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  001e8	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  001ee	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  001f4	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  001f7	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  001fd	0f b6 c2	 movzx	 eax, dl
  00200	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  00208	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  0020e	48		 dec	 eax
  0020f	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax
  00215	0f 94 c3	 sete	 bl

; 1601 :             s->lookahead--;

  00218	ff 4e 74	 dec	 DWORD PTR [esi+116]
$LN41@deflate_fa:

; 1602 :             s->strstart++;
; 1603 :         }
; 1604 :         if (bflush) FLUSH_BLOCK(s, 0);

  0021b	ff 46 6c	 inc	 DWORD PTR [esi+108]
  0021e	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]
$LN14@deflate_fa:
  00221	85 db		 test	 ebx, ebx
  00223	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00226	0f 84 e4 fd ff
	ff		 je	 $LL2@deflate_fa
  0022c	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0022f	85 c0		 test	 eax, eax
  00231	78 07		 js	 SHORT $LN23@deflate_fa
  00233	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00236	03 d0		 add	 edx, eax
  00238	eb 02		 jmp	 SHORT $LN24@deflate_fa
$LN23@deflate_fa:
  0023a	33 d2		 xor	 edx, edx
$LN24@deflate_fa:
  0023c	2b f8		 sub	 edi, eax
  0023e	8b ce		 mov	 ecx, esi
  00240	6a 00		 push	 0
  00242	57		 push	 edi
  00243	e8 00 00 00 00	 call	 __tr_flush_block
  00248	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0024b	83 c4 08	 add	 esp, 8
  0024e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00250	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00253	e8 00 00 00 00	 call	 _flush_pending
  00258	8b 06		 mov	 eax, DWORD PTR [esi]
  0025a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0025e	0f 85 ac fd ff
	ff		 jne	 $LL2@deflate_fa
$LN32@deflate_fa:
  00264	5f		 pop	 edi

; 1608 : }

  00265	5e		 pop	 esi
  00266	33 c0		 xor	 eax, eax
  00268	5b		 pop	 ebx
  00269	5d		 pop	 ebp
  0026a	c3		 ret	 0
$LN31@deflate_fa:

; 1605 :     }
; 1606 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0026b	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0026e	85 c9		 test	 ecx, ecx
  00270	78 07		 js	 SHORT $LN25@deflate_fa
  00272	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00275	03 d1		 add	 edx, ecx
  00277	eb 02		 jmp	 SHORT $LN26@deflate_fa
$LN25@deflate_fa:
  00279	33 d2		 xor	 edx, edx
$LN26@deflate_fa:
  0027b	33 c0		 xor	 eax, eax
  0027d	83 fb 04	 cmp	 ebx, 4
  00280	0f 94 c0	 sete	 al
  00283	50		 push	 eax
  00284	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00287	2b c1		 sub	 eax, ecx
  00289	8b ce		 mov	 ecx, esi
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 __tr_flush_block
  00291	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00294	83 c4 08	 add	 esp, 8
  00297	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00299	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0029c	e8 00 00 00 00	 call	 _flush_pending
  002a1	8b 06		 mov	 eax, DWORD PTR [esi]
  002a3	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  002a7	75 12		 jne	 SHORT $LN19@deflate_fa
  002a9	33 c0		 xor	 eax, eax
  002ab	b9 02 00 00 00	 mov	 ecx, 2
  002b0	5f		 pop	 edi
  002b1	83 fb 04	 cmp	 ebx, 4

; 1608 : }

  002b4	5e		 pop	 esi
  002b5	0f 44 c1	 cmove	 eax, ecx
  002b8	5b		 pop	 ebx
  002b9	5d		 pop	 ebp
  002ba	c3		 ret	 0
$LN19@deflate_fa:

; 1607 :     return flush == Z_FINISH ? finish_done : block_done;

  002bb	33 c0		 xor	 eax, eax
  002bd	83 fb 04	 cmp	 ebx, 4
  002c0	5f		 pop	 edi
  002c1	0f 94 c0	 sete	 al

; 1608 : }

  002c4	5e		 pop	 esi
  002c5	5b		 pop	 ebx
  002c6	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  002cd	5d		 pop	 ebp
  002ce	c3		 ret	 0
_deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflate_slow
_TEXT	SEGMENT
tv1284 = -8						; size = 4
tv1278 = -4						; size = 4
_max_insert$1$ = 8					; size = 4
_s$ = 8							; size = 4
_flush$ = 12						; size = 4
_deflate_slow PROC					; COMDAT

; 1619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  0000b	57		 push	 edi
  0000c	0f 1f 40 00	 npad	 4
$LL50@deflate_sl:

; 1620 :     IPos hash_head;          /* head of hash chain */
; 1621 :     int bflush;              /* set if current block must be flushed */
; 1622 : 
; 1623 :     /* Process the input block. */
; 1624 :     for (;;) {
; 1625 :         /* Make sure that we always have enough lookahead, except
; 1626 :          * at the end of the input file. We need MAX_MATCH bytes
; 1627 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1628 :          * string following the next match.
; 1629 :          */
; 1630 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00013	8b 5d 0c	 mov	 ebx, DWORD PTR _flush$[ebp]
  00016	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0001b	73 21		 jae	 SHORT $LN10@deflate_sl

; 1631 :             fill_window(s);

  0001d	8b ce		 mov	 ecx, esi
  0001f	e8 00 00 00 00	 call	 _fill_window

; 1632 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00024	8b 46 74	 mov	 eax, DWORD PTR [esi+116]
  00027	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0002c	73 08		 jae	 SHORT $LN9@deflate_sl
  0002e	85 db		 test	 ebx, ebx
  00030	0f 84 23 02 00
	00		 je	 $LN41@deflate_sl
$LN9@deflate_sl:

; 1633 :                 return need_more;
; 1634 :             }
; 1635 :             if (s->lookahead == 0) break; /* flush the current block */

  00036	85 c0		 test	 eax, eax
  00038	0f 84 d0 02 00
	00		 je	 $LN39@deflate_sl
$LN10@deflate_sl:

; 1636 :         }
; 1637 : 
; 1638 :         /* Insert the string window[strstart .. strstart+2] in the
; 1639 :          * dictionary, and set hash_head to the head of the hash chain:
; 1640 :          */
; 1641 :         hash_head = NIL;

  0003e	33 ff		 xor	 edi, edi

; 1642 :         if (s->lookahead >= MIN_MATCH) {

  00040	83 f8 03	 cmp	 eax, 3
  00043	72 45		 jb	 SHORT $LN11@deflate_sl

; 1643 :             INSERT_STRING(s, s->strstart, hash_head);

  00045	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]
  00048	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0004b	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  0004e	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00051	d3 e2		 shl	 edx, cl
  00053	0f b6 44 38 02	 movzx	 eax, BYTE PTR [eax+edi+2]
  00058	23 7e 34	 and	 edi, DWORD PTR [esi+52]
  0005b	33 d0		 xor	 edx, eax
  0005d	23 56 54	 and	 edx, DWORD PTR [esi+84]
  00060	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00063	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  00066	89 56 48	 mov	 DWORD PTR [esi+72], edx
  00069	66 8b 04 50	 mov	 ax, WORD PTR [eax+edx*2]
  0006d	66 89 04 79	 mov	 WORD PTR [ecx+edi*2], ax
  00071	8b 56 6c	 mov	 edx, DWORD PTR [esi+108]
  00074	8b ca		 mov	 ecx, edx
  00076	23 4e 34	 and	 ecx, DWORD PTR [esi+52]
  00079	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0007c	0f b7 3c 48	 movzx	 edi, WORD PTR [eax+ecx*2]
  00080	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00083	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00086	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
$LN11@deflate_sl:

; 1644 :         }
; 1645 : 
; 1646 :         /* Find the longest match, discarding those <= prev_length.
; 1647 :          */
; 1648 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  0008a	8b 4e 60	 mov	 ecx, DWORD PTR [esi+96]

; 1649 :         s->match_length = MIN_MATCH-1;

  0008d	ba 02 00 00 00	 mov	 edx, 2
  00092	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  00095	89 4e 78	 mov	 DWORD PTR [esi+120], ecx
  00098	89 46 64	 mov	 DWORD PTR [esi+100], eax
  0009b	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2

; 1650 : 
; 1651 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&

  000a2	85 ff		 test	 edi, edi
  000a4	74 53		 je	 SHORT $LN13@deflate_sl
  000a6	3b 8e 80 00 00
	00		 cmp	 ecx, DWORD PTR [esi+128]
  000ac	73 4b		 jae	 SHORT $LN13@deflate_sl
  000ae	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  000b1	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000b4	2b cf		 sub	 ecx, edi
  000b6	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000bb	3b c8		 cmp	 ecx, eax
  000bd	77 3a		 ja	 SHORT $LN13@deflate_sl

; 1652 :             s->strstart - hash_head <= MAX_DIST(s)) {
; 1653 :             /* To simplify the code, we prevent matches with the string
; 1654 :              * of window index 0 (in particular we have to avoid a match
; 1655 :              * of the string with itself at the start of the input file).
; 1656 :              */
; 1657 :             s->match_length = longest_match (s, hash_head);

  000bf	8b d7		 mov	 edx, edi
  000c1	8b ce		 mov	 ecx, esi
  000c3	e8 00 00 00 00	 call	 _longest_match
  000c8	89 46 60	 mov	 DWORD PTR [esi+96], eax

; 1658 :             /* longest_match() sets match_start */
; 1659 : 
; 1660 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED

  000cb	8b d0		 mov	 edx, eax
  000cd	83 f8 05	 cmp	 eax, 5
  000d0	77 27		 ja	 SHORT $LN13@deflate_sl
  000d2	83 be 88 00 00
	00 01		 cmp	 DWORD PTR [esi+136], 1
  000d9	74 12		 je	 SHORT $LN14@deflate_sl
  000db	83 f8 03	 cmp	 eax, 3
  000de	75 19		 jne	 SHORT $LN13@deflate_sl
  000e0	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000e3	2b 46 70	 sub	 eax, DWORD PTR [esi+112]
  000e6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000eb	76 0c		 jbe	 SHORT $LN13@deflate_sl
$LN14@deflate_sl:

; 1661 : #if TOO_FAR <= 32767
; 1662 :                 || (s->match_length == MIN_MATCH &&
; 1663 :                     s->strstart - s->match_start > TOO_FAR)
; 1664 : #endif
; 1665 :                 )) {
; 1666 : 
; 1667 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1668 :                  * but we will ignore the current match anyway.
; 1669 :                  */
; 1670 :                 s->match_length = MIN_MATCH-1;

  000ed	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2
  000f4	ba 02 00 00 00	 mov	 edx, 2
$LN13@deflate_sl:

; 1671 :             }
; 1672 :         }
; 1673 :         /* If there was a match at the previous step and the current
; 1674 :          * match is not better, output the previous match:
; 1675 :          */
; 1676 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  000f9	8b 5e 78	 mov	 ebx, DWORD PTR [esi+120]
  000fc	83 fb 03	 cmp	 ebx, 3
  000ff	0f 82 5d 01 00
	00		 jb	 $LN44@deflate_sl
  00105	3b d3		 cmp	 edx, ebx
  00107	0f 87 55 01 00
	00		 ja	 $LN44@deflate_sl

; 1677 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0010d	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]

; 1678 :             /* Do not insert strings in hash table beyond this. */
; 1679 : 
; 1680 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1681 : 
; 1682 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,

  00110	80 eb 03	 sub	 bl, 3
  00113	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00116	83 c7 fd	 add	 edi, -3			; fffffffdH
  00119	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0011f	03 f9		 add	 edi, ecx
  00121	66 2b 4e 64	 sub	 cx, WORD PTR [esi+100]
  00125	66 49		 dec	 cx
  00127	89 7d 08	 mov	 DWORD PTR _max_insert$1$[ebp], edi
  0012a	0f b7 d1	 movzx	 edx, cx
  0012d	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00133	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  00137	81 c2 ff ff 00
	00		 add	 edx, 65535		; 0000ffffH
  0013d	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00143	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  00149	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
  0014c	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00151	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00157	0f b6 c3	 movzx	 eax, bl
  0015a	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  00161	66 ff 84 86 98
	04 00 00	 inc	 WORD PTR [esi+eax*4+1176]
  00169	0f b7 c2	 movzx	 eax, dx
  0016c	66 3b d1	 cmp	 dx, cx
  0016f	73 08		 jae	 SHORT $LN27@deflate_sl
  00171	8a 80 00 00 00
	00		 mov	 al, BYTE PTR __dist_code[eax]
  00177	eb 09		 jmp	 SHORT $LN28@deflate_sl
$LN27@deflate_sl:
  00179	c1 e8 07	 shr	 eax, 7
  0017c	8a 80 00 01 00
	00		 mov	 al, BYTE PTR __dist_code[eax+256]
$LN28@deflate_sl:
  00182	0f b6 c0	 movzx	 eax, al
  00185	66 ff 84 86 88
	09 00 00	 inc	 WORD PTR [esi+eax*4+2440]
  0018d	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]

; 1683 :                            s->prev_length - MIN_MATCH, bflush);
; 1684 : 
; 1685 :             /* Insert in hash table all strings up to the end of the match.
; 1686 :              * strstart-1 and strstart are already inserted. If there is not
; 1687 :              * enough lookahead, the last two strings are not inserted in
; 1688 :              * the hash table.
; 1689 :              */
; 1690 :             s->lookahead -= s->prev_length-1;

  00193	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00196	48		 dec	 eax
  00197	89 45 f8	 mov	 DWORD PTR tv1284[ebp], eax
  0019a	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  001a0	89 45 fc	 mov	 DWORD PTR tv1278[ebp], eax
  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	2b c1		 sub	 eax, ecx
  001aa	01 46 74	 add	 DWORD PTR [esi+116], eax

; 1691 :             s->prev_length -= 2;

  001ad	8d 41 fe	 lea	 eax, DWORD PTR [ecx-2]
  001b0	89 46 78	 mov	 DWORD PTR [esi+120], eax
$LL7@deflate_sl:

; 1692 :             do {
; 1693 :                 if (++s->strstart <= max_insert) {

  001b3	8b 5e 6c	 mov	 ebx, DWORD PTR [esi+108]
  001b6	43		 inc	 ebx
  001b7	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx
  001ba	3b df		 cmp	 ebx, edi
  001bc	77 3f		 ja	 SHORT $LN5@deflate_sl

; 1694 :                     INSERT_STRING(s, s->strstart, hash_head);

  001be	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001c1	8b 7e 48	 mov	 edi, DWORD PTR [esi+72]
  001c4	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  001c7	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  001ca	0f b6 44 18 02	 movzx	 eax, BYTE PTR [eax+ebx+2]
  001cf	d3 e7		 shl	 edi, cl
  001d1	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  001d4	33 f8		 xor	 edi, eax
  001d6	23 7e 54	 and	 edi, DWORD PTR [esi+84]
  001d9	23 d3		 and	 edx, ebx
  001db	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  001de	89 7e 48	 mov	 DWORD PTR [esi+72], edi
  001e1	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  001e5	8b 7d 08	 mov	 edi, DWORD PTR _max_insert$1$[ebp]
  001e8	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  001ec	8b 56 48	 mov	 edx, DWORD PTR [esi+72]
  001ef	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  001f2	0f b7 46 6c	 movzx	 eax, WORD PTR [esi+108]
  001f6	66 89 04 51	 mov	 WORD PTR [ecx+edx*2], ax
  001fa	8b 5e 6c	 mov	 ebx, DWORD PTR [esi+108]
$LN5@deflate_sl:

; 1695 :                 }
; 1696 :             } while (--s->prev_length != 0);

  001fd	83 46 78 ff	 add	 DWORD PTR [esi+120], -1
  00201	75 b0		 jne	 SHORT $LL7@deflate_sl

; 1697 :             s->match_available = 0;
; 1698 :             s->match_length = MIN_MATCH-1;
; 1699 :             s->strstart++;
; 1700 : 
; 1701 :             if (bflush) FLUSH_BLOCK(s, 0);

  00203	8b 45 fc	 mov	 eax, DWORD PTR tv1278[ebp]
  00206	43		 inc	 ebx
  00207	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  0020e	c7 46 60 02 00
	00 00		 mov	 DWORD PTR [esi+96], 2
  00215	89 5e 6c	 mov	 DWORD PTR [esi+108], ebx
  00218	3b 45 f8	 cmp	 eax, DWORD PTR tv1284[ebp]
  0021b	0f 85 ef fd ff
	ff		 jne	 $LL50@deflate_sl
  00221	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  00224	85 c0		 test	 eax, eax
  00226	78 07		 js	 SHORT $LN29@deflate_sl
  00228	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  0022b	03 d0		 add	 edx, eax
  0022d	eb 02		 jmp	 SHORT $LN30@deflate_sl
$LN29@deflate_sl:
  0022f	33 d2		 xor	 edx, edx
$LN30@deflate_sl:
  00231	2b d8		 sub	 ebx, eax
  00233	8b ce		 mov	 ecx, esi
  00235	6a 00		 push	 0
  00237	53		 push	 ebx
  00238	e8 00 00 00 00	 call	 __tr_flush_block
  0023d	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00240	83 c4 08	 add	 esp, 8
  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00245	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00248	e8 00 00 00 00	 call	 _flush_pending
  0024d	8b 06		 mov	 eax, DWORD PTR [esi]
  0024f	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00253	0f 85 b7 fd ff
	ff		 jne	 $LL50@deflate_sl
$LN41@deflate_sl:
  00259	5f		 pop	 edi

; 1733 : }

  0025a	5e		 pop	 esi
  0025b	33 c0		 xor	 eax, eax
  0025d	5b		 pop	 ebx
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
$LN44@deflate_sl:

; 1702 : 
; 1703 :         } else if (s->match_available) {

  00262	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00266	0f 84 90 00 00
	00		 je	 $LN20@deflate_sl

; 1704 :             /* If there was no match at the previous position, output a
; 1705 :              * single literal. If there was a match but the current match
; 1706 :              * is longer, truncate the previous match to a single literal.
; 1707 :              */
; 1708 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1709 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  0026c	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0026f	33 ff		 xor	 edi, edi
  00271	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00274	8a 54 01 ff	 mov	 dl, BYTE PTR [ecx+eax-1]
  00278	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  0027e	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  00284	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  00288	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  0028e	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  00294	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00297	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  0029d	0f b6 c2	 movzx	 eax, dl
  002a0	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  002a8	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  002ae	48		 dec	 eax
  002af	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1710 :             if (bflush) {

  002b5	75 2f		 jne	 SHORT $LN22@deflate_sl

; 1711 :                 FLUSH_BLOCK_ONLY(s, 0);

  002b7	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  002ba	85 c9		 test	 ecx, ecx
  002bc	78 07		 js	 SHORT $LN31@deflate_sl
  002be	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  002c1	03 d1		 add	 edx, ecx
  002c3	eb 02		 jmp	 SHORT $LN32@deflate_sl
$LN31@deflate_sl:
  002c5	33 d2		 xor	 edx, edx
$LN32@deflate_sl:
  002c7	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  002ca	2b c1		 sub	 eax, ecx
  002cc	8b ce		 mov	 ecx, esi
  002ce	6a 00		 push	 0
  002d0	50		 push	 eax
  002d1	e8 00 00 00 00	 call	 __tr_flush_block
  002d6	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  002d9	83 c4 08	 add	 esp, 8
  002dc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002de	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  002e1	e8 00 00 00 00	 call	 _flush_pending
$LN22@deflate_sl:

; 1712 :             }
; 1713 :             s->strstart++;
; 1714 :             s->lookahead--;
; 1715 :             if (s->strm->avail_out == 0) return need_more;

  002e6	8b 06		 mov	 eax, DWORD PTR [esi]
  002e8	ff 46 6c	 inc	 DWORD PTR [esi+108]
  002eb	ff 4e 74	 dec	 DWORD PTR [esi+116]
  002ee	39 78 10	 cmp	 DWORD PTR [eax+16], edi
  002f1	0f 84 62 ff ff
	ff		 je	 $LN41@deflate_sl

; 1716 :         } else {

  002f7	e9 14 fd ff ff	 jmp	 $LL50@deflate_sl
$LN20@deflate_sl:

; 1717 :             /* There is no previous match to compare with, wait for
; 1718 :              * the next step to decide.
; 1719 :              */
; 1720 :             s->match_available = 1;
; 1721 :             s->strstart++;

  002fc	ff 46 6c	 inc	 DWORD PTR [esi+108]

; 1722 :             s->lookahead--;

  002ff	ff 4e 74	 dec	 DWORD PTR [esi+116]
  00302	c7 46 68 01 00
	00 00		 mov	 DWORD PTR [esi+104], 1

; 1723 :         }
; 1724 :     }

  00309	e9 02 fd ff ff	 jmp	 $LL50@deflate_sl
$LN39@deflate_sl:

; 1725 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1726 :     if (s->match_available) {

  0030e	83 7e 68 00	 cmp	 DWORD PTR [esi+104], 0
  00312	74 3f		 je	 SHORT $LN24@deflate_sl

; 1727 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1728 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00314	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00317	33 ff		 xor	 edi, edi
  00319	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0031c	8a 54 01 ff	 mov	 dl, BYTE PTR [ecx+eax-1]
  00320	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00326	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0032c	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  00330	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00336	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  0033c	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0033f	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00345	0f b6 c2	 movzx	 eax, dl
  00348	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]

; 1729 :         s->match_available = 0;

  00350	89 7e 68	 mov	 DWORD PTR [esi+104], edi
$LN24@deflate_sl:

; 1730 :     }
; 1731 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00353	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  00356	85 c9		 test	 ecx, ecx
  00358	78 07		 js	 SHORT $LN33@deflate_sl
  0035a	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  0035d	03 d1		 add	 edx, ecx
  0035f	eb 02		 jmp	 SHORT $LN34@deflate_sl
$LN33@deflate_sl:
  00361	33 d2		 xor	 edx, edx
$LN34@deflate_sl:
  00363	33 c0		 xor	 eax, eax
  00365	83 fb 04	 cmp	 ebx, 4
  00368	0f 94 c0	 sete	 al
  0036b	50		 push	 eax
  0036c	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0036f	2b c1		 sub	 eax, ecx
  00371	8b ce		 mov	 ecx, esi
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 __tr_flush_block
  00379	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  0037c	83 c4 08	 add	 esp, 8
  0037f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00381	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00384	e8 00 00 00 00	 call	 _flush_pending
  00389	8b 06		 mov	 eax, DWORD PTR [esi]
  0038b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0038f	75 14		 jne	 SHORT $LN25@deflate_sl
  00391	33 c0		 xor	 eax, eax
  00393	b9 02 00 00 00	 mov	 ecx, 2
  00398	5f		 pop	 edi
  00399	83 fb 04	 cmp	 ebx, 4

; 1733 : }

  0039c	5e		 pop	 esi
  0039d	0f 44 c1	 cmove	 eax, ecx
  003a0	5b		 pop	 ebx
  003a1	8b e5		 mov	 esp, ebp
  003a3	5d		 pop	 ebp
  003a4	c3		 ret	 0
$LN25@deflate_sl:

; 1732 :     return flush == Z_FINISH ? finish_done : block_done;

  003a5	33 c0		 xor	 eax, eax
  003a7	83 fb 04	 cmp	 ebx, 4
  003aa	5f		 pop	 edi
  003ab	0f 94 c0	 sete	 al

; 1733 : }

  003ae	5e		 pop	 esi
  003af	5b		 pop	 ebx
  003b0	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  003b7	8b e5		 mov	 esp, ebp
  003b9	5d		 pop	 ebp
  003ba	c3		 ret	 0
_deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflate_rle
_TEXT	SEGMENT
tv931 = -8						; size = 4
tv928 = -8						; size = 4
_flush$1$ = -4						; size = 4
_deflate_rle PROC					; COMDAT
; _s$ = ecx
; _flush$ = edx

; 1744 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 55 fc	 mov	 DWORD PTR _flush$1$[ebp], edx
  0000c	8b f1		 mov	 esi, ecx
$LN42@deflate_rl:

; 1745 :     int bflush;             /* set if current block must be flushed */
; 1746 :     uInt prev;              /* byte at distance one to match */
; 1747 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1748 : 
; 1749 :     for (;;) {
; 1750 :         /* Make sure that we always have enough lookahead, except
; 1751 :          * at the end of the input file. We need MAX_MATCH bytes
; 1752 :          * for the longest encodable run.
; 1753 :          */
; 1754 :         if (s->lookahead < MAX_MATCH) {

  0000e	8d 5e 6c	 lea	 ebx, DWORD PTR [esi+108]
$LL2@deflate_rl:
  00011	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  00014	8b c7		 mov	 eax, edi
  00016	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  0001c	73 26		 jae	 SHORT $LN10@deflate_rl

; 1755 :             fill_window(s);

  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 _fill_window

; 1756 :             if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {

  00025	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  00028	81 ff 02 01 00
	00		 cmp	 edi, 258		; 00000102H
  0002e	73 0a		 jae	 SHORT $LN9@deflate_rl
  00030	83 7d fc 00	 cmp	 DWORD PTR _flush$1$[ebp], 0
  00034	0f 84 9a 01 00
	00		 je	 $LN32@deflate_rl
$LN9@deflate_rl:

; 1757 :                 return need_more;
; 1758 :             }
; 1759 :             if (s->lookahead == 0) break; /* flush the current block */

  0003a	8b c7		 mov	 eax, edi
  0003c	85 ff		 test	 edi, edi
  0003e	0f 84 99 01 00
	00		 je	 $LN31@deflate_rl
$LN10@deflate_rl:

; 1760 :         }
; 1761 : 
; 1762 :         /* See how many times the previous byte repeats */
; 1763 :         s->match_length = 0;

  00044	33 d2		 xor	 edx, edx
  00046	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0

; 1764 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0004d	83 f8 03	 cmp	 eax, 3
  00050	72 6e		 jb	 SHORT $LN14@deflate_rl
  00052	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00055	85 c9		 test	 ecx, ecx
  00057	74 67		 je	 SHORT $LN14@deflate_rl

; 1765 :             scan = s->window + s->strstart - 1;

  00059	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0005c	03 c1		 add	 eax, ecx
  0005e	89 45 f8	 mov	 DWORD PTR tv928[ebp], eax

; 1766 :             prev = *scan;

  00061	8a 48 ff	 mov	 cl, BYTE PTR [eax-1]

; 1767 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  00064	3a 08		 cmp	 cl, BYTE PTR [eax]
  00066	75 58		 jne	 SHORT $LN14@deflate_rl
  00068	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  0006b	75 53		 jne	 SHORT $LN14@deflate_rl
  0006d	83 c0 02	 add	 eax, 2
  00070	3a 08		 cmp	 cl, BYTE PTR [eax]
  00072	75 4c		 jne	 SHORT $LN14@deflate_rl

; 1768 :                 strend = s->window + s->strstart + MAX_MATCH;

  00074	8b 55 f8	 mov	 edx, DWORD PTR tv928[ebp]
  00077	81 c2 02 01 00
	00		 add	 edx, 258		; 00000102H
  0007d	0f 1f 00	 npad	 3
$LL7@deflate_rl:

; 1769 :                 do {
; 1770 :                 } while (prev == *++scan && prev == *++scan &&
; 1771 :                          prev == *++scan && prev == *++scan &&
; 1772 :                          prev == *++scan && prev == *++scan &&
; 1773 :                          prev == *++scan && prev == *++scan &&

  00080	40		 inc	 eax
  00081	3a 08		 cmp	 cl, BYTE PTR [eax]
  00083	75 27		 jne	 SHORT $LN13@deflate_rl
  00085	40		 inc	 eax
  00086	3a 08		 cmp	 cl, BYTE PTR [eax]
  00088	75 22		 jne	 SHORT $LN13@deflate_rl
  0008a	40		 inc	 eax
  0008b	3a 08		 cmp	 cl, BYTE PTR [eax]
  0008d	75 1d		 jne	 SHORT $LN13@deflate_rl
  0008f	40		 inc	 eax
  00090	3a 08		 cmp	 cl, BYTE PTR [eax]
  00092	75 18		 jne	 SHORT $LN13@deflate_rl
  00094	40		 inc	 eax
  00095	3a 08		 cmp	 cl, BYTE PTR [eax]
  00097	75 13		 jne	 SHORT $LN13@deflate_rl
  00099	40		 inc	 eax
  0009a	3a 08		 cmp	 cl, BYTE PTR [eax]
  0009c	75 0e		 jne	 SHORT $LN13@deflate_rl
  0009e	40		 inc	 eax
  0009f	3a 08		 cmp	 cl, BYTE PTR [eax]
  000a1	75 09		 jne	 SHORT $LN13@deflate_rl
  000a3	40		 inc	 eax
  000a4	3a 08		 cmp	 cl, BYTE PTR [eax]
  000a6	75 04		 jne	 SHORT $LN13@deflate_rl
  000a8	3b c2		 cmp	 eax, edx
  000aa	72 d4		 jb	 SHORT $LL7@deflate_rl
$LN13@deflate_rl:

; 1774 :                          scan < strend);
; 1775 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  000ac	2b c2		 sub	 eax, edx
  000ae	8d 90 02 01 00
	00		 lea	 edx, DWORD PTR [eax+258]
  000b4	89 56 60	 mov	 DWORD PTR [esi+96], edx

; 1776 :                 if (s->match_length > s->lookahead)

  000b7	3b d7		 cmp	 edx, edi
  000b9	76 05		 jbe	 SHORT $LN14@deflate_rl

; 1777 :                     s->match_length = s->lookahead;

  000bb	89 7e 60	 mov	 DWORD PTR [esi+96], edi
  000be	8b d7		 mov	 edx, edi
$LN14@deflate_rl:

; 1778 :             }
; 1779 :         }
; 1780 : 
; 1781 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1782 :         if (s->match_length >= MIN_MATCH) {

  000c0	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  000c3	83 fa 03	 cmp	 edx, 3
  000c6	72 77		 jb	 SHORT $LN15@deflate_rl

; 1783 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1784 : 
; 1785 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  000c8	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  000ce	2c 03		 sub	 al, 3
  000d0	89 45 f8	 mov	 DWORD PTR tv931[ebp], eax
  000d3	ba 01 00 00 00	 mov	 edx, 1
  000d8	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  000de	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  000e2	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  000e8	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  000ee	8b 55 f8	 mov	 edx, DWORD PTR tv931[ebp]
  000f1	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  000f4	33 c9		 xor	 ecx, ecx
  000f6	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  000fc	0f b6 c2	 movzx	 eax, dl
  000ff	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR __length_code[eax]
  00106	66 ff 84 86 98
	04 00 00	 inc	 WORD PTR [esi+eax*4+1176]
  0010e	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR __dist_code
  00115	66 ff 84 86 88
	09 00 00	 inc	 WORD PTR [esi+eax*4+2440]
  0011d	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00123	48		 dec	 eax
  00124	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1786 : 
; 1787 :             s->lookahead -= s->match_length;

  0012a	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  0012d	0f 94 c1	 sete	 cl

; 1788 :             s->strstart += s->match_length;
; 1789 :             s->match_length = 0;

  00130	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  00137	29 46 74	 sub	 DWORD PTR [esi+116], eax
  0013a	01 46 6c	 add	 DWORD PTR [esi+108], eax

; 1790 :         } else {

  0013d	eb 53		 jmp	 SHORT $LN41@deflate_rl
$LN15@deflate_rl:

; 1791 :             /* No match, output a literal byte */
; 1792 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1793 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  0013f	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00142	33 ff		 xor	 edi, edi
  00144	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00147	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0014a	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00150	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  00156	66 89 3c 48	 mov	 WORD PTR [eax+ecx*2], di
  0015a	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00160	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  00166	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  00169	33 c9		 xor	 ecx, ecx
  0016b	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00171	0f b6 c2	 movzx	 eax, dl
  00174	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]
  0017c	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00182	48		 dec	 eax
  00183	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax
  00189	0f 94 c1	 sete	 cl

; 1794 :             s->lookahead--;

  0018c	ff 4e 74	 dec	 DWORD PTR [esi+116]

; 1795 :             s->strstart++;

  0018f	ff 46 6c	 inc	 DWORD PTR [esi+108]
$LN41@deflate_rl:

; 1796 :         }
; 1797 :         if (bflush) FLUSH_BLOCK(s, 0);

  00192	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]
  00195	85 c9		 test	 ecx, ecx
  00197	0f 84 74 fe ff
	ff		 je	 $LL2@deflate_rl
  0019d	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  001a0	85 c0		 test	 eax, eax
  001a2	78 07		 js	 SHORT $LN23@deflate_rl
  001a4	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  001a7	03 d0		 add	 edx, eax
  001a9	eb 02		 jmp	 SHORT $LN24@deflate_rl
$LN23@deflate_rl:
  001ab	33 d2		 xor	 edx, edx
$LN24@deflate_rl:
  001ad	2b f8		 sub	 edi, eax
  001af	8b ce		 mov	 ecx, esi
  001b1	6a 00		 push	 0
  001b3	57		 push	 edi
  001b4	e8 00 00 00 00	 call	 __tr_flush_block
  001b9	8b 03		 mov	 eax, DWORD PTR [ebx]
  001bb	83 c4 08	 add	 esp, 8
  001be	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c0	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  001c3	e8 00 00 00 00	 call	 _flush_pending
  001c8	8b 06		 mov	 eax, DWORD PTR [esi]
  001ca	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  001ce	0f 85 3a fe ff
	ff		 jne	 $LN42@deflate_rl
$LN32@deflate_rl:
  001d4	5f		 pop	 edi

; 1801 : }

  001d5	5e		 pop	 esi
  001d6	33 c0		 xor	 eax, eax
  001d8	5b		 pop	 ebx
  001d9	8b e5		 mov	 esp, ebp
  001db	5d		 pop	 ebp
  001dc	c3		 ret	 0
$LN31@deflate_rl:

; 1798 :     }
; 1799 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  001dd	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  001e0	85 c9		 test	 ecx, ecx
  001e2	78 07		 js	 SHORT $LN25@deflate_rl
  001e4	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  001e7	03 d1		 add	 edx, ecx
  001e9	eb 02		 jmp	 SHORT $LN26@deflate_rl
$LN25@deflate_rl:
  001eb	33 d2		 xor	 edx, edx
$LN26@deflate_rl:
  001ed	8b 5d fc	 mov	 ebx, DWORD PTR _flush$1$[ebp]
  001f0	33 c0		 xor	 eax, eax
  001f2	83 fb 04	 cmp	 ebx, 4
  001f5	0f 94 c0	 sete	 al
  001f8	50		 push	 eax
  001f9	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  001fc	2b c1		 sub	 eax, ecx
  001fe	8b ce		 mov	 ecx, esi
  00200	50		 push	 eax
  00201	e8 00 00 00 00	 call	 __tr_flush_block
  00206	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00209	83 c4 08	 add	 esp, 8
  0020c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0020e	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  00211	e8 00 00 00 00	 call	 _flush_pending
  00216	8b 06		 mov	 eax, DWORD PTR [esi]
  00218	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0021c	75 14		 jne	 SHORT $LN19@deflate_rl
  0021e	33 c0		 xor	 eax, eax
  00220	b9 02 00 00 00	 mov	 ecx, 2
  00225	5f		 pop	 edi
  00226	83 fb 04	 cmp	 ebx, 4

; 1801 : }

  00229	5e		 pop	 esi
  0022a	0f 44 c1	 cmove	 eax, ecx
  0022d	5b		 pop	 ebx
  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c3		 ret	 0
$LN19@deflate_rl:

; 1800 :     return flush == Z_FINISH ? finish_done : block_done;

  00232	33 c0		 xor	 eax, eax
  00234	83 fb 04	 cmp	 ebx, 4
  00237	5f		 pop	 edi
  00238	0f 94 c0	 sete	 al

; 1801 : }

  0023b	5e		 pop	 esi
  0023c	5b		 pop	 ebx
  0023d	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c3		 ret	 0
_deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\git\mcferront\anttrap-engine\3rdparty\zlib\zlib-1.2.5\deflate.c
;	COMDAT _deflate_huff
_TEXT	SEGMENT
_deflate_huff PROC					; COMDAT
; _s$ = ecx
; _flush$ = edx

; 1810 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b fa		 mov	 edi, edx
  00005	8b f1		 mov	 esi, ecx
$LL2@deflate_hu:

; 1811 :     int bflush;             /* set if current block must be flushed */
; 1812 : 
; 1813 :     for (;;) {
; 1814 :         /* Make sure that we have a literal to write. */
; 1815 :         if (s->lookahead == 0) {

  00007	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  0000b	75 11		 jne	 SHORT $LN6@deflate_hu

; 1816 :             fill_window(s);

  0000d	8b ce		 mov	 ecx, esi
  0000f	e8 00 00 00 00	 call	 _fill_window

; 1817 :             if (s->lookahead == 0) {

  00014	83 7e 74 00	 cmp	 DWORD PTR [esi+116], 0
  00018	0f 84 98 00 00
	00		 je	 $LN18@deflate_hu
$LN6@deflate_hu:

; 1819 :                     return need_more;
; 1820 :                 break;      /* flush the current block */
; 1821 :             }
; 1822 :         }
; 1823 : 
; 1824 :         /* Output a literal byte */
; 1825 :         s->match_length = 0;
; 1826 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1827 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  0001e	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00021	33 db		 xor	 ebx, ebx
  00023	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00026	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  0002d	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00030	8b 8e a0 16 00
	00		 mov	 ecx, DWORD PTR [esi+5792]
  00036	8b 86 a4 16 00
	00		 mov	 eax, DWORD PTR [esi+5796]
  0003c	66 89 1c 48	 mov	 WORD PTR [eax+ecx*2], bx
  00040	8b 86 a0 16 00
	00		 mov	 eax, DWORD PTR [esi+5792]
  00046	8b 8e 98 16 00
	00		 mov	 ecx, DWORD PTR [esi+5784]
  0004c	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
  0004f	ff 86 a0 16 00
	00		 inc	 DWORD PTR [esi+5792]
  00055	0f b6 c2	 movzx	 eax, dl
  00058	66 ff 84 86 94
	00 00 00	 inc	 WORD PTR [esi+eax*4+148]

; 1828 :         s->lookahead--;
; 1829 :         s->strstart++;

  00060	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  00063	8b 86 9c 16 00
	00		 mov	 eax, DWORD PTR [esi+5788]
  00069	41		 inc	 ecx
  0006a	ff 4e 74	 dec	 DWORD PTR [esi+116]
  0006d	48		 dec	 eax
  0006e	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  00071	39 86 a0 16 00
	00		 cmp	 DWORD PTR [esi+5792], eax

; 1830 :         if (bflush) FLUSH_BLOCK(s, 0);

  00077	75 8e		 jne	 SHORT $LL2@deflate_hu
  00079	8b 46 5c	 mov	 eax, DWORD PTR [esi+92]
  0007c	85 c0		 test	 eax, eax
  0007e	78 07		 js	 SHORT $LN12@deflate_hu
  00080	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00083	03 d0		 add	 edx, eax
  00085	eb 02		 jmp	 SHORT $LN13@deflate_hu
$LN12@deflate_hu:
  00087	33 d2		 xor	 edx, edx
$LN13@deflate_hu:
  00089	2b c8		 sub	 ecx, eax
  0008b	6a 00		 push	 0
  0008d	51		 push	 ecx
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 __tr_flush_block
  00095	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00098	83 c4 08	 add	 esp, 8
  0009b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0009d	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000a0	e8 00 00 00 00	 call	 _flush_pending
  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	39 58 10	 cmp	 DWORD PTR [eax+16], ebx
  000aa	0f 85 57 ff ff
	ff		 jne	 $LL2@deflate_hu
$LN19@deflate_hu:
  000b0	5f		 pop	 edi

; 1834 : }

  000b1	5e		 pop	 esi
  000b2	33 c0		 xor	 eax, eax
  000b4	5b		 pop	 ebx
  000b5	c3		 ret	 0
$LN18@deflate_hu:

; 1818 :                 if (flush == Z_NO_FLUSH)

  000b6	85 ff		 test	 edi, edi
  000b8	74 f6		 je	 SHORT $LN19@deflate_hu

; 1831 :     }
; 1832 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  000ba	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  000bd	85 c9		 test	 ecx, ecx
  000bf	78 07		 js	 SHORT $LN14@deflate_hu
  000c1	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  000c4	03 d1		 add	 edx, ecx
  000c6	eb 02		 jmp	 SHORT $LN15@deflate_hu
$LN14@deflate_hu:
  000c8	33 d2		 xor	 edx, edx
$LN15@deflate_hu:
  000ca	33 c0		 xor	 eax, eax
  000cc	83 ff 04	 cmp	 edi, 4
  000cf	0f 94 c0	 sete	 al
  000d2	50		 push	 eax
  000d3	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000d6	2b c1		 sub	 eax, ecx
  000d8	8b ce		 mov	 ecx, esi
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 __tr_flush_block
  000e0	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  000e3	83 c4 08	 add	 esp, 8
  000e6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000e8	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  000eb	e8 00 00 00 00	 call	 _flush_pending
  000f0	8b 06		 mov	 eax, DWORD PTR [esi]
  000f2	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000f6	75 11		 jne	 SHORT $LN10@deflate_hu
  000f8	33 c0		 xor	 eax, eax
  000fa	b9 02 00 00 00	 mov	 ecx, 2
  000ff	83 ff 04	 cmp	 edi, 4
  00102	5f		 pop	 edi

; 1834 : }

  00103	5e		 pop	 esi
  00104	0f 44 c1	 cmove	 eax, ecx
  00107	5b		 pop	 ebx
  00108	c3		 ret	 0
$LN10@deflate_hu:

; 1833 :     return flush == Z_FINISH ? finish_done : block_done;

  00109	33 c0		 xor	 eax, eax
  0010b	83 ff 04	 cmp	 edi, 4
  0010e	5f		 pop	 edi
  0010f	0f 94 c0	 sete	 al

; 1834 : }

  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [eax*2+1]
  0011b	c3		 ret	 0
_deflate_huff ENDP
_TEXT	ENDS
END
